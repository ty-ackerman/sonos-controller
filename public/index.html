<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Sonos Controller</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3ClinearGradient id='wood' x1='0' y1='0' x2='0' y2='100'%3E%3Cstop offset='0' stop-color='%23d4a574'/%3E%3Cstop offset='1' stop-color='%23c8956a'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect fill='url(%23wood)' width='100' height='100'/%3E%3Crect fill='%23a67c52' x='0' y='0' width='100' height='15'/%3E%3Crect fill='%23a67c52' x='0' y='20' width='15' height='60'/%3E%3Crect fill='%23a67c52' x='85' y='20' width='15' height='60'/%3E%3Crect fill='%238b6f47' x='20' y='40' width='60' height='15'/%3E%3Crect fill='%238b6f47' x='20' y='60' width='60' height='15'/%3E%3Crect fill='%23404040' x='70' y='70' width='20' height='20' rx='2'/%3E%3Ccircle fill='%23ffd700' cx='85' cy='15' r='6'/%3E%3Cpath fill='%23ffffff' opacity='0.7' d='M25 25 Q35 15 45 25 T65 25'/%3E%3Cpath fill='%23ffffff' opacity='0.5' d='M20 30 Q30 20 40 30 T60 30'/%3E%3C/svg%3E" />
    
    <!-- Apple Touch Icon (for iOS Home Screen) -->
    <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3ClinearGradient id='wood' x1='0' y1='0' x2='0' y2='100'%3E%3Cstop offset='0' stop-color='%23d4a574'/%3E%3Cstop offset='1' stop-color='%23c8956a'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect fill='url(%23wood)' width='100' height='100'/%3E%3Crect fill='%23a67c52' x='0' y='0' width='100' height='15'/%3E%3Crect fill='%23a67c52' x='0' y='20' width='15' height='60'/%3E%3Crect fill='%23a67c52' x='85' y='20' width='15' height='60'/%3E%3Crect fill='%238b6f47' x='20' y='40' width='60' height='15'/%3E%3Crect fill='%238b6f47' x='20' y='60' width='60' height='15'/%3E%3Crect fill='%23404040' x='70' y='70' width='20' height='20' rx='2'/%3E%3Ccircle fill='%23ffd700' cx='85' cy='15' r='6'/%3E%3Cpath fill='%23ffffff' opacity='0.7' d='M25 25 Q35 15 45 25 T65 25'/%3E%3Cpath fill='%23ffffff' opacity='0.5' d='M20 30 Q30 20 40 30 T60 30'/%3E%3C/svg%3E" />
    
    <!-- Open Graph / Social Sharing -->
    <meta property="og:image" content="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3ClinearGradient id='wood' x1='0' y1='0' x2='0' y2='100'%3E%3Cstop offset='0' stop-color='%23d4a574'/%3E%3Cstop offset='1' stop-color='%23c8956a'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect fill='url(%23wood)' width='100' height='100'/%3E%3Crect fill='%23a67c52' x='0' y='0' width='100' height='15'/%3E%3Crect fill='%23a67c52' x='0' y='20' width='15' height='60'/%3E%3Crect fill='%23a67c52' x='85' y='20' width='15' height='60'/%3E%3Crect fill='%238b6f47' x='20' y='40' width='60' height='15'/%3E%3Crect fill='%238b6f47' x='20' y='60' width='60' height='15'/%3E%3Crect fill='%23404040' x='70' y='70' width='20' height='20' rx='2'/%3E%3Ccircle fill='%23ffd700' cx='85' cy='15' r='6'/%3E%3Cpath fill='%23ffffff' opacity='0.7' d='M25 25 Q35 15 45 25 T65 25'/%3E%3Cpath fill='%23ffffff' opacity='0.5' d='M20 30 Q30 20 40 30 T60 30'/%3E%3C/svg%3E" />
    <meta property="og:title" content="Sonos Controller" />
    <meta property="og:type" content="website" />
    
    <!-- Web App Manifest -->
    <link rel="manifest" href="/manifest.json" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="apple-mobile-web-app-title" content="Sonos Controller" />
    <style>
      :root {
        color-scheme: light dark;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
        --bg-primary: #ffffff;
        --bg-secondary: #f8f9fa;
        --bg-tertiary: #f1f3f5;
        --text-primary: #1a1a1a;
        --text-secondary: #6b7280;
        --text-tertiary: #9ca3af;
        --border-color: #e5e7eb;
        --accent: #000000;
        --accent-hover: #1a1a1a;
        --success: #10b981;
        --error: #ef4444;
        --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      }

      @media (prefers-color-scheme: dark) {
        :root {
          --bg-primary: #0a0a0a;
          --bg-secondary: #141414;
          --bg-tertiary: #1a1a1a;
          --text-primary: #fafafa;
          --text-secondary: #a1a1aa;
          --text-tertiary: #71717a;
          --border-color: #27272a;
          --accent: #ffffff;
          --accent-hover: #f4f4f5;
        }
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        background: var(--bg-secondary);
        color: var(--text-primary);
        min-height: 100vh;
        display: flex;
        align-items: stretch;
        justify-content: center;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .container {
        width: min(480px, 100vw);
        padding: 20px;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        gap: 24px;
      }

      .header-wrapper {
        position: sticky;
        top: 0;
        z-index: 50;
        background: var(--bg-secondary);
        margin: -20px -20px 0 -20px;
        padding: 12px 20px;
        border-bottom: 1px solid var(--border-color);
        box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
      }

      .header-container {
        display: grid;
        grid-template-columns: 40px 1fr 40px;
        align-items: center;
        gap: 12px;
      }

      .hamburger-menu-btn {
        width: 40px;
        height: 40px;
        border: none;
        background: transparent;
        color: var(--text-primary);
        cursor: pointer;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        gap: 5px;
        padding: 8px;
        border-radius: 8px;
        transition: background 0.2s ease;
      }


      .hamburger-menu-btn span {
        display: block;
        width: 20px;
        height: 2px;
        background: currentColor;
        border-radius: 1px;
        transition: all 0.3s ease;
      }

      h1 {
        font-size: 1.5rem;
        font-weight: 600;
        margin: 0;
        grid-column: 2;
        text-align: center;
        letter-spacing: -0.02em;
      }

      .household-title {
        font-size: 1.125rem;
        font-weight: 600;
        margin: 8px 0;
        text-align: center;
        color: var(--text-primary);
        min-height: 1.5rem;
      }

      p.status {
        margin: 0;
        text-align: center;
        font-weight: 500;
        font-size: 0.875rem;
      }

      p.status.connected {
        color: var(--success);
      }

      p.status.disconnected {
        color: var(--error);
      }

      .feedback {
        min-height: 1.25rem;
        text-align: center;
        font-size: 0.875rem;
        color: var(--text-secondary);
      }

      .feedback.error {
        color: var(--error);
      }

      section {
        background: var(--bg-primary);
        border-radius: 16px;
        padding: 20px;
        border: 1px solid var(--border-color);
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      label {
        font-size: 0.8125rem;
        font-weight: 500;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.05em;
        margin-bottom: 8px;
        display: block;
      }

      select {
        width: 100%;
        padding: 12px 16px;
        border-radius: 10px;
        border: 1px solid var(--border-color);
        background: var(--bg-primary);
        color: var(--text-primary);
        font-size: 0.9375rem;
        font-weight: 500;
        appearance: none;
        cursor: pointer;
        transition: border-color 0.2s ease;
      }


      button {
        border: none;
        border-radius: 10px;
        padding: 12px 20px;
        font-size: 0.9375rem;
        font-weight: 500;
        background: var(--accent);
        color: var(--bg-primary);
        cursor: pointer;
        transition: all 0.2s ease;
      }



      button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }

      button.secondary {
        background: var(--bg-tertiary);
        color: var(--text-primary);
      }


      .controls,
      .volume {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .control-buttons {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
      }

      .control-buttons button {
        padding: 14px 12px;
        font-size: 0.875rem;
      }

      .control-buttons button:first-child {
        grid-column: 1 / -1;
        padding: 16px;
        font-size: 0.9375rem;
      }

      .slider-row {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      input[type='range'] {
        width: 100%;
        height: 6px;
        accent-color: var(--accent);
        cursor: pointer;
      }

      .volume-value {
        min-width: 3.5rem;
        text-align: right;
        font-variant-numeric: tabular-nums;
        font-size: 0.875rem;
        font-weight: 500;
        color: var(--text-secondary);
      }

      .group-chip {
        display: inline-flex;
        align-items: center;
        padding: 10px 16px;
        border-radius: 10px;
        border: 1px solid var(--border-color);
        background: var(--bg-tertiary);
        font-size: 0.875rem;
        font-weight: 500;
        min-width: 140px;
        justify-content: center;
        color: var(--text-primary);
      }

      .settings-row {
        display: grid;
        grid-template-columns: 1fr auto auto;
        gap: 12px;
        align-items: center;
        margin-bottom: 12px;
        background: var(--bg-secondary);
        padding: 16px;
        border-radius: 12px;
        border: 1px solid var(--border-color);
      }

      .favorites {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .vibe-filters {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
        margin-bottom: 4px;
      }

      .vibe-filter-btn {
        padding: 8px 16px;
        border-radius: 8px;
        border: 1px solid var(--border-color);
        background: var(--bg-secondary);
        color: var(--text-secondary);
        font-size: 0.8125rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
      }



      .favorites-grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
      }

      .favorites-status {
        font-size: 0.875rem;
        color: var(--text-secondary);
      }

      .section-title {
        font-size: 0.9375rem;
        font-weight: 600;
        letter-spacing: -0.01em;
        color: var(--text-primary);
      }

      .playlist-card {
        display: flex;
        flex-direction: column;
        gap: 14px;
        padding: 16px;
        border-radius: 12px;
        border: 1px solid var(--border-color);
        background: var(--bg-primary);
        color: inherit;
        text-align: left;
        box-shadow: var(--shadow-sm);
        transition: all 0.2s ease;
        cursor: pointer;
      }


      .playlist-card-content {
        display: flex;
        align-items: center;
        gap: 14px;
      }


      .playlist-card.disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .playlist-card.loading {
        cursor: progress;
      }


      .playlist-art-wrapper {
        width: 60px;
        height: 60px;
        border-radius: 10px;
        overflow: hidden;
        flex-shrink: 0;
        background: var(--bg-tertiary);
        display: grid;
        place-items: center;
        box-shadow: var(--shadow-sm);
      }

      .playlist-art {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .playlist-meta {
        display: flex;
        flex-direction: column;
        gap: 6px;
        align-items: flex-start;
        flex: 1;
        min-width: 0;
      }

      .playlist-placeholder {
        font-size: 1.5rem;
        color: var(--text-tertiary);
      }

      .playlist-brand {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--text-tertiary);
        font-weight: 500;
      }

      .playlist-brand svg {
        width: 14px;
        height: 14px;
        fill: currentColor;
      }

      .playlist-name {
        font-size: 0.9375rem;
        font-weight: 500;
        color: var(--text-primary);
        line-height: 1.4;
        overflow: hidden;
        text-overflow: ellipsis;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        line-clamp: 2;
        -webkit-box-orient: vertical;
      }

      .playlist-status {
        font-size: 0.8125rem;
        color: var(--text-secondary);
      }

      .playlist-vibe-selector {
        display: flex;
        align-items: center;
        gap: 10px;
        padding-top: 12px;
        border-top: 1px solid var(--border-color);
      }

      .playlist-vibe-selector label {
        font-size: 0.8125rem;
        font-weight: 500;
        color: var(--text-secondary);
        white-space: nowrap;
      }

      .playlist-vibe-selector select {
        flex: 1;
        padding: 8px 12px;
        border-radius: 8px;
        border: 1px solid var(--border-color);
        background: var(--bg-secondary);
        color: var(--text-primary);
        font-size: 0.8125rem;
        font-weight: 500;
        appearance: none;
        cursor: pointer;
        transition: border-color 0.2s ease;
      }

      .playlist-vibe-pill {
        display: inline-flex;
        align-items: center;
        padding: 4px 10px;
        border-radius: 12px;
        font-size: 0.75rem;
        font-weight: 500;
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }

      .playlist-vibe-pill.down {
        background: #ffffff;
        color: #000000;
        border: 1px solid var(--border-color);
      }

      .playlist-vibe-pill.down-mid {
        background: #808080;
        color: #ffffff;
      }

      .playlist-vibe-pill.mid {
        background: #808080;
        color: #ffffff;
      }

      .favorites-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 12px;
      }

      .favorites-toggle {
        padding: 6px 12px;
        border-radius: 6px;
        border: 1px solid var(--border-color);
        background: var(--bg-secondary);
        color: var(--text-primary);
        font-size: 0.875rem;
        cursor: pointer;
        text-align: left;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        transition: all 0.2s ease;
      }

      .favorites-toggle:hover {
        background: var(--bg-tertiary);
      }

      .favorites-content {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .favorites-content.hidden {
        display: none;
      }


      .settings-actions {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-top: 8px;
        flex-wrap: wrap;
      }

      .settings-status {
        min-height: 1.2rem;
        font-size: 0.875rem;
        color: var(--text-secondary);
      }

      .rooms {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .room-card {
        display: flex;
        flex-direction: column;
        gap: 14px;
        padding: 16px;
        border-radius: 12px;
        background: var(--bg-primary);
        border: 1px solid var(--border-color);
        cursor: pointer;
        transition: all 0.2s ease;
      }



      .room-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      .room-name {
        font-weight: 500;
        font-size: 0.9375rem;
        color: var(--text-primary);
      }

      .room-group-label {
        font-size: 0.8125rem;
        color: var(--text-secondary);
        font-weight: 400;
      }

      .room-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .room-actions button {
        font-size: 0.8125rem;
        padding: 8px 14px;
        border-radius: 8px;
        background: var(--bg-tertiary);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
      }


      .volume-row {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .volume-row span {
        font-size: 0.875rem;
        min-width: 56px;
        font-weight: 500;
        color: var(--text-secondary);
      }

      .hidden {
        display: none !important;
      }

      #auth-bar {
        display: flex;
        gap: 8px;
        margin-bottom: 8px;
      }

      #auth-bar button {
        flex: 1;
      }

      .select-group {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .currently-playing {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: var(--bg-primary);
        border-top: 1px solid var(--border-color);
        padding: 12px 16px 24px 16px;
        display: none;
        z-index: 50;
        box-shadow: 0 -4px 6px -1px rgba(0, 0, 0, 0.1);
        max-height: 100vh;
        overflow-y: auto;
        transition: transform 0.3s ease-out;
        transform: translateY(0);
      }

      .currently-playing.visible {
        display: block;
      }

      .currently-playing.expanded {
        transform: translateY(0);
      }

      .currently-playing-content {
        max-width: 480px;
        margin: 0 auto;
        display: flex;
        align-items: center;
        gap: 12px;
        cursor: pointer;
      }


      .currently-playing-art {
        width: 56px;
        height: 56px;
        border-radius: 8px;
        overflow: hidden;
        flex-shrink: 0;
        background: var(--bg-tertiary);
        display: grid;
        place-items: center;
      }

      .currently-playing-art img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .currently-playing-art-placeholder {
        font-size: 1.25rem;
        color: var(--text-tertiary);
      }

      .currently-playing-info {
        flex: 1;
        min-width: 0;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .currently-playing-location {
        font-size: 0.75rem;
        color: var(--text-secondary);
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 4px;
      }

      .currently-playing-title {
        font-size: 0.9375rem;
        font-weight: 600;
        color: var(--text-primary);
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .currently-playing-artist {
        font-size: 0.8125rem;
        color: var(--text-secondary);
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .currently-playing-controls {
        display: flex;
        align-items: center;
        gap: 12px;
        flex-shrink: 0;
      }

      .currently-playing-group-indicator {
        width: 32px;
        height: 32px;
        border-radius: 6px;
        background: var(--bg-tertiary);
        border: 1px solid var(--border-color);
        display: grid;
        place-items: center;
        font-size: 0.75rem;
        font-weight: 600;
        color: var(--text-primary);
        position: relative;
      }

      .currently-playing-group-count {
        position: absolute;
        top: -4px;
        right: -4px;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: var(--accent);
        color: var(--bg-primary);
        font-size: 0.625rem;
        font-weight: 600;
        display: grid;
        place-items: center;
      }

      .currently-playing-play-btn {
        width: 56px;
        height: 56px;
        border-radius: 50%;
        background: var(--bg-primary);
        border: 2px solid var(--border-color);
        color: var(--text-primary);
        display: grid;
        place-items: center;
        cursor: pointer;
        transition: all 0.2s ease;
        flex-shrink: 0;
        box-shadow: var(--shadow-sm);
        padding: 0;
      }



      .currently-playing-play-btn svg {
        width: 24px;
        height: 24px;
        display: block;
      }

      .currently-playing-play-btn .play-icon {
        fill: currentColor;
      }

      .currently-playing-play-btn .pause-icon {
        display: none;
        stroke: currentColor;
        stroke-width: 2;
        stroke-linecap: round;
        stroke-linejoin: round;
      }

      .currently-playing-play-btn.playing .play-icon {
        display: none;
      }

      .currently-playing-play-btn.playing .pause-icon {
        display: block;
      }

      /* Hide play button when expanded */
      .currently-playing.expanded .currently-playing-play-btn {
        display: none;
      }

      .currently-playing-play-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      .currently-playing-volume {
        flex-direction: column;
        gap: 12px;
        margin-top: 0;
        padding: 0 16px;
        padding-top: 0;
        padding-bottom: 0;
        border-top: none;
        max-height: 0;
        overflow: hidden;
        opacity: 0;
        transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1), 
                    padding 0.4s cubic-bezier(0.4, 0, 0.2, 1), 
                    margin 0.4s cubic-bezier(0.4, 0, 0.2, 1), 
                    opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                    border-top 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .currently-playing.expanded .currently-playing-volume {
        margin-top: 12px;
        padding-top: 16px;
        padding-bottom: 8px;
        border-top: 1px solid var(--border-color);
        max-height: 500px;
        opacity: 1;
      }

      .currently-playing-room-volume {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px 0;
        min-height: 44px;
        border-top: 1px solid var(--border-color);
      }

      .currently-playing-room-volume:first-of-type {
        border-top: none;
      }

      .currently-playing-room-name {
        min-width: 100px;
        font-size: 0.875rem;
        font-weight: 500;
        color: var(--text-primary);
      }

      .currently-playing-room-slider {
        flex: 1;
        height: 4px;
        accent-color: var(--accent);
        cursor: pointer;
      }

      .currently-playing-room-value {
        min-width: 2.5rem;
        text-align: right;
        font-size: 0.8125rem;
        font-weight: 500;
        color: var(--text-secondary);
        font-variant-numeric: tabular-nums;
      }

      body {
        padding-bottom: 0;
      }

      body.has-playing {
        padding-bottom: 100px;
      }

      body.menu-open {
        overflow: hidden;
      }

      .menu-backdrop {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 998;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease;
      }

      .menu-backdrop.visible {
        opacity: 1;
        visibility: visible;
      }

      .menu-panel {
        position: fixed;
        top: 0;
        left: 0;
        bottom: 0;
        width: min(280px, 80vw);
        max-width: 280px;
        background: var(--bg-primary);
        border-right: 1px solid var(--border-color);
        z-index: 999;
        transform: translateX(-100%);
        transition: transform 0.3s ease;
        display: flex;
        flex-direction: column;
        box-shadow: var(--shadow-lg);
      }

      .menu-panel.open {
        transform: translateX(0);
      }

      .menu-header {
        padding: 20px;
        border-bottom: 1px solid var(--border-color);
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .menu-title {
        font-size: 1.125rem;
        font-weight: 600;
        color: var(--text-primary);
      }

      .menu-close-btn {
        width: 32px;
        height: 32px;
        border: none;
        background: transparent;
        color: var(--text-primary);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 6px;
        transition: background 0.2s ease;
      }


      .menu-items {
        flex: 1;
        padding: 12px 0;
        overflow-y: auto;
      }

      .menu-item {
        display: block;
        width: 100%;
        padding: 14px 20px;
        border: none;
        background: transparent;
        color: var(--text-primary);
        text-align: left;
        font-size: 0.9375rem;
        font-weight: 500;
        cursor: pointer;
        transition: background 0.2s ease;
      }



      .menu-signout {
        margin-top: auto;
        padding: 12px 0;
        border-top: 1px solid var(--border-color);
      }

      .menu-signout .menu-item {
        color: var(--error);
      }


      .currently-playing-playback-controls {
        display: none;
        justify-content: center;
        align-items: center;
        gap: 24px;
        margin: 20px 0 16px 0;
        padding: 0 16px;
      }

      .currently-playing.expanded .currently-playing-playback-controls {
        display: flex;
      }

      .playback-control-btn {
        width: 40px;
        height: 40px;
        border: none;
        background: transparent;
        color: var(--text-primary);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: all 0.2s ease;
        padding: 0;
      }



      .playback-control-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        transform: none;
      }

      .playback-control-btn svg {
        width: 20px;
        height: 20px;
        fill: currentColor;
      }

      .playback-control-btn.play-pause {
        width: 56px;
        height: 56px;
        background: var(--bg-primary);
        border: 2px solid var(--border-color);
        box-shadow: var(--shadow-sm);
      }


      .playback-control-btn.play-pause.playing {
        background: var(--accent);
        border-color: var(--accent);
        color: var(--bg-primary);
      }


      .playback-control-btn.play-pause svg {
        width: 24px;
        height: 24px;
      }

      /* Show/hide play/pause icons in expanded section */
      .playback-control-btn.play-pause #play-icon {
        display: block;
      }

      .playback-control-btn.play-pause #pause-icon {
        display: none;
      }

      .playback-control-btn.play-pause.playing #play-icon {
        display: none;
      }

      .playback-control-btn.play-pause.playing #pause-icon {
        display: block;
      }

      .currently-playing-master-volume {
        display: flex;
        flex-direction: column;
        gap: 12px;
        margin-bottom: 12px;
      }

      .master-volume-label {
        font-size: 0.875rem;
        font-weight: 600;
        color: var(--text-primary);
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }

      .master-volume-row {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .master-volume-slider {
        flex: 1;
        height: 4px;
        accent-color: var(--accent);
        cursor: pointer;
      }

      .master-volume-value {
        min-width: 2.5rem;
        text-align: right;
        font-size: 0.875rem;
        font-weight: 500;
        color: var(--text-secondary);
        font-variant-numeric: tabular-nums;
      }

      .playlist-management-section {
        margin-bottom: 32px;
      }

      .time-rules-section {
        margin-top: 32px;
        padding-top: 32px;
        border-top: 1px solid var(--border-color);
      }

      .time-rules-list {
        display: flex;
        flex-direction: column;
        gap: 12px;
        margin-bottom: 16px;
      }

      .time-rule-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 16px;
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        gap: 12px;
      }

      .time-rule-info {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .time-rule-time {
        font-size: 0.9375rem;
        font-weight: 500;
        color: var(--text-primary);
      }

      .time-rule-vibes {
        font-size: 0.8125rem;
        color: var(--text-secondary);
      }

      .time-rule-actions {
        display: flex;
        gap: 8px;
      }

      .time-rule-actions button {
        padding: 6px 12px;
        border-radius: 6px;
        border: 1px solid var(--border-color);
        background: var(--bg-tertiary);
        color: var(--text-primary);
        font-size: 0.8125rem;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .time-rule-actions button:hover {
        background: var(--bg-primary);
      }

      .time-rule-actions button.delete {
        color: var(--error);
      }

      .time-rule-actions button.delete:hover {
        background: var(--error);
        color: var(--bg-primary);
      }

      .add-rule-btn {
        padding: 10px 16px;
        border-radius: 8px;
        border: 1px solid var(--border-color);
        background: var(--accent);
        color: var(--bg-primary);
        font-size: 0.875rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .add-rule-btn:hover {
        background: var(--accent-hover);
      }

      .time-rule-editor-backdrop {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 1000;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
      }

      .time-rule-editor-backdrop.visible {
        opacity: 1;
        visibility: visible;
      }

      .time-rule-editor {
        position: relative;
        width: 100%;
        max-width: 500px;
        max-height: 90vh;
        overflow-y: auto;
        padding: 24px;
        background: var(--bg-primary);
        border: 1px solid var(--border-color);
        border-radius: 12px;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        transform: scale(0.95);
        transition: transform 0.3s ease;
      }

      .time-rule-editor-backdrop.visible .time-rule-editor {
        transform: scale(1);
      }

      .time-rule-editor-close {
        position: absolute;
        top: 16px;
        right: 16px;
        width: 32px;
        height: 32px;
        border: none;
        background: transparent;
        color: var(--text-primary);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 6px;
        transition: background 0.2s ease;
      }

      .time-rule-editor-close:hover {
        background: var(--bg-tertiary);
      }

      .time-rule-editor-title {
        font-size: 1rem;
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: 16px;
      }

      .time-rule-form {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .time-rule-field {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .time-rule-field label {
        font-size: 0.875rem;
        font-weight: 500;
        color: var(--text-primary);
      }

      .time-rule-field select {
        padding: 8px 12px;
        border-radius: 6px;
        border: 1px solid var(--border-color);
        background: var(--bg-primary);
        color: var(--text-primary);
        font-size: 0.875rem;
      }

      .time-rule-days {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .time-rule-day-checkbox {
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
        font-size: 0.875rem;
        color: var(--text-primary);
      }

      .time-rule-day-checkbox input[type="checkbox"] {
        width: 18px;
        height: 18px;
        cursor: pointer;
        accent-color: var(--accent);
      }

      .time-rule-vibes {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .time-rule-vibe-checkbox {
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
        font-size: 0.875rem;
        color: var(--text-primary);
      }

      .time-rule-vibe-checkbox input[type="checkbox"] {
        width: 18px;
        height: 18px;
        cursor: pointer;
        accent-color: var(--accent);
      }

      .time-rule-actions {
        display: flex;
        gap: 8px;
        margin-top: 8px;
      }

      .time-rule-actions button {
        padding: 8px 16px;
        border-radius: 6px;
        border: 1px solid var(--border-color);
        background: var(--bg-tertiary);
        color: var(--text-primary);
        font-size: 0.875rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .time-rule-actions button:hover {
        background: var(--bg-primary);
      }

      .time-rule-actions button:first-child {
        background: var(--accent);
        color: var(--bg-primary);
      }

      .time-rule-actions button:first-child:hover {
        background: var(--accent-hover);
      }

      .playlist-recommendations {
        margin-bottom: 32px;
        padding-bottom: 16px;
        border-bottom: 1px solid var(--border-color);
      }

      .recommendation-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 12px;
      }

      .recommendation-title {
        font-size: 0.9375rem;
        font-weight: 600;
        color: var(--text-primary);
      }

      .recommendation-rule-info {
        font-size: 0.8125rem;
        color: var(--text-secondary);
        margin-bottom: 12px;
      }

      .recommended-playlist {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px;
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        margin-bottom: 12px;
      }

      .recommended-playlist-art {
        width: 48px;
        height: 48px;
        border-radius: 6px;
        overflow: hidden;
        flex-shrink: 0;
        background: var(--bg-tertiary);
        display: grid;
        place-items: center;
      }

      .recommended-playlist-art img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .recommended-playlist-info {
        flex: 1;
        min-width: 0;
      }

      .recommended-playlist-name {
        font-size: 0.9375rem;
        font-weight: 500;
        color: var(--text-primary);
        margin-bottom: 2px;
      }

      .recommended-playlist-vibe {
        font-size: 0.8125rem;
        color: var(--text-secondary);
      }

      .recommended-playlist-actions {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .recommended-playlist-actions button {
        padding: 8px 16px;
        border-radius: 6px;
        border: 1px solid var(--border-color);
        background: var(--accent);
        color: var(--bg-primary);
        font-size: 0.8125rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .recommended-playlist-actions button:hover {
        background: var(--accent-hover);
      }

      .recommended-playlist-actions button.secondary {
        background: var(--bg-tertiary);
        color: var(--text-primary);
      }

      .recommended-playlist-actions button.secondary:hover {
        background: var(--bg-primary);
      }

      .alternatives-dropdown {
        margin-top: 12px;
      }

      .alternatives-toggle {
        width: 100%;
        padding: 8px 12px;
        border-radius: 6px;
        border: 1px solid var(--border-color);
        background: var(--bg-secondary);
        color: var(--text-primary);
        font-size: 0.875rem;
        cursor: pointer;
        text-align: left;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .alternatives-toggle:hover {
        background: var(--bg-tertiary);
      }

      .alternatives-list {
        margin-top: 8px;
        display: none;
        flex-direction: column;
        gap: 8px;
      }

      .alternatives-list.visible {
        display: flex;
      }

      .alternative-playlist {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 10px;
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .alternative-playlist:hover {
        background: var(--bg-tertiary);
      }

      .alternative-playlist-art {
        width: 40px;
        height: 40px;
        border-radius: 4px;
        overflow: hidden;
        flex-shrink: 0;
        background: var(--bg-tertiary);
        display: grid;
        place-items: center;
      }

      .alternative-playlist-art img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .alternative-playlist-info {
        flex: 1;
        min-width: 0;
      }

      .alternative-playlist-name {
        font-size: 0.875rem;
        font-weight: 500;
        color: var(--text-primary);
      }

      .alternative-playlist-vibe {
        font-size: 0.75rem;
        color: var(--text-secondary);
      }
    </style>
  </head>
  <body>
    <div id="menu-backdrop" class="menu-backdrop"></div>
    <div id="menu-panel" class="menu-panel">
      <div class="menu-header">
        <span class="menu-title">Menu</span>
        <button id="menu-close-btn" class="menu-close-btn" type="button" aria-label="Close menu">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" width="20" height="20">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      <div class="menu-items">
        <button id="menu-item-controls" class="menu-item active" type="button">Controls</button>
        <button id="menu-item-playlist-management" class="menu-item" type="button">Playlist Management</button>
        <button id="menu-item-settings" class="menu-item" type="button">Settings</button>
      </div>
      <div class="menu-signout">
        <button id="menu-item-signout" class="menu-item" type="button">Sign out</button>
      </div>
    </div>

    <main class="container">
      <div class="header-wrapper">
        <div class="header-container">
          <button id="hamburger-menu-btn" class="hamburger-menu-btn" type="button" aria-label="Open menu">
            <span></span>
            <span></span>
            <span></span>
          </button>
          <h1>Sonos Controller</h1>
        </div>
      </div>
      <p id="status" class="status disconnected">Checking connection…</p>
      <div id="feedback" class="feedback"></div>

      <div id="auth-bar" style="margin-bottom: 12px">
        <button id="signin-btn" onclick="login()">Sign in with Sonos</button>
      </div>

      <div id="app-panels" class="hidden">
        <div id="household-title" class="household-title"></div>

        <section id="panel-control">
          <div class="playlist-recommendations" id="playlist-recommendations">
            <div class="recommendation-header">
              <div class="recommendation-title">Recommended Playlist</div>
            </div>
            <div id="recommendation-rule-info" class="recommendation-rule-info"></div>
            <div id="recommended-playlist-container"></div>
            <div id="alternatives-dropdown" class="alternatives-dropdown"></div>
          </div>
          <div class="favorites">
            <div class="favorites-header">
              <span class="section-title">Favorites</span>
              <button id="favorites-toggle" class="favorites-toggle" type="button">
                View All Favorites <span>▼</span>
              </button>
            </div>
            <div id="favorites-content" class="favorites-content hidden">
              <div id="vibe-filters" class="vibe-filters"></div>
              <p id="favorites-status" class="favorites-status">Sign in to load favorites.</p>
              <div id="favorites-grid" class="favorites-grid"></div>
            </div>
          </div>
        </section>

        <section id="panel-playlist-management" class="hidden">
          <div class="playlist-management-section">
            <h3 class="section-title">Playlists</h3>
            <p id="playlist-management-status" class="favorites-status">Sign in to load playlists.</p>
            <div id="playlist-management-grid" class="favorites-grid"></div>
          </div>
          <div class="time-rules-section">
            <h3 class="section-title">Time-Based Rules</h3>
            <p class="favorites-status">Configure which vibes are allowed at different times of day.</p>
            <div id="time-rules-list"></div>
            <button id="add-time-rule-btn" type="button" class="add-rule-btn">Add Rule</button>
            <div id="time-rule-editor-backdrop" class="time-rule-editor-backdrop">
              <div id="time-rule-editor" class="time-rule-editor">
                <button id="time-rule-editor-close" class="time-rule-editor-close" type="button" aria-label="Close">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" width="20" height="20">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                  </svg>
                </button>
                <h4 id="time-rule-editor-title" class="time-rule-editor-title">Edit Time Rule</h4>
              <div class="time-rule-form">
                <div class="time-rule-field">
                  <label>Start Hour</label>
                  <select id="time-rule-start-hour">
                    <option value="0">12:00 AM</option>
                    <option value="1">1:00 AM</option>
                    <option value="2">2:00 AM</option>
                    <option value="3">3:00 AM</option>
                    <option value="4">4:00 AM</option>
                    <option value="5">5:00 AM</option>
                    <option value="6">6:00 AM</option>
                    <option value="7">7:00 AM</option>
                    <option value="8">8:00 AM</option>
                    <option value="9">9:00 AM</option>
                    <option value="10">10:00 AM</option>
                    <option value="11">11:00 AM</option>
                    <option value="12">12:00 PM</option>
                    <option value="13">1:00 PM</option>
                    <option value="14">2:00 PM</option>
                    <option value="15">3:00 PM</option>
                    <option value="16">4:00 PM</option>
                    <option value="17">5:00 PM</option>
                    <option value="18">6:00 PM</option>
                    <option value="19">7:00 PM</option>
                    <option value="20">8:00 PM</option>
                    <option value="21">9:00 PM</option>
                    <option value="22">10:00 PM</option>
                    <option value="23">11:00 PM</option>
                  </select>
                </div>
                <div class="time-rule-field">
                  <label>End Hour</label>
                  <select id="time-rule-end-hour">
                    <option value="0">12:00 AM</option>
                    <option value="1">1:00 AM</option>
                    <option value="2">2:00 AM</option>
                    <option value="3">3:00 AM</option>
                    <option value="4">4:00 AM</option>
                    <option value="5">5:00 AM</option>
                    <option value="6">6:00 AM</option>
                    <option value="7">7:00 AM</option>
                    <option value="8">8:00 AM</option>
                    <option value="9">9:00 AM</option>
                    <option value="10">10:00 AM</option>
                    <option value="11">11:00 AM</option>
                    <option value="12">12:00 PM</option>
                    <option value="13">1:00 PM</option>
                    <option value="14">2:00 PM</option>
                    <option value="15">3:00 PM</option>
                    <option value="16">4:00 PM</option>
                    <option value="17">5:00 PM</option>
                    <option value="18">6:00 PM</option>
                    <option value="19">7:00 PM</option>
                    <option value="20">8:00 PM</option>
                    <option value="21">9:00 PM</option>
                    <option value="22">10:00 PM</option>
                    <option value="23">11:00 PM</option>
                  </select>
                </div>
                <div class="time-rule-field">
                  <label>Days</label>
                  <div class="time-rule-days">
                    <label class="time-rule-day-checkbox">
                      <input type="checkbox" value="everyday" id="time-rule-day-everyday">
                      <span>Every day</span>
                    </label>
                    <label class="time-rule-day-checkbox">
                      <input type="checkbox" value="0" id="time-rule-day-0">
                      <span>Sunday</span>
                    </label>
                    <label class="time-rule-day-checkbox">
                      <input type="checkbox" value="1" id="time-rule-day-1">
                      <span>Monday</span>
                    </label>
                    <label class="time-rule-day-checkbox">
                      <input type="checkbox" value="2" id="time-rule-day-2">
                      <span>Tuesday</span>
                    </label>
                    <label class="time-rule-day-checkbox">
                      <input type="checkbox" value="3" id="time-rule-day-3">
                      <span>Wednesday</span>
                    </label>
                    <label class="time-rule-day-checkbox">
                      <input type="checkbox" value="4" id="time-rule-day-4">
                      <span>Thursday</span>
                    </label>
                    <label class="time-rule-day-checkbox">
                      <input type="checkbox" value="5" id="time-rule-day-5">
                      <span>Friday</span>
                    </label>
                    <label class="time-rule-day-checkbox">
                      <input type="checkbox" value="6" id="time-rule-day-6">
                      <span>Saturday</span>
                    </label>
                  </div>
                </div>
                <div class="time-rule-field">
                  <label>Allowed Vibes</label>
                  <div class="time-rule-vibes">
                    <label class="time-rule-vibe-checkbox">
                      <input type="checkbox" value="Down" id="time-rule-vibe-down">
                      <span>Down</span>
                    </label>
                    <label class="time-rule-vibe-checkbox">
                      <input type="checkbox" value="Down/Mid" id="time-rule-vibe-down-mid">
                      <span>Down/Mid</span>
                    </label>
                    <label class="time-rule-vibe-checkbox">
                      <input type="checkbox" value="Mid" id="time-rule-vibe-mid">
                      <span>Mid</span>
                    </label>
                  </div>
                </div>
                <div class="time-rule-actions">
                  <button id="time-rule-save-btn" type="button">Save</button>
                  <button id="time-rule-cancel-btn" type="button">Cancel</button>
                </div>
              </div>
            </div>
          </div>
        </section>

        <section id="panel-settings" class="hidden">
          <h3 class="section-title">Default Volumes (on play)</h3>
          <p id="settings-help" class="favorites-status">
            Set a default launch volume for each speaker. Leave blank to keep its current level.
          </p>
          <div id="settings-players"></div>
          <div class="settings-actions">
            <button id="settings-save" type="button">Save Defaults</button>
            <span id="settings-status" class="settings-status"></span>
          </div>
        </section>
      </div>

      <div id="currently-playing" class="currently-playing">
        <div class="currently-playing-content">
          <div class="currently-playing-art" id="currently-playing-art">
            <span class="currently-playing-art-placeholder">♪</span>
          </div>
          <div class="currently-playing-info">
            <div class="currently-playing-location" id="currently-playing-location">
              <span>No group selected</span>
            </div>
            <div class="currently-playing-title" id="currently-playing-title">
              Nothing playing
            </div>
            <div class="currently-playing-artist" id="currently-playing-artist">
              <span></span>
            </div>
          </div>
          <div class="currently-playing-controls">
            <div class="currently-playing-group-indicator" id="currently-playing-group-indicator" style="display: none;">
              <span>🔊</span>
              <span class="currently-playing-group-count" id="currently-playing-group-count" style="display: none;">1</span>
            </div>
            <button class="currently-playing-play-btn" id="currently-playing-play-btn" type="button">
              <svg class="play-icon" viewBox="0 0 24 24" fill="currentColor">
                <path d="M8 5v14l11-7z" />
              </svg>
              <svg class="pause-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="6" y="4" width="4" height="16" rx="1"/>
                <rect x="14" y="4" width="4" height="16" rx="1"/>
              </svg>
            </button>
          </div>
        </div>
        <div class="currently-playing-playback-controls" id="currently-playing-playback-controls">
          <button class="playback-control-btn" id="playback-prev-btn" type="button" aria-label="Previous">
            <svg viewBox="0 0 24 24" fill="currentColor">
              <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/>
            </svg>
          </button>
          <button class="playback-control-btn play-pause" id="playback-play-pause-btn" type="button" aria-label="Play/Pause">
            <svg id="play-icon" viewBox="0 0 24 24" fill="currentColor">
              <path d="M8 5v14l11-7z"/>
            </svg>
            <svg id="pause-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
              <rect x="6" y="4" width="4" height="16" rx="1"/>
              <rect x="14" y="4" width="4" height="16" rx="1"/>
            </svg>
          </button>
          <button class="playback-control-btn" id="playback-next-btn" type="button" aria-label="Next">
            <svg viewBox="0 0 24 24" fill="currentColor">
              <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/>
            </svg>
          </button>
        </div>
        <div class="currently-playing-volume" id="currently-playing-volume">
          <div class="currently-playing-master-volume" id="currently-playing-master-volume">
            <div class="master-volume-label">Master Volume</div>
            <div class="master-volume-row">
              <input id="master-volume-slider" type="range" class="master-volume-slider" min="0" max="100" step="1" value="0" />
              <span id="master-volume-value" class="master-volume-value">0%</span>
            </div>
          </div>
          <div id="currently-playing-rooms-list"></div>
        </div>
      </div>
    </main>

    <script>
      const SELECT_GROUP_MESSAGE = 'Ready to play';
      const READY_MESSAGE = 'Ready to play';
      const FAVORITE_SUCCESS_MESSAGE = 'Loaded • Shuffle / Repeat / Crossfade ON';
      const FAVORITE_ERROR_MESSAGE = 'Favorite failed to start';
      const LOADING_MESSAGE = 'Loading…';
      const FAVORITE_SUCCESS_TOAST = 'Favorite loaded with shuffle, repeat, crossfade.';

      const statusLabel = document.getElementById('status');
      const feedbackLabel = document.getElementById('feedback');
      const signinButton = document.getElementById('signin-btn');
      const panelsContainer = document.getElementById('app-panels');
      const panelControl = document.getElementById('panel-control');
      const panelSettings = document.getElementById('panel-settings');
      const panelPlaylistManagement = document.getElementById('panel-playlist-management');
      const householdTitle = document.getElementById('household-title');
      const favoritesGrid = document.getElementById('favorites-grid');
      const favoritesStatus = document.getElementById('favorites-status');
      const vibeFiltersContainer = document.getElementById('vibe-filters');
      const favoritesToggle = document.getElementById('favorites-toggle');
      const favoritesContent = document.getElementById('favorites-content');
      const currentlyPlayingPanel = document.getElementById('currently-playing');
      const currentlyPlayingArt = document.getElementById('currently-playing-art');
      const currentlyPlayingLocation = document.getElementById('currently-playing-location');
      const currentlyPlayingTitle = document.getElementById('currently-playing-title');
      const currentlyPlayingArtist = document.getElementById('currently-playing-artist');
      const currentlyPlayingGroupIndicator = document.getElementById('currently-playing-group-indicator');
      const currentlyPlayingGroupCount = document.getElementById('currently-playing-group-count');
      const currentlyPlayingPlayBtn = document.getElementById('currently-playing-play-btn');
      const currentlyPlayingVolume = document.getElementById('currently-playing-volume');
      const currentlyPlayingRoomsList = document.getElementById('currently-playing-rooms-list');
      const recommendedPlaylistContainer = document.getElementById('recommended-playlist-container');
      const alternativesDropdown = document.getElementById('alternatives-dropdown');
      const recommendationRuleInfo = document.getElementById('recommendation-rule-info');
      
      // Hamburger menu elements
      const hamburgerMenuBtn = document.getElementById('hamburger-menu-btn');
      const menuBackdrop = document.getElementById('menu-backdrop');
      const menuPanel = document.getElementById('menu-panel');
      const menuCloseBtn = document.getElementById('menu-close-btn');
      const menuItemControls = document.getElementById('menu-item-controls');
      const menuItemPlaylistManagement = document.getElementById('menu-item-playlist-management');
      const menuItemSettings = document.getElementById('menu-item-settings');
      const menuItemSignout = document.getElementById('menu-item-signout');
      
      // Playback controls in now-playing section
      const playbackPrevBtn = document.getElementById('playback-prev-btn');
      const playbackPlayPauseBtn = document.getElementById('playback-play-pause-btn');
      const playbackNextBtn = document.getElementById('playback-next-btn');
      const playIcon = document.getElementById('play-icon');
      const pauseIcon = document.getElementById('pause-icon');
      
      // Master volume controls
      const masterVolumeSlider = document.getElementById('master-volume-slider');
      const masterVolumeValue = document.getElementById('master-volume-value');
      
      // Track panel state to prevent flickering
      let panelShouldBeVisible = false;
      let hidePanelTimeout = null;
      let currentHouseholdName = null;
      
const settingsPlayersWrap = document.getElementById('settings-players');
const settingsSaveButton = document.getElementById('settings-save');
const settingsStatusLabel = document.getElementById('settings-status');
const settingsHelpLabel = document.getElementById('settings-help');

// Playlist management elements
const playlistManagementGrid = document.getElementById('playlist-management-grid');
const playlistManagementStatus = document.getElementById('playlist-management-status');
const timeRulesList = document.getElementById('time-rules-list');
const addTimeRuleBtn = document.getElementById('add-time-rule-btn');
const timeRuleEditorBackdrop = document.getElementById('time-rule-editor-backdrop');
const timeRuleEditor = document.getElementById('time-rule-editor');
const timeRuleEditorClose = document.getElementById('time-rule-editor-close');
const timeRuleStartHour = document.getElementById('time-rule-start-hour');
const timeRuleEndHour = document.getElementById('time-rule-end-hour');
const timeRuleVibeDown = document.getElementById('time-rule-vibe-down');
const timeRuleVibeDownMid = document.getElementById('time-rule-vibe-down-mid');
const timeRuleVibeMid = document.getElementById('time-rule-vibe-mid');
const timeRuleSaveBtn = document.getElementById('time-rule-save-btn');
const timeRuleCancelBtn = document.getElementById('time-rule-cancel-btn');

settingsSaveButton.disabled = true;
settingsStatusLabel.textContent = '';

      let isSonosConnected = false;
      let currentHouseholdId = null;
      let currentGroupId = null;
      let currentGroupName = 'No group selected';
      let currentActiveFavoriteId = null;
      let currentActiveFavoriteIdTimestamp = 0; // Track when favorite was set
      const favoritesRegistry = new Map();
      let latestPlayers = [];
      let latestGroups = [];
      let refreshTimer = null;
      let playlistVibes = {};
      let currentVibeFilter = null;
      let playbackRefreshTimer = null;
      let currentPlaybackState = null;
      // Track playback state locally (since API is unreliable)
      let trackedPlaybackState = null; // 'PLAYING' | 'PAUSED' | null
      let currentImageUrl = null;
      let lastPlayActionTime = 0; // Track when last play action occurred to prevent refresh interference

      function login() {
        window.location.href = '/auth/sonos/login';
      }

async function signout() {
  try {
    await fetch('/auth/signout', { method: 'POST' });
  } catch (error) {
    console.error('Sign out failed:', error);
  }
  closeMenu();
  setAuthUI(false);
  showFeedback('Signed out of Sonos.');
}

function openMenu() {
  menuPanel.classList.add('open');
  menuBackdrop.classList.add('visible');
  document.body.classList.add('menu-open');
}

function closeMenu() {
  menuPanel.classList.remove('open');
  menuBackdrop.classList.remove('visible');
  document.body.classList.remove('menu-open');
}

function showView(name) {
  const isControl = name === 'control';
  const isPlaylistManagement = name === 'playlist-management';
  const isSettings = name === 'settings';
  
  menuItemControls.classList.toggle('active', isControl);
  menuItemPlaylistManagement.classList.toggle('active', isPlaylistManagement);
  menuItemSettings.classList.toggle('active', isSettings);
  
  panelControl.classList.toggle('hidden', !isControl);
  panelPlaylistManagement.classList.toggle('hidden', !isPlaylistManagement);
  panelSettings.classList.toggle('hidden', !isSettings);
  
  closeMenu();
  
  if (isSettings) {
    renderSettings();
  } else if (isPlaylistManagement) {
    renderPlaylistManagement();
  } else if (isControl) {
    // Update recommendations when control panel is shown
    updatePlaylistRecommendations();
  }
}

// Hamburger menu event handlers
hamburgerMenuBtn.addEventListener('click', () => {
  openMenu();
});

menuCloseBtn.addEventListener('click', () => {
  closeMenu();
});

menuBackdrop.addEventListener('click', () => {
  closeMenu();
});

menuItemControls.addEventListener('click', () => {
  showView('control');
});

menuItemPlaylistManagement.addEventListener('click', () => {
  showView('playlist-management');
});

menuItemSettings.addEventListener('click', () => {
  showView('settings');
});

menuItemSignout.addEventListener('click', () => {
  signout();
});

// Favorites toggle handler
favoritesToggle.addEventListener('click', () => {
  const isHidden = favoritesContent.classList.contains('hidden');
  favoritesContent.classList.toggle('hidden', !isHidden);
  const arrow = favoritesToggle.querySelector('span');
  if (arrow) {
    arrow.textContent = isHidden ? '▲' : '▼';
  }
  favoritesToggle.innerHTML = `${isHidden ? 'Hide' : 'View'} All Favorites <span>${isHidden ? '▲' : '▼'}</span>`;
});

function setAuthUI(loggedIn) {
  signinButton.classList.toggle('hidden', loggedIn);
  panelsContainer.classList.toggle('hidden', !loggedIn);
  if (!loggedIn) {
    showView('control');
    closeMenu();
  }
  updateConnectionStatus(loggedIn);
}

async function checkAuthAndInit() {
  try {
    const response = await fetch('/auth/status');
    if (!response.ok) {
      throw new Error('Failed to check auth status');
    }

    const state = await response.json();
    const loggedIn = Boolean(state.loggedIn);
    setAuthUI(loggedIn);
    showView('control');

    if (loggedIn) {
      await refreshUI();
    }
  } catch (error) {
          console.error('Auth status check failed:', error);
          setAuthUI(false);
        }
      }

      // Playback control handlers for now-playing section
      playbackPrevBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        await handlePlaybackAction('previous');
      });

      playbackPlayPauseBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        await handlePlaybackAction('playpause');
      });

      playbackNextBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        await handlePlaybackAction('next');
      });

      // Master volume handler
      masterVolumeSlider.addEventListener('input', (e) => {
        masterVolumeValue.textContent = `${Number(e.target.value)}%`;
      });

      masterVolumeSlider.addEventListener('change', async (e) => {
        e.stopPropagation();
        await setMasterVolume(Number(e.target.value));
      });
      const authMessages = {
        success: 'Sonos authorization complete. Ready to control playback.',
        error: 'Authorization failed. Please try logging in again.',
        missing_code: 'Login response missing authorization code.',
        invalid_state: 'Login validation failed. Please retry.'
      };

      function applyAuthFeedback() {
        const params = new URLSearchParams(window.location.search);
        const state = params.get('auth');

        if (state && authMessages[state]) {
          showFeedback(authMessages[state], state !== 'success');
          params.delete('auth');
          const newUrl = window.location.pathname + (params.toString() ? `?${params}` : '');
          window.history.replaceState({}, '', newUrl);
        }
      }

      function updateConnectionStatus(connected) {
        statusLabel.classList.toggle('connected', connected);
        statusLabel.classList.toggle('disconnected', !connected);
        statusLabel.textContent = connected ? 'Connected to Sonos' : 'Not connected';
        isSonosConnected = connected;

        if (!connected) {
          currentHouseholdId = null;
          currentHouseholdName = null;
          householdTitle.textContent = '';
          favoritesStatus.textContent = 'Login required to load favorites.';
          vibeFiltersContainer.innerHTML = '';
          currentGroupId = null;
          currentGroupName = 'No group selected';
          updateActiveGroupDisplay();
          currentActiveFavoriteId = null;
          settingsPlayersWrap.innerHTML = '';
          settingsStatusLabel.textContent = '';
          if (settingsHelpLabel) {
            settingsHelpLabel.textContent = 'Sign in to load speakers.';
          }
          stopPlaybackRefresh();
          currentlyPlayingPanel.classList.remove('visible');
          document.body.classList.remove('has-playing');
        }

        settingsSaveButton.disabled = !connected;
        evaluateFavoritesAvailability();
      }

      function showFeedback(message, isError = false) {
        feedbackLabel.textContent = message ?? '';
        feedbackLabel.classList.toggle('error', Boolean(isError));
      }

      function getSelectedGroupId() {
        return currentGroupId;
      }

      function updateActiveGroupDisplay() {
        // Group display removed - groups are auto-created
      }


      async function loadHouseholds() {
        try {
          const response = await fetch('/api/households');

          if (response.status === 401) {
            setAuthUI(false);
            showFeedback('Login required to load Sonos households.', true);
            favoritesStatus.textContent = 'Login required to load favorites.';
            return;
          }

          if (!response.ok) {
            throw new Error(await response.text());
          }

          const data = await response.json();
          const households = Array.isArray(data.households) ? data.households : [];

          if (!households.length) {
            setAuthUI(true);
            showFeedback('No households returned for this account.', true);
            currentHouseholdId = null;
            currentHouseholdName = null;
            householdTitle.textContent = '';
            currentGroupId = null;
            currentGroupName = 'No group selected';
            currentActiveFavoriteId = null;
            updateActiveGroupDisplay();
            await loadFavorites(null);
            await loadPlayers(null);
            evaluateFavoritesAvailability();
            return;
          }

          // Auto-select first household and display as title
          const firstHousehold = households[0];
          currentHouseholdId = firstHousehold.id || null;
          currentHouseholdName = firstHousehold.name || firstHousehold.id || '';
          householdTitle.textContent = currentHouseholdName;

          setAuthUI(true);
          showFeedback('Household loaded.');

          if (currentHouseholdId) {
            await loadPlayers(currentHouseholdId);
            await loadFavorites(currentHouseholdId);
          } else {
            await loadFavorites(null);
            await loadPlayers(null);
            evaluateFavoritesAvailability();
          }

          if (!panelSettings.classList.contains('hidden')) {
            await renderSettings();
          }
        } catch (error) {
          console.error('Failed to load households:', error);
          showFeedback('Could not load households. Please try again.', true);
          setAuthUI(false);
          favoritesStatus.textContent = 'Unable to load favorites.';
      }
    }

      async function fetchGroupsPlayers(householdId) {
        if (!householdId) {
          return { groups: [], players: [] };
        }

        const response = await fetch(
          `/api/households/${encodeURIComponent(householdId)}/groups-players`
        );

        if (!response.ok) {
          throw new Error(await response.text());
        }

        return response.json();
      }

      async function renderSettings() {
        if (panelSettings.classList.contains('hidden')) {
          return;
        }

        settingsStatusLabel.textContent = '';

        if (!isSonosConnected) {
          settingsPlayersWrap.innerHTML = '';
          if (settingsHelpLabel) {
            settingsHelpLabel.textContent = 'Sign in to load speakers.';
          }
          settingsSaveButton.disabled = true;
          settingsSaveButton.onclick = null;
          return;
        }

        const householdId = currentHouseholdId;
        if (!householdId) {
          settingsPlayersWrap.innerHTML = '';
          if (settingsHelpLabel) {
            settingsHelpLabel.textContent = 'No household available.';
          }
          settingsSaveButton.disabled = true;
          settingsSaveButton.onclick = null;
          return;
        }

        if (settingsHelpLabel) {
          settingsHelpLabel.textContent =
            'Set a default launch volume for each speaker. Leave blank to keep its current level.';
        }

        try {
          // Always fetch fresh data from the database when settings panel loads
          // This ensures settings saved on other devices are immediately visible
          const [snapshot, defaults] = await Promise.all([
            fetchGroupsPlayers(householdId),
            fetch('/api/settings/volumes', {
              cache: 'no-store',
              headers: {
                'Cache-Control': 'no-cache'
              }
            }).then((response) => {
              if (!response.ok) {
                throw new Error('Failed to load saved volumes');
              }
              return response.json();
            })
          ]);

          const players = Array.isArray(snapshot.players) ? snapshot.players : [];
          settingsPlayersWrap.innerHTML = '';

          if (!players.length) {
            settingsSaveButton.disabled = true;
            settingsStatusLabel.textContent = 'No speakers found for this household.';
            settingsSaveButton.onclick = null;
            return;
          }

          players.forEach((player) => {
            const row = document.createElement('div');
            row.className = 'settings-row';
            row.dataset.playerId = player.id;

            const nameLabel = document.createElement('strong');
            nameLabel.textContent = player.name || player.id || 'Speaker';

            const rangeInput = document.createElement('input');
            rangeInput.type = 'range';
            rangeInput.min = '0';
            rangeInput.max = '100';

            const numberInput = document.createElement('input');
            numberInput.type = 'number';
            numberInput.min = '0';
            numberInput.max = '100';
            numberInput.placeholder = '—';

            const defaultValue =
              defaults && typeof defaults[player.id] === 'number'
                ? Math.max(0, Math.min(100, Number(defaults[player.id])))
                : null;

            if (defaultValue === null || Number.isNaN(defaultValue)) {
              rangeInput.value = '50';
              numberInput.value = '';
            } else {
              rangeInput.value = String(defaultValue);
              numberInput.value = String(defaultValue);
            }

            rangeInput.addEventListener('input', (event) => {
              numberInput.value = event.target.value;
            });

            numberInput.addEventListener('input', (event) => {
              const raw = event.target.value.trim();
              if (raw === '') {
                return;
              }

              let numeric = Number(raw);
              if (Number.isNaN(numeric)) {
                numeric = '';
              } else {
                numeric = Math.max(0, Math.min(100, numeric));
              }

              if (numeric === '') {
                event.target.value = '';
              } else {
                event.target.value = String(numeric);
                rangeInput.value = String(numeric);
              }
            });

            row.appendChild(nameLabel);
            row.appendChild(rangeInput);
            row.appendChild(numberInput);
            settingsPlayersWrap.appendChild(row);
          });

          settingsSaveButton.disabled = false;
          settingsSaveButton.onclick = async () => {
            try {
              settingsSaveButton.disabled = true;
              settingsStatusLabel.textContent = 'Saving…';

              const payload = {};
              settingsPlayersWrap.querySelectorAll('.settings-row').forEach((row) => {
                const playerId = row.dataset.playerId;
                const input = row.querySelector('input[type="number"]');
                if (!playerId || !input) {
                  return;
                }

                const value = input.value.trim();
                // Send all players: empty string for cleared values, number for set values
                // This allows the backend to delete volumes that are cleared
                payload[playerId] = value !== '' ? Number(value) : '';
              });

              const response = await fetch('/api/settings/volumes', {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
              });

              if (!response.ok) {
                throw new Error(await response.text());
              }

              settingsStatusLabel.textContent = 'Saved defaults.';
            } catch (error) {
              console.error('Failed to save volume defaults:', error);
              settingsStatusLabel.textContent = 'Failed to save defaults.';
            } finally {
              settingsSaveButton.disabled = false;
            }
          };
        } catch (error) {
          console.error('Failed to render settings:', error);
          settingsPlayersWrap.innerHTML = '';
          settingsStatusLabel.textContent = 'Failed to load speaker data.';
          settingsSaveButton.disabled = true;
          settingsSaveButton.onclick = null;
        }
      }

      // Playlist management functions
      let timeRules = [];
      let editingRuleId = null;

      async function renderPlaylistManagement() {
        if (panelPlaylistManagement.classList.contains('hidden')) {
          return;
        }

        if (!isSonosConnected || !currentHouseholdId) {
          playlistManagementStatus.textContent = 'Sign in to load playlists.';
          playlistManagementGrid.innerHTML = '';
          timeRulesList.innerHTML = '';
          return;
        }

        try {
          await loadPlaylistVibes();
          await loadTimeRules();

          // Load favorites for playlist management
          const params = new URLSearchParams({ householdId: currentHouseholdId });
          const response = await fetch(`/api/favorites?${params.toString()}`);

          if (response.status === 401) {
            setAuthUI(false);
            playlistManagementStatus.textContent = 'Login required to load playlists.';
            return;
          }

          if (!response.ok) {
            throw new Error(await response.text());
          }

          const data = await response.json();
          const items = Array.isArray(data.items) ? data.items : [];

          if (!items.length) {
            playlistManagementStatus.textContent = 'No playlists found.';
            playlistManagementGrid.innerHTML = '';
            renderTimeRules();
            return;
          }

          playlistManagementStatus.textContent = '';
          playlistManagementGrid.innerHTML = '';

          items.forEach((favorite) => {
            const entry = createPlaylistManagementCard(favorite);
            playlistManagementGrid.appendChild(entry.button);
          });

          renderTimeRules();
        } catch (error) {
          console.error('Failed to load playlists:', error);
          playlistManagementStatus.textContent = 'Could not load playlists. Please try again.';
          playlistManagementGrid.innerHTML = '';
          timeRulesList.innerHTML = '';
        }
      }

      function createPlaylistManagementCard(favorite) {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'playlist-card';
        button.dataset.favoriteId = favorite.id;

        const cardContent = document.createElement('div');
        cardContent.className = 'playlist-card-content';

        const artWrapper = document.createElement('div');
        artWrapper.className = 'playlist-art-wrapper';

        const imageUrl =
          favorite && favorite.imageUrl
            ? favorite.imageUrl
            : favorite && favorite.images && favorite.images.length && favorite.images[0].url
              ? favorite.images[0].url
              : favorite && favorite.container && favorite.container.imageUrl
                ? favorite.container.imageUrl
                : null;

        if (imageUrl) {
          const img = document.createElement('img');
          img.className = 'playlist-art';
          img.alt = `${favorite.name || 'Playlist'} cover art`;
          img.loading = 'lazy';
          img.src = imageUrl;
          img.addEventListener('error', () => img.classList.add('hidden'));
          artWrapper.appendChild(img);
        } else {
          const placeholder = document.createElement('span');
          placeholder.className = 'playlist-placeholder';
          placeholder.textContent = '★';
          artWrapper.appendChild(placeholder);
        }

        const meta = document.createElement('div');
        meta.className = 'playlist-meta';

        const title = document.createElement('span');
        title.className = 'playlist-name';
        title.textContent = favorite.name || 'Unnamed Playlist';

        meta.appendChild(title);
        cardContent.appendChild(artWrapper);
        cardContent.appendChild(meta);

        const vibeSelector = document.createElement('div');
        vibeSelector.className = 'playlist-vibe-selector';

        const vibeLabel = document.createElement('label');
        vibeLabel.textContent = 'Vibe: ';

        const vibeSelect = document.createElement('select');
        vibeSelect.appendChild(new Option('', ''));
        ['Down', 'Down/Mid', 'Mid'].forEach((vibe) => {
          const option = document.createElement('option');
          option.value = vibe;
          option.textContent = vibe;
          vibeSelect.appendChild(option);
        });
        vibeSelect.value = playlistVibes[favorite.id] || '';
        vibeSelect.addEventListener('change', async (event) => {
          event.stopPropagation();
          const oldValue = vibeSelect.value;
          // Optimistically update the UI
          vibeSelect.value = event.target.value;
          try {
            await setPlaylistVibe(favorite.id, event.target.value);
            // Refresh the vibe selector to ensure it matches saved state
            await loadPlaylistVibes();
            vibeSelect.value = playlistVibes[favorite.id] || '';
          } catch (error) {
            // Revert on error
            vibeSelect.value = oldValue;
          }
        });
        vibeSelector.appendChild(vibeLabel);
        vibeSelector.appendChild(vibeSelect);

        button.appendChild(cardContent);
        button.appendChild(vibeSelector);

        return { favorite, button, vibeSelect };
      }

      async function loadTimeRules() {
        try {
          const response = await fetch('/api/vibe-time-rules');
          if (response.ok) {
            timeRules = await response.json();
          } else {
            timeRules = [];
          }
        } catch (error) {
          console.error('Failed to load time rules:', error);
          timeRules = [];
        }
      }

      function renderTimeRules() {
        timeRulesList.innerHTML = '';

        if (timeRules.length === 0) {
          const emptyMsg = document.createElement('p');
          emptyMsg.className = 'favorites-status';
          emptyMsg.textContent = 'No time rules configured. Add a rule to get started.';
          timeRulesList.appendChild(emptyMsg);
          return;
        }

        timeRules.forEach((rule) => {
          const item = document.createElement('div');
          item.className = 'time-rule-item';

          const info = document.createElement('div');
          info.className = 'time-rule-info';

          const time = document.createElement('div');
          time.className = 'time-rule-time';
          const startHour = rule.start_hour;
          const endHour = rule.end_hour;
          const startTime = formatHour(startHour);
          const endTime = formatHour(endHour);
          
          let daysText = 'Every day';
          if (rule.days && Array.isArray(rule.days) && rule.days.length > 0) {
            const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            daysText = rule.days.map(d => dayNames[d]).join(', ');
          }
          
          time.textContent = `${startTime} - ${endTime} (${daysText})`;

          const vibes = document.createElement('div');
          vibes.className = 'time-rule-vibes';
          vibes.textContent = `Vibes: ${rule.allowed_vibes.join(', ')}`;

          info.appendChild(time);
          info.appendChild(vibes);

          const actions = document.createElement('div');
          actions.className = 'time-rule-actions';

          const editBtn = document.createElement('button');
          editBtn.textContent = 'Edit';
          editBtn.addEventListener('click', () => {
            editingRuleId = rule.id;
            timeRuleStartHour.value = rule.start_hour;
            timeRuleEndHour.value = rule.end_hour;
            timeRuleVibeDown.checked = rule.allowed_vibes.includes('Down');
            timeRuleVibeDownMid.checked = rule.allowed_vibes.includes('Down/Mid');
            timeRuleVibeMid.checked = rule.allowed_vibes.includes('Mid');
            
            // Set day checkboxes
            const everydayCheckbox = document.getElementById('time-rule-day-everyday');
            if (!rule.days || !Array.isArray(rule.days) || rule.days.length === 0) {
              everydayCheckbox.checked = true;
              for (let i = 0; i <= 6; i++) {
                document.getElementById(`time-rule-day-${i}`).checked = false;
              }
            } else {
              everydayCheckbox.checked = false;
              for (let i = 0; i <= 6; i++) {
                document.getElementById(`time-rule-day-${i}`).checked = rule.days.includes(i);
              }
            }
            
            openTimeRuleEditor();
          });

          const deleteBtn = document.createElement('button');
          deleteBtn.textContent = 'Delete';
          deleteBtn.className = 'delete';
          deleteBtn.addEventListener('click', async () => {
            if (confirm('Are you sure you want to delete this rule?')) {
              try {
                const response = await fetch(`/api/vibe-time-rules/${rule.id}`, {
                  method: 'DELETE'
                });
                if (response.ok) {
                  await loadTimeRules();
                  renderTimeRules();
                } else {
                  throw new Error('Failed to delete rule');
                }
              } catch (error) {
                console.error('Failed to delete rule:', error);
                alert('Failed to delete rule. Please try again.');
              }
            }
          });

          actions.appendChild(editBtn);
          actions.appendChild(deleteBtn);

          item.appendChild(info);
          item.appendChild(actions);
          timeRulesList.appendChild(item);
        });
      }

      function formatHour(hour) {
        const h = hour % 12 || 12;
        const ampm = hour < 12 ? 'AM' : 'PM';
        return `${h}:00 ${ampm}`;
      }

      addTimeRuleBtn.addEventListener('click', () => {
        editingRuleId = null;
        timeRuleStartHour.value = '7';
        timeRuleEndHour.value = '12';
        timeRuleVibeDown.checked = false;
        timeRuleVibeDownMid.checked = false;
        timeRuleVibeMid.checked = false;
        
        // Set "Every day" as default
        document.getElementById('time-rule-day-everyday').checked = true;
        for (let i = 0; i <= 6; i++) {
          document.getElementById(`time-rule-day-${i}`).checked = false;
        }
        
        openTimeRuleEditor();
      });

      function openTimeRuleEditor() {
        const titleEl = document.getElementById('time-rule-editor-title');
        if (titleEl) {
          titleEl.textContent = editingRuleId ? 'Edit Time Rule' : 'Add Time Rule';
        }
        timeRuleEditorBackdrop.classList.add('visible');
        document.body.style.overflow = 'hidden';
      }

      function closeTimeRuleEditor() {
        timeRuleEditorBackdrop.classList.remove('visible');
        document.body.style.overflow = '';
        editingRuleId = null;
      }

      // Handle "Every day" checkbox
      const everydayCheckbox = document.getElementById('time-rule-day-everyday');
      everydayCheckbox.addEventListener('change', (e) => {
        if (e.target.checked) {
          // Uncheck all individual days
          for (let i = 0; i <= 6; i++) {
            document.getElementById(`time-rule-day-${i}`).checked = false;
          }
        }
      });

      // Handle individual day checkboxes - uncheck "Every day" if any specific day is selected
      for (let i = 0; i <= 6; i++) {
        const dayCheckbox = document.getElementById(`time-rule-day-${i}`);
        dayCheckbox.addEventListener('change', () => {
          if (dayCheckbox.checked) {
            everydayCheckbox.checked = false;
          }
        });
      }

      timeRuleCancelBtn.addEventListener('click', () => {
        closeTimeRuleEditor();
      });

      timeRuleEditorClose.addEventListener('click', () => {
        closeTimeRuleEditor();
      });

      // Close modal when clicking backdrop (but not the modal content itself)
      timeRuleEditorBackdrop.addEventListener('click', (e) => {
        if (e.target === timeRuleEditorBackdrop) {
          closeTimeRuleEditor();
        }
      });

      // Prevent clicks inside the modal from closing it
      timeRuleEditor.addEventListener('click', (e) => {
        e.stopPropagation();
      });

      timeRuleSaveBtn.addEventListener('click', async () => {
        const startHour = parseInt(timeRuleStartHour.value, 10);
        const endHour = parseInt(timeRuleEndHour.value, 10);
        const allowedVibes = [];
        if (timeRuleVibeDown.checked) allowedVibes.push('Down');
        if (timeRuleVibeDownMid.checked) allowedVibes.push('Down/Mid');
        if (timeRuleVibeMid.checked) allowedVibes.push('Mid');

        if (allowedVibes.length === 0) {
          alert('Please select at least one vibe.');
          return;
        }

        // Get selected days
        let days = null;
        const everydayCheckbox = document.getElementById('time-rule-day-everyday');
        if (!everydayCheckbox.checked) {
          days = [];
          for (let i = 0; i <= 6; i++) {
            const dayCheckbox = document.getElementById(`time-rule-day-${i}`);
            if (dayCheckbox.checked) {
              days.push(i);
            }
          }
          // If no days selected, treat as "every day" (null)
          if (days.length === 0) {
            days = null;
          }
        }

        try {
          const rule = {
            start_hour: startHour,
            end_hour: endHour,
            allowed_vibes: allowedVibes,
            days: days
          };

          if (editingRuleId) {
            rule.id = editingRuleId;
            const response = await fetch(`/api/vibe-time-rules/${editingRuleId}`, {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(rule)
            });
            if (!response.ok) {
              throw new Error('Failed to update rule');
            }
          } else {
            const response = await fetch('/api/vibe-time-rules', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(rule)
            });
            if (!response.ok) {
              throw new Error('Failed to create rule');
            }
          }

          closeTimeRuleEditor();
          await loadTimeRules();
          renderTimeRules();
        } catch (error) {
          console.error('Failed to save time rule:', error);
          alert('Failed to save rule. Please try again.');
        }
      });

      async function loadPlaylistVibes() {
        try {
          const response = await fetch('/api/playlist-vibes');
          if (response.ok) {
            playlistVibes = await response.json();
          }
        } catch (error) {
          console.error('Failed to load playlist vibes:', error);
        }
      }

      async function setPlaylistVibe(playlistId, vibe) {
        if (vibe) {
          playlistVibes[playlistId] = vibe;
        } else {
          delete playlistVibes[playlistId];
        }

        try {
          const response = await fetch('/api/playlist-vibes', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(playlistVibes)
          });

          if (!response.ok) {
            throw new Error('Failed to save vibe');
          }

          // Update the saved vibes from the response
          const saved = await response.json();
          playlistVibes = saved;

          applyVibeFilter();
          // Update recommendations when vibes change (if control panel is visible)
          if (!panelControl.classList.contains('hidden')) {
            updatePlaylistRecommendations();
          }
        } catch (error) {
          console.error('Failed to save playlist vibe:', error);
          // Revert the change on error
          if (vibe) {
            delete playlistVibes[playlistId];
          } else {
            // Reload from server to get correct state
            await loadPlaylistVibes();
          }
        }
      }

      async function updatePlaylistRecommendations() {
        if (!isSonosConnected || !currentHouseholdId) {
          recommendedPlaylistContainer.innerHTML = '';
          alternativesDropdown.innerHTML = '';
          recommendationRuleInfo.textContent = '';
          return;
        }

        try {
          const params = new URLSearchParams({ householdId: currentHouseholdId });
          const response = await fetch(`/api/playlist-recommendations?${params.toString()}`);

          if (!response.ok) {
            throw new Error('Failed to fetch recommendations');
          }

          const data = await response.json();
          const { primary, alternatives, currentRule } = data;

          // Update rule info
          if (currentRule) {
            const startTime = formatHour(currentRule.start_hour);
            const endTime = formatHour(currentRule.end_hour);
            recommendationRuleInfo.textContent = `Current rule: ${startTime} - ${endTime} (${currentRule.allowed_vibes.join(', ')})`;
          } else {
            recommendationRuleInfo.textContent = 'No time rule active for current time.';
          }

          // Clear containers
          recommendedPlaylistContainer.innerHTML = '';
          alternativesDropdown.innerHTML = '';

          if (!primary) {
            const noRecs = document.createElement('p');
            noRecs.className = 'favorites-status';
            noRecs.textContent = 'No playlists match the current time rule.';
            recommendedPlaylistContainer.appendChild(noRecs);
            return;
          }

          // Render primary recommendation
          const primaryCard = createRecommendationCard(primary, true);
          recommendedPlaylistContainer.appendChild(primaryCard);

          // Render alternatives if any
          if (alternatives && alternatives.length > 0) {
            const toggle = document.createElement('button');
            toggle.className = 'alternatives-toggle';
            toggle.textContent = `View ${alternatives.length} other option${alternatives.length > 1 ? 's' : ''}`;
            toggle.innerHTML = `${toggle.textContent} <span>▼</span>`;
            
            let isOpen = false;
            toggle.addEventListener('click', () => {
              isOpen = !isOpen;
              alternativesList.classList.toggle('visible', isOpen);
              toggle.innerHTML = `${isOpen ? 'Hide' : 'View'} ${alternatives.length} other option${alternatives.length > 1 ? 's' : ''} <span>${isOpen ? '▲' : '▼'}</span>`;
            });

            const alternativesList = document.createElement('div');
            alternativesList.className = 'alternatives-list';

            alternatives.forEach((alt) => {
              const altCard = createRecommendationCard(alt, false);
              alternativesList.appendChild(altCard);
            });

            alternativesDropdown.appendChild(toggle);
            alternativesDropdown.appendChild(alternativesList);
          }
        } catch (error) {
          console.error('Failed to update playlist recommendations:', error);
          recommendedPlaylistContainer.innerHTML = '';
          alternativesDropdown.innerHTML = '';
          recommendationRuleInfo.textContent = '';
        }
      }

      function createRecommendationCard(favorite, isPrimary) {
        const card = document.createElement('div');
        card.className = isPrimary ? 'recommended-playlist' : 'alternative-playlist';

        const art = document.createElement('div');
        art.className = isPrimary ? 'recommended-playlist-art' : 'alternative-playlist-art';

        const imageUrl =
          favorite && favorite.imageUrl
            ? favorite.imageUrl
            : favorite && favorite.images && favorite.images.length && favorite.images[0].url
              ? favorite.images[0].url
              : favorite && favorite.container && favorite.container.imageUrl
                ? favorite.container.imageUrl
                : null;

        if (imageUrl) {
          const img = document.createElement('img');
          img.src = imageUrl;
          img.alt = `${favorite.name || 'Playlist'} cover art`;
          img.loading = 'lazy';
          img.addEventListener('error', () => {
            const placeholder = document.createElement('span');
            placeholder.textContent = '★';
            art.innerHTML = '';
            art.appendChild(placeholder);
          });
          art.appendChild(img);
        } else {
          const placeholder = document.createElement('span');
          placeholder.textContent = '★';
          art.appendChild(placeholder);
        }

        const info = document.createElement('div');
        info.className = isPrimary ? 'recommended-playlist-info' : 'alternative-playlist-info';

        const name = document.createElement('div');
        name.className = isPrimary ? 'recommended-playlist-name' : 'alternative-playlist-name';
        name.textContent = favorite.name || 'Unnamed Playlist';

        const vibe = document.createElement('div');
        vibe.className = isPrimary ? 'recommended-playlist-vibe' : 'alternative-playlist-vibe';
        const vibeValue = playlistVibes[favorite.id] || 'No vibe assigned';
        vibe.textContent = `Vibe: ${vibeValue}`;

        info.appendChild(name);
        info.appendChild(vibe);

        card.appendChild(art);
        card.appendChild(info);

        if (isPrimary) {
          const actions = document.createElement('div');
          actions.className = 'recommended-playlist-actions';

          const playBtn = document.createElement('button');
          playBtn.textContent = 'Play Recommended';
          playBtn.addEventListener('click', async () => {
            const entry = favoritesRegistry.get(favorite.id);
            if (entry) {
              await playFavorite(entry);
            } else {
              // Create a temporary entry
              const tempEntry = { favorite, button: null, statusEl: null, loading: false };
              await playFavorite(tempEntry);
            }
          });

          actions.appendChild(playBtn);
          card.appendChild(actions);
        } else {
          card.style.cursor = 'pointer';
          card.addEventListener('click', async () => {
            const entry = favoritesRegistry.get(favorite.id);
            if (entry) {
              await playFavorite(entry);
            } else {
              const tempEntry = { favorite, button: null, statusEl: null, loading: false };
              await playFavorite(tempEntry);
            }
          });
        }

        return card;
      }

      function renderVibeFilters() {
        vibeFiltersContainer.innerHTML = '';

        const allButton = document.createElement('button');
        allButton.className = 'vibe-filter-btn';
        allButton.textContent = 'All';
        allButton.classList.toggle('active', currentVibeFilter === null);
        allButton.addEventListener('click', () => {
          currentVibeFilter = null;
          applyVibeFilter();
        });
        vibeFiltersContainer.appendChild(allButton);

        ['Down', 'Down/Mid', 'Mid'].forEach((vibe) => {
          const button = document.createElement('button');
          button.className = 'vibe-filter-btn';
          button.textContent = vibe;
          button.classList.toggle('active', currentVibeFilter === vibe);
          button.addEventListener('click', () => {
            currentVibeFilter = vibe;
            applyVibeFilter();
          });
          vibeFiltersContainer.appendChild(button);
        });
      }

      function applyVibeFilter() {
        favoritesRegistry.forEach((entry) => {
          const vibe = playlistVibes[entry.favorite.id] || null;
          const shouldShow = currentVibeFilter === null || vibe === currentVibeFilter;
          entry.button.style.display = shouldShow ? '' : 'none';
        });
      }

      async function loadFavorites(householdId) {
        favoritesRegistry.clear();
        favoritesGrid.innerHTML = '';

        if (!householdId) {
          favoritesStatus.textContent = isSonosConnected
            ? 'Select a household to load favorites.'
            : 'Login required to load favorites.';
          vibeFiltersContainer.innerHTML = '';
          evaluateFavoritesAvailability();
          return;
        }

        favoritesStatus.textContent = 'Loading favorites…';

        try {
          await loadPlaylistVibes();

          const params = new URLSearchParams({ householdId });
          const activeGroupId = getSelectedGroupId();
          if (activeGroupId) {
            params.set('groupId', activeGroupId);
          }

          const response = await fetch(`/api/favorites?${params.toString()}`);

          if (response.status === 401) {
            setAuthUI(false);
            favoritesStatus.textContent = 'Login required to load favorites.';
            return;
          }

          if (!response.ok) {
            throw new Error(await response.text());
          }

          const data = await response.json();
          const items = Array.isArray(data.items) ? data.items : [];
          currentActiveFavoriteId = data.activeFavorite ?? null;

          if (!items.length) {
            favoritesStatus.textContent = 'No favorites found.';
            vibeFiltersContainer.innerHTML = '';
            evaluateFavoritesAvailability();
            return;
          }

          favoritesStatus.textContent = '';

          items.forEach((favorite) => {
            const entry = createFavoriteCard(favorite);
            favoritesRegistry.set(favorite.id, entry);
            favoritesGrid.appendChild(entry.button);
          });

          renderVibeFilters();
          applyVibeFilter();
          evaluateFavoritesAvailability();
          markActiveFavorite(currentActiveFavoriteId);
          // Update recommendations when favorites are loaded
          if (!panelControl.classList.contains('hidden')) {
            updatePlaylistRecommendations();
          }
        } catch (error) {
          console.error('Failed to load favorites:', error);
          favoritesStatus.textContent = 'Could not load favorites. Please try again.';
          vibeFiltersContainer.innerHTML = '';
          evaluateFavoritesAvailability();
        }
      }

      function createFavoriteCard(favorite) {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'playlist-card disabled';
        button.disabled = true;
        button.dataset.favoriteId = favorite.id;

        const artWrapper = document.createElement('div');
        artWrapper.className = 'playlist-art-wrapper';

        const imageUrl =
          favorite && favorite.imageUrl
            ? favorite.imageUrl
            : favorite && favorite.images && favorite.images.length && favorite.images[0].url
              ? favorite.images[0].url
              : favorite && favorite.container && favorite.container.imageUrl
                ? favorite.container.imageUrl
                : null;

        if (imageUrl) {
          const img = document.createElement('img');
          img.className = 'playlist-art';
          img.alt = `${favorite.name || 'Favorite'} cover art`;
          img.loading = 'lazy';
          img.src = imageUrl;
          img.addEventListener('error', () => img.classList.add('hidden'));
          artWrapper.appendChild(img);
        } else {
          const placeholder = document.createElement('span');
          placeholder.className = 'playlist-placeholder';
          placeholder.textContent = '★';
          artWrapper.appendChild(placeholder);
        }

        const meta = document.createElement('div');
        meta.className = 'playlist-meta';

        const brand = document.createElement('span');
        brand.className = 'playlist-brand';
        const brandIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        brandIcon.setAttribute('viewBox', '0 0 24 24');
        brandIcon.setAttribute('aria-hidden', 'true');
        const brandPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        brandPath.setAttribute(
          'd',
          'M12 17.27 18.18 21l-1.64-7.03L22 9.24l-7.19-.62L12 2 9.19 8.62 2 9.24l5.46 4.73L5.82 21z'
        );
        brandIcon.appendChild(brandPath);
        brand.appendChild(brandIcon);
        const serviceLabel =
          favorite && favorite.service && favorite.service.name
            ? favorite.service.name
            : favorite && favorite.programType
              ? favorite.programType
              : 'Sonos Favorite';
        brand.appendChild(document.createTextNode(' ' + serviceLabel));

        const title = document.createElement('span');
        title.className = 'playlist-name';
        title.textContent = favorite.name || 'Unnamed Favorite';

        const status = document.createElement('span');
        status.className = 'playlist-status';
        status.textContent = SELECT_GROUP_MESSAGE;

        meta.appendChild(brand);
        meta.appendChild(title);
        meta.appendChild(status);

        const cardContent = document.createElement('div');
        cardContent.className = 'playlist-card-content';
        cardContent.appendChild(artWrapper);
        cardContent.appendChild(meta);

        const vibeSelector = document.createElement('div');
        vibeSelector.className = 'playlist-vibe-selector';
        const vibeLabel = document.createElement('label');
        vibeLabel.textContent = 'Vibe:';
        
        const vibePill = document.createElement('span');
        const vibe = playlistVibes[favorite.id] || '';
        if (vibe) {
          vibePill.className = 'playlist-vibe-pill';
          if (vibe === 'Down') {
            vibePill.className += ' down';
            vibePill.textContent = 'Down';
          } else if (vibe === 'Down/Mid') {
            vibePill.className += ' down-mid';
            vibePill.textContent = 'Down/Mid';
          } else if (vibe === 'Mid') {
            vibePill.className += ' mid';
            vibePill.textContent = 'Mid';
          }
        } else {
          vibePill.textContent = '—';
          vibePill.style.color = 'var(--text-tertiary)';
          vibePill.style.fontSize = '0.8125rem';
        }
        
        vibeSelector.appendChild(vibeLabel);
        vibeSelector.appendChild(vibePill);

        button.appendChild(cardContent);
        button.appendChild(vibeSelector);

        const entry = {
          favorite,
          button,
          statusEl: status,
          loading: false,
          statusMessage: SELECT_GROUP_MESSAGE,
          vibePill
        };

        button.addEventListener('click', (event) => {
          playFavorite(entry);
        });

        return entry;
      }

      async function playFavorite(entry) {
        if (!currentHouseholdId) {
          showFeedback('Select a household first.', true);
          return;
        }

        setFavoriteLoading(entry, true);

        try {
          const groupResponse = await fetch(`/api/households/${encodeURIComponent(currentHouseholdId)}/create-all-group`, {
            method: 'POST'
          });

          if (!groupResponse.ok) {
            throw new Error('Failed to create group with all players');
          }

          const groupData = await groupResponse.json();
          const groupId = groupData.groupId;

          if (!groupId) {
            throw new Error('No group ID returned');
          }

          setActiveGroup(groupId, groupData.groupName || 'All Rooms');

          // Set favorite as active immediately for optimistic UI update
          markActiveFavorite(entry.favorite.id);
          // Track play action time to prevent refresh interference
          lastPlayActionTime = Date.now();
          // Update now playing immediately with this favorite's metadata
          updateCurrentlyPlaying();

          const commandPromise = sendCommand(
            `/api/groups/${encodeURIComponent(groupId)}/favorites/play`,
            {
              householdId: currentHouseholdId,
              favoriteId: entry.favorite.id,
              shuffle: true,
              repeat: true,
              crossfade: true
            },
            FAVORITE_SUCCESS_TOAST
          );

          const [success] = await Promise.all([commandPromise, delay(2000)]);
          setFavoriteLoading(entry, false);

          if (success) {
            // Store the group ID before loadPlayers might clear it
            const savedGroupId = groupId;
            // Load players before updating currently playing to ensure group state is fresh
            await loadPlayers(currentHouseholdId);
            // Restore the group ID if it was cleared
            if (!getSelectedGroupId() && savedGroupId) {
              setActiveGroup(savedGroupId, groupData.groupName || 'All Rooms');
            }
            
            // Retry logic: if status doesn't match expected favoriteId, retry after short delay
            let retryCount = 0;
            const maxRetries = 3;
            const checkStatus = async () => {
              try {
                const response = await fetch(`/api/groups/${encodeURIComponent(savedGroupId)}/playback/status`);
                if (response.ok) {
                  const status = await response.json();
                  if (status.activeFavoriteId === entry.favorite.id) {
                    // Status matches, update UI
                    updateCurrentlyPlaying();
                  } else if (retryCount < maxRetries) {
                    // Status doesn't match yet, retry
                    retryCount++;
                    setTimeout(checkStatus, 500);
                  } else {
                    // Max retries reached, update anyway
                    updateCurrentlyPlaying();
                  }
                } else {
                  updateCurrentlyPlaying();
                }
              } catch (error) {
                console.error('Failed to check status:', error);
                updateCurrentlyPlaying();
              }
            };
            
            // Check status after a short delay to allow server to update
            setTimeout(checkStatus, 300);
          } else {
            // Playback failed, clear active favorite
            markActiveFavorite(null);
            updateFavoriteStatus(entry, FAVORITE_ERROR_MESSAGE);
          }
        } catch (error) {
          console.error('Failed to play favorite:', error);
          setFavoriteLoading(entry, false);
          updateFavoriteStatus(entry, FAVORITE_ERROR_MESSAGE);
          showFeedback('Failed to start playback. Please try again.', true);
        }

        evaluateFavoritesAvailability();
      }

      function setFavoriteLoading(entry, isLoading) {
        entry.loading = isLoading;
        entry.button.disabled = true;
        if (isLoading) {
          entry.button.classList.add('loading');
          updateFavoriteStatus(entry, LOADING_MESSAGE);
        } else {
          entry.button.classList.remove('loading');
        }
      }

      function updateFavoriteStatus(entry, message) {
        entry.statusMessage = message;
        entry.statusEl.textContent = message;
      }

      function evaluateFavoritesAvailability() {
        const enabled = isSonosConnected && Boolean(currentHouseholdId);

        favoritesRegistry.forEach((entry) => {
          if (entry.loading) {
            return;
          }

          entry.button.disabled = !enabled;
          entry.button.classList.toggle('disabled', !enabled);

          if (!enabled) {
            entry.button.classList.remove('active');
            updateFavoriteStatus(entry, 'Select a household to play');
          } else if (
            entry.statusMessage === SELECT_GROUP_MESSAGE ||
            entry.statusMessage === READY_MESSAGE ||
            entry.statusMessage === ''
          ) {
            updateFavoriteStatus(entry, READY_MESSAGE);
          }
        });

        if (enabled) {
          markActiveFavorite(currentActiveFavoriteId);
        }
      }

      function markActiveFavorite(favoriteId) {
        currentActiveFavoriteId = favoriteId || null;
        currentActiveFavoriteIdTimestamp = Date.now();

        favoritesRegistry.forEach((entry) => {
          if (entry.loading) {
            return;
          }

          const isActive = Boolean(favoriteId) && entry.favorite.id === favoriteId;
          entry.button.classList.toggle('active', isActive);

          if (isActive) {
            updateFavoriteStatus(entry, FAVORITE_SUCCESS_MESSAGE);
          } else if (entry.statusMessage === FAVORITE_SUCCESS_MESSAGE) {
            updateFavoriteStatus(entry, READY_MESSAGE);
          }
        });
      }

      async function handlePlaybackAction(action) {
        const groupId = getSelectedGroupId();
        if (!groupId) {
          // Auto-grouping is handled on load, but if we still don't have a group, try to create one
          if (currentHouseholdId && latestPlayers.length > 0) {
            try {
              const groupResponse = await fetch(`/api/households/${encodeURIComponent(currentHouseholdId)}/create-all-group`, {
                method: 'POST'
              });
              if (groupResponse.ok) {
                const groupData = await groupResponse.json();
                if (groupData.groupId) {
                  setActiveGroup(groupData.groupId, groupData.groupName || 'All Rooms');
                  // Retry the action
                  handlePlaybackAction(action);
                  return;
                }
              }
            } catch (error) {
              console.error('Failed to auto-create group:', error);
            }
          }
          showFeedback('Unable to control playback. Please try again.', true);
          return;
        }

        // Track state change for play/pause - toggle based on current tracked state
        if (action === 'playpause') {
          // Determine current state to toggle from
          const currentIsPlaying = trackedPlaybackState === 'PLAYING' || (trackedPlaybackState === null && currentPlaybackState?.playbackState === 'PLAYING');
          // Toggle tracked state
          if (currentIsPlaying) {
            trackedPlaybackState = 'PAUSED';
          } else {
            trackedPlaybackState = 'PLAYING';
          }
          console.log('[PlayPause] Tracked state after toggle:', trackedPlaybackState, '(was playing:', currentIsPlaying + ')');
        }

        const endpoints = {
          playpause: `/api/groups/${encodeURIComponent(groupId)}/playpause`,
          next: `/api/groups/${encodeURIComponent(groupId)}/next`,
          previous: `/api/groups/${encodeURIComponent(groupId)}/previous`
        };

        const endpoint = endpoints[action];
        if (!endpoint) {
          console.warn(`Unknown playback action requested: ${action}`);
          return;
        }

        await sendCommand(endpoint);
        setTimeout(() => updateCurrentlyPlaying(), 500);
      }

      async function setMasterVolume(level) {
        const groupId = getSelectedGroupId();
        if (!groupId) {
          // Auto-grouping is handled on load, but if we still don't have a group, try to create one
          if (currentHouseholdId && latestPlayers.length > 0) {
            try {
              const groupResponse = await fetch(`/api/households/${encodeURIComponent(currentHouseholdId)}/create-all-group`, {
                method: 'POST'
              });
              if (groupResponse.ok) {
                const groupData = await groupResponse.json();
                if (groupData.groupId) {
                  setActiveGroup(groupData.groupId, groupData.groupName || 'All Rooms');
                  // Retry setting volume
                  setMasterVolume(level);
                  return;
                }
              }
            } catch (error) {
              console.error('Failed to auto-create group:', error);
            }
          }
          showFeedback('Unable to change volume. Please try again.', true);
          return;
        }

        masterVolumeValue.textContent = `${level}%`;
        const success = await sendCommand(
          `/api/groups/${encodeURIComponent(groupId)}/volume`,
          {
            volume: level
          },
          `Volume set to ${level}%.`
        );

        if (!success) {
          showFeedback('Unable to update volume. Please try again.', true);
        } else {
          // Update individual player volumes proportionally
          updateIndividualVolumesFromMaster(level);
          setTimeout(() => updateCurrentlyPlaying(), 500);
        }
      }

      function updateIndividualVolumesFromMaster(masterLevel) {
        // Update all individual sliders to match master volume
        const roomRows = currentlyPlayingRoomsList.querySelectorAll('.currently-playing-room-volume');
        roomRows.forEach((row) => {
          const slider = row.querySelector('.currently-playing-room-slider');
          const value = row.querySelector('.currently-playing-room-value');
          if (slider && value) {
            slider.value = masterLevel;
            value.textContent = `${masterLevel}`;
          }
        });
      }

      async function sendCommand(endpoint, body, successMessage = 'Command sent to Sonos.') {
        try {
          const response = await fetch(endpoint, {
            method: 'POST',
            headers: body ? { 'Content-Type': 'application/json' } : undefined,
            body: body ? JSON.stringify(body) : undefined
          });

          if (response.status === 401) {
            setAuthUI(false);
            showFeedback('Session expired. Please login again.', true);
            return false;
          }

          if (!response.ok) {
            throw new Error(await response.text());
          }

          if (successMessage) {
            showFeedback(successMessage);
          }
          return true;
        } catch (error) {
          console.error('Command failed:', error);
          showFeedback('Unable to reach Sonos. Please try again.', true);
          return false;
        }
      }

      function delay(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

  evaluateFavoritesAvailability();
  applyAuthFeedback();
  showView('control');

      async function loadPlayers(householdId) {
        if (!householdId) {
          latestPlayers = [];
          latestGroups = [];
          ensureActiveGroup([]);
          return;
        }

        try {
          clearTimeout(refreshTimer);
          refreshTimer = null;
          const response = await fetch(`/api/households/${encodeURIComponent(householdId)}/players`);

          if (response.status === 401) {
            setAuthUI(false);
            favoritesStatus.textContent = 'Login required to load favorites.';
            return;
          }

          if (!response.ok) {
            throw new Error(await response.text());
          }

          const data = await response.json();
          latestPlayers = Array.isArray(data.players) ? data.players : [];
          latestGroups = Array.isArray(data.groups) ? data.groups : [];

          ensureActiveGroup(latestPlayers);
          let activeGroupId = getSelectedGroupId();
          
          // Automatically create and select a group with all players if none is selected
          if (!activeGroupId && latestPlayers.length > 0 && currentHouseholdId) {
            try {
              const groupResponse = await fetch(`/api/households/${encodeURIComponent(currentHouseholdId)}/create-all-group`, {
                method: 'POST'
              });
              
              if (groupResponse.ok) {
                const groupData = await groupResponse.json();
                if (groupData.groupId) {
                  setActiveGroup(groupData.groupId, groupData.groupName || 'All Rooms');
                  activeGroupId = groupData.groupId;
                }
              }
            } catch (error) {
              console.error('Failed to auto-create group:', error);
            }
          }
          
          // Check for currently playing content after a short delay to ensure everything is loaded
          setTimeout(async () => {
            // Use the active group (either existing or newly created)
            if (activeGroupId) {
              updateCurrentlyPlayingRooms(activeGroupId);
              await updateCurrentlyPlaying();
              startPlaybackRefresh();
            } else if (latestGroups.length > 0) {
              // If still no group, check all groups to find which one is playing
              for (const group of latestGroups) {
                const groupId = group.id || group.groupId;
                if (!groupId) continue;
                
                try {
                  const response = await fetch(`/api/groups/${encodeURIComponent(groupId)}/playback/status`);
                  if (response.ok) {
                    const status = await response.json();
                    const playbackState = status.playbackState || status.state || 'STOPPED';
                    const isPlaying = playbackState === 'PLAYING' || playbackState === 'PLAYBACK_STATE_PLAYING';
                    const hasContent = !!(status.track || status.currentItem || status.item);
                    
                    if (isPlaying || hasContent || playbackState !== 'STOPPED') {
                      // Found a group with playback - set it as active
                      setActiveGroup(groupId, group.name || group.displayName || 'Group');
                      updateCurrentlyPlayingRooms(groupId);
                      await updateCurrentlyPlaying();
                      startPlaybackRefresh();
                      break;
                    }
                  }
                } catch (error) {
                  // Continue to next group
                  continue;
                }
              }
            }
          }, 500);
        } catch (error) {
          console.error('Failed to load players', error);
        }
      }

      function ensureActiveGroup(players) {
        if (currentGroupId && players.some((player) => player.groupId === currentGroupId)) {
          const active = players.find((player) => player.groupId === currentGroupId);
          if (active) {
            currentGroupName = active.groupName || active.name || currentGroupName;
          }
        } else {
          // Don't clear the group if panel is visible (we're in the middle of playback)
          if (panelShouldBeVisible && currentGroupId) {
            return; // Keep the existing group ID
          }
          const candidate = players.find((player) => player.groupId);
          if (candidate) {
            currentGroupId = candidate.groupId;
            currentGroupName = candidate.groupName || candidate.name || 'Group';
          } else {
            // Only clear if panel isn't visible
            if (!panelShouldBeVisible) {
              currentGroupId = null;
              currentGroupName = 'No group selected';
            }
          }
        }
        updateActiveGroupDisplay();
        evaluateFavoritesAvailability();
      }


      async function setPlayerVolume(playerId, level) {
        if (!playerId) {
          return;
        }

        const numericLevel = Number(level);

        try {
          const postResponse = await fetch(`/api/players/${encodeURIComponent(playerId)}/volume`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ level: numericLevel })
          });

          if (!postResponse.ok) {
            throw new Error(await postResponse.text());
          }

          const getResponse = await fetch(`/api/players/${encodeURIComponent(playerId)}/volume`);
          if (getResponse.ok) {
            const payload = await getResponse.json();
            const updatedLevel = Number(
              payload.volume ?? payload?.volume?.volume ?? payload.level ?? numericLevel
            );
            
            const roomRow = document.querySelector(`[data-player-id="${playerId}"]`);
            if (roomRow) {
              const slider = roomRow.querySelector('.currently-playing-room-slider');
              const value = roomRow.querySelector('.currently-playing-room-value');
              if (slider) slider.value = updatedLevel;
              if (value) value.textContent = updatedLevel;
            }
          }

          if (currentHouseholdId) {
            setTimeout(() => loadPlayers(currentHouseholdId), 500);
          }
        } catch (error) {
          console.error('Failed to update player volume:', error);
          showFeedback('Unable to update room volume. Please try again.', true);
        }
      }

      async function refreshUI() {
        await loadHouseholds();
      }

      evaluateFavoritesAvailability();
      updateActiveGroupDisplay();

      async function updateCurrentlyPlaying() {
        let groupId = getSelectedGroupId();
        
        // If no group is selected but we have groups, try the first one
        if (!groupId && latestGroups.length > 0 && isSonosConnected) {
          const firstGroup = latestGroups.find(g => g.id || g.groupId);
          if (firstGroup) {
            groupId = firstGroup.id || firstGroup.groupId;
            // Set it as active so refresh continues
            if (groupId && !currentGroupId) {
              setActiveGroup(groupId, firstGroup.name || firstGroup.displayName || 'Group');
            }
          }
        }
        
        if (!groupId || !isSonosConnected) {
          // Only hide if panel wasn't previously visible (don't hide during transitions)
          if (!panelShouldBeVisible) {
            clearTimeout(hidePanelTimeout);
            currentlyPlayingPanel.classList.remove('visible');
            document.body.classList.remove('has-playing');
          }
          return;
        }

        try {
          const response = await fetch(`/api/groups/${encodeURIComponent(groupId)}/playback/status`);
          if (!response.ok) {
            throw new Error('Failed to fetch playback status');
          }

          const status = await response.json();
          currentPlaybackState = status;

          const apiPlaybackState = status.playbackState || status.state || status.playback?.state || 'STOPPED';
          
          // Normalize API state (handle PLAYBACK_STATE_PLAYING, PLAYING, etc.)
          let normalizedApiState = apiPlaybackState;
          if (typeof apiPlaybackState === 'string') {
            if (apiPlaybackState.includes('PLAYING')) {
              normalizedApiState = 'PLAYING';
            } else if (apiPlaybackState.includes('PAUSED') || apiPlaybackState.includes('IDLE')) {
              normalizedApiState = 'PAUSED';
            } else if (apiPlaybackState.includes('STOPPED')) {
              normalizedApiState = 'STOPPED';
            }
          }
          
          // Use tracked state if available (more reliable than API), otherwise use normalized API state
          let playbackState;
          if (trackedPlaybackState !== null) {
            // Use tracked state (from user actions) - this is more reliable than the API
            playbackState = trackedPlaybackState;
            console.log('[PlayPause] Using tracked state:', trackedPlaybackState, '(API said:', normalizedApiState + ')');
          } else if (normalizedApiState === 'STOPPED') {
            // API says STOPPED - trust it
            playbackState = 'STOPPED';
            trackedPlaybackState = 'STOPPED';
            console.log('[PlayPause] Using API STOPPED state');
          } else if (normalizedApiState === 'PAUSED') {
            // API says PAUSED - trust it
            playbackState = 'PAUSED';
            trackedPlaybackState = 'PAUSED';
            console.log('[PlayPause] Using API PAUSED state');
          } else {
            // API says PLAYING but we have no tracked state - initialize to PLAYING
            // (This happens on first load when music is already playing)
            playbackState = 'PLAYING';
            trackedPlaybackState = 'PLAYING';
            console.log('[PlayPause] Initializing tracked state to PLAYING (first load, API:', normalizedApiState + ')');
          }
          
          const isPlaying = playbackState === 'PLAYING';
          
          // DEBUG: Play/Pause state
          console.log('[PlayPause] State check:', {
            apiPlaybackState: status.playbackState || status.state || 'STOPPED',
            finalPlaybackState: playbackState,
            trackedPlaybackState,
            isPlaying,
            statusKeys: Object.keys(status)
          });
          
          const item = status.currentItem || status.item || status.playback?.currentItem || null;
          const track = item?.track || item?.container?.metadata || status.track || null;
          
          // Determine if we should show the panel - be more permissive
          const hasContent = !!(track || item);
          const isActive = isPlaying || playbackState !== 'STOPPED';
          
          // If we have content OR are playing, show the panel
          // If panel was visible, keep it visible (don't hide during transitions)
          if (hasContent || isActive || panelShouldBeVisible) {
            panelShouldBeVisible = true;
            clearTimeout(hidePanelTimeout);
            
            const groupInfo = latestGroups.find((g) => g.id === groupId || g.groupId === groupId);
            const groupName = groupInfo?.name || currentGroupName || 'Unknown Group';

            // Sync currentActiveFavoriteId with status to keep highlighted favorite in sync with now playing
            // Use currentActiveFavoriteId as source of truth for display, only sync FROM status if status is newer/more reliable
            const statusActiveFavoriteId = status.activeFavoriteId;
            
            // For display purposes, prefer currentActiveFavoriteId (optimistic update)
            // Only use status if it has a non-null value AND differs from current
            let activeFavoriteId = currentActiveFavoriteId;
            
            // Only sync FROM status if:
            // 1. Status has a non-null value (not null, not undefined)
            // 2. Status value differs from current
            // 3. Don't clear currentActiveFavoriteId if status returns null/undefined (might be stale)
            if (statusActiveFavoriteId !== undefined && statusActiveFavoriteId !== null) {
              if (statusActiveFavoriteId !== currentActiveFavoriteId) {
                // Status has a different non-null value - update to match
                currentActiveFavoriteId = statusActiveFavoriteId;
                currentActiveFavoriteIdTimestamp = Date.now();
                markActiveFavorite(statusActiveFavoriteId);
                activeFavoriteId = statusActiveFavoriteId;
              } else {
                // Status matches current - use it for display
                activeFavoriteId = statusActiveFavoriteId;
              }
            }
            // If status is null/undefined, keep using currentActiveFavoriteId (don't clear it - might be stale)

            let playlistName = null;
            let playlistImageUrl = null;
            if (activeFavoriteId) {
              const favoriteEntry = favoritesRegistry.get(activeFavoriteId);
              if (favoriteEntry && favoriteEntry.favorite) {
                playlistName = favoriteEntry.favorite.name || null;
                // Get playlist cover art
                const favorite = favoriteEntry.favorite;
                playlistImageUrl = favorite?.imageUrl
                  ? (typeof favorite.imageUrl === 'string' ? favorite.imageUrl : favorite.imageUrl?.url || favorite.imageUrl?.value || null)
                  : favorite?.images && favorite.images.length && favorite.images[0]?.url
                    ? favorite.images[0].url
                    : favorite?.container?.imageUrl
                      ? (typeof favorite.container.imageUrl === 'string' ? favorite.container.imageUrl : favorite.container.imageUrl?.url || favorite.container.imageUrl?.value || null)
                      : null;
              }
            }
            
            const title = track?.name || track?.title || item?.name || (isPlaying ? 'Loading...' : 'Unknown Track');
            
            let artist = '';
            if (track?.artist) {
              artist = typeof track.artist === 'string' ? track.artist : track.artist?.name || track.artist?.value || '';
            } else if (track?.albumArtist) {
              artist = typeof track.albumArtist === 'string' ? track.albumArtist : track.albumArtist?.name || track.albumArtist?.value || '';
            } else if (track?.creator) {
              artist = typeof track.creator === 'string' ? track.creator : track.creator?.name || track.creator?.value || '';
            }
            
            let album = '';
            if (track?.album) {
              album = typeof track.album === 'string' ? track.album : track.album?.name || track.album?.value || '';
            } else if (track?.albumName) {
              album = typeof track.albumName === 'string' ? track.albumName : track.albumName?.name || track.albumName?.value || '';
            }
            
            // Use playlist image instead of track image
            let imageUrl = playlistImageUrl;
            
            if (imageUrl && !imageUrl.startsWith('http')) {
              imageUrl = null;
            }

            currentlyPlayingTitle.textContent = title;
            currentlyPlayingArtist.innerHTML = '';
            if (artist) {
              const artistSpan = document.createElement('span');
              artistSpan.textContent = artist;
              currentlyPlayingArtist.appendChild(artistSpan);
            }
            if (album && artist) {
              const separator = document.createTextNode(' • ');
              currentlyPlayingArtist.appendChild(separator);
              const albumSpan = document.createElement('span');
              albumSpan.textContent = album;
              currentlyPlayingArtist.appendChild(albumSpan);
            }
            if (!artist && !album) {
              currentlyPlayingArtist.innerHTML = '<span>Sonos</span>';
            }

            currentlyPlayingLocation.innerHTML = `<span>${playlistName || groupName}</span>`;

            // Handle image loading - always proxy through server
            // Calculate the final URL we'll use (proxy URL if HTTP/HTTPS)
            let finalImageUrl = null;
            if (imageUrl) {
              if (imageUrl.startsWith('http://') || imageUrl.startsWith('https://')) {
                finalImageUrl = `/api/image-proxy?url=${encodeURIComponent(imageUrl)}`;
              } else {
                finalImageUrl = imageUrl;
              }
            }
            
            // Only update if the final URL has actually changed
            if (finalImageUrl && finalImageUrl !== currentImageUrl) {
              loadImage(finalImageUrl, imageUrl);
            } else if (!finalImageUrl) {
              // No image - only show placeholder if there's no image element
              if (!currentlyPlayingArt.querySelector('img')) {
                currentlyPlayingArt.innerHTML = '<span class="currently-playing-art-placeholder">♪</span>';
              }
            }
            
            function loadImage(url, originalUrl) {
              currentImageUrl = url;
              
              // Check if there's already an img element - if so, just update src
              const existingImg = currentlyPlayingArt.querySelector('img');
              if (existingImg) {
                existingImg.src = url;
                existingImg.alt = title;
                return;
              }
              
              // Otherwise create new img element
              const img = document.createElement('img');
              img.alt = title;
              img.loading = 'lazy';
              img.style.width = '100%';
              img.style.height = '100%';
              img.style.objectFit = 'cover';
              
              img.onerror = () => {
                currentlyPlayingArt.innerHTML = '<span class="currently-playing-art-placeholder">♪</span>';
                currentImageUrl = null;
              };
              
              currentlyPlayingArt.innerHTML = '';
              currentlyPlayingArt.appendChild(img);
              img.src = url;
            }

            const playerCount = latestPlayers.filter((p) => p.groupId === groupId).length;
            if (playerCount > 1) {
              currentlyPlayingGroupIndicator.style.display = 'grid';
              currentlyPlayingGroupCount.textContent = playerCount;
              currentlyPlayingGroupCount.style.display = 'grid';
            } else {
              currentlyPlayingGroupIndicator.style.display = 'none';
              currentlyPlayingGroupCount.style.display = 'none';
            }

            // Toggle play/pause icon for right-side button using CSS classes
            // When isPlaying is true, show pause icon (add .playing class)
            // When isPlaying is false, show play icon (remove .playing class)
            const hadPlayingClass = currentlyPlayingPlayBtn.classList.contains('playing');
            if (isPlaying) {
              currentlyPlayingPlayBtn.classList.add('playing');
            } else {
              currentlyPlayingPlayBtn.classList.remove('playing');
            }
            const hasPlayingClass = currentlyPlayingPlayBtn.classList.contains('playing');
            
            // Update playback controls in expanded section using CSS classes
            const hadExpandedPlayingClass = playbackPlayPauseBtn.classList.contains('playing');
            if (isPlaying) {
              playbackPlayPauseBtn.classList.add('playing');
            } else {
              playbackPlayPauseBtn.classList.remove('playing');
            }
            const hasExpandedPlayingClass = playbackPlayPauseBtn.classList.contains('playing');
            
            // DEBUG: Button state updates
            console.log('[PlayPause] Button updates:', {
              isPlaying,
              playbackState,
              rightButton: {
                exists: !!currentlyPlayingPlayBtn,
                hadPlaying: hadPlayingClass,
                hasPlaying: hasPlayingClass,
                classList: Array.from(currentlyPlayingPlayBtn.classList)
              },
              expandedButton: {
                exists: !!playbackPlayPauseBtn,
                hadPlaying: hadExpandedPlayingClass,
                hasPlaying: hasExpandedPlayingClass,
                classList: Array.from(playbackPlayPauseBtn.classList)
              }
            });

            // Update master volume from group volume
            const groupVolume = status.volume || 0;
            masterVolumeSlider.value = groupVolume;
            masterVolumeValue.textContent = `${groupVolume}%`;

            updateCurrentlyPlayingRooms(groupId);

            currentlyPlayingPanel.classList.add('visible');
            document.body.classList.add('has-playing');
          } else {
            // Only hide if we're truly stopped - use a delay to prevent flickering
            if (playbackState === 'STOPPED' && !isPlaying) {
              clearTimeout(hidePanelTimeout);
              hidePanelTimeout = setTimeout(() => {
                if (!panelShouldBeVisible) {
                  currentlyPlayingPanel.classList.remove('visible');
                  document.body.classList.remove('has-playing');
                  currentImageUrl = null;
                }
              }, 2000); // Wait 2 seconds before hiding
            }
          }
        } catch (error) {
          console.error('Failed to update currently playing:', error);
          currentlyPlayingPanel.classList.remove('visible');
          document.body.classList.remove('has-playing');
        }
      }

      function updateCurrentlyPlayingRooms(groupId) {
        if (!groupId || !latestPlayers.length) {
          currentlyPlayingRoomsList.innerHTML = '';
          return;
        }

        // Since we're auto-grouping all players, show all players
        // The groupId format is "RINCON_XXX:PORT" where RINCON_XXX is the coordinator
        // We'll show all players since they're all in the same auto-created group
        const groupPlayers = latestPlayers;
        
        currentlyPlayingRoomsList.innerHTML = '';

        groupPlayers.forEach((player) => {
          const roomRow = document.createElement('div');
          roomRow.className = 'currently-playing-room-volume';
          roomRow.dataset.playerId = player.id;

          const name = document.createElement('span');
          name.className = 'currently-playing-room-name';
          name.textContent = player.name || player.id || 'Room';

          const slider = document.createElement('input');
          slider.type = 'range';
          slider.className = 'currently-playing-room-slider';
          slider.min = '0';
          slider.max = '100';
          slider.value = Number.isFinite(Number(player.volume)) ? Number(player.volume) : 0;

          const value = document.createElement('span');
          value.className = 'currently-playing-room-value';
          value.textContent = `${slider.value}`;

          slider.addEventListener('input', (e) => {
            e.stopPropagation();
            value.textContent = e.target.value;
          });

          slider.addEventListener('change', async (e) => {
            e.stopPropagation();
            const playerId = roomRow.dataset.playerId;
            if (playerId) {
              await setPlayerVolume(playerId, Number(e.target.value));
            }
          });

          // Prevent panel from closing when interacting with slider
          slider.addEventListener('pointerdown', (e) => {
            e.stopPropagation();
          });
          slider.addEventListener('mousedown', (e) => {
            e.stopPropagation();
          });
          slider.addEventListener('touchstart', (e) => {
            e.stopPropagation();
          });
          slider.addEventListener('touchmove', (e) => {
            e.stopPropagation();
          });
          slider.addEventListener('touchend', (e) => {
            e.stopPropagation();
          });

          roomRow.appendChild(name);
          roomRow.appendChild(slider);
          roomRow.appendChild(value);
          currentlyPlayingRoomsList.appendChild(roomRow);
        });
        
      }

      function startPlaybackRefresh() {
        clearInterval(playbackRefreshTimer);
        playbackRefreshTimer = setInterval(() => {
          if (isSonosConnected && getSelectedGroupId()) {
            // Don't refresh if a play action just occurred (within last 2 seconds)
            // This prevents refresh from overwriting correct metadata during play operations
            const timeSinceLastPlayAction = Date.now() - lastPlayActionTime;
            if (timeSinceLastPlayAction > 2000) {
              updateCurrentlyPlaying();
            }
          }
        }, 3000);
        // Only update immediately if no recent play action
        const timeSinceLastPlayAction = Date.now() - lastPlayActionTime;
        if (timeSinceLastPlayAction > 2000) {
          updateCurrentlyPlaying();
        }
      }
      
      function stopPlaybackRefresh() {
        clearInterval(playbackRefreshTimer);
        playbackRefreshTimer = null;
      }


      // Use event delegation on the panel itself - simpler and more reliable
      currentlyPlayingPanel.addEventListener('click', (e) => {
        // Don't toggle if clicking on interactive elements
        const playBtn = e.target.closest('.currently-playing-play-btn');
        const roomVolume = e.target.closest('.currently-playing-room-volume');
        const roomSlider = e.target.closest('.currently-playing-room-slider');
        const rangeInput = e.target.closest('input[type="range"]');
        const playbackControls = e.target.closest('.currently-playing-playback-controls');
        const playbackControlBtn = e.target.closest('.playback-control-btn');
        const masterVolume = e.target.closest('.currently-playing-master-volume');
        
        if (playBtn || roomVolume || roomSlider || rangeInput || playbackControls || playbackControlBtn || masterVolume) {
          return;
        }
        
        // Toggle expanded state
        currentlyPlayingPanel.classList.toggle('expanded');
        
        // Update rooms when expanding (in case they weren't loaded yet)
        if (currentlyPlayingPanel.classList.contains('expanded')) {
          const groupId = getSelectedGroupId();
          if (groupId) {
            updateCurrentlyPlayingRooms(groupId);
          }
        }
      });

      // Close panel when clicking outside of it
      document.addEventListener('click', (e) => {
        if (!currentlyPlayingPanel.classList.contains('visible')) {
          return;
        }
        
        // If click is outside the panel, close it
        if (!currentlyPlayingPanel.contains(e.target)) {
          currentlyPlayingPanel.classList.remove('expanded');
        }
      });

      // Close panel when scrolling starts (only if scroll is outside the panel)
      let isScrolling = false;
      document.addEventListener('scroll', (e) => {
        if (!currentlyPlayingPanel.classList.contains('visible') || !currentlyPlayingPanel.classList.contains('expanded')) {
          return;
        }
        
        // Check if the scroll event originated from within the panel
        const target = e.target;
        if (target && currentlyPlayingPanel.contains(target)) {
          return; // Don't close if scrolling within the panel
        }
        
        // Check if the scroll happened on the document/body (outside the panel)
        if (target === document || target === document.body || target === document.documentElement) {
          // Close immediately when scrolling starts outside the panel
          if (!isScrolling) {
            isScrolling = true;
            currentlyPlayingPanel.classList.remove('expanded');
          }
        }
      }, { passive: true, capture: true });

      // Close panel on touchmove (mobile scrolling) - only if touch is outside the panel
      document.addEventListener('touchmove', (e) => {
        if (!currentlyPlayingPanel.classList.contains('visible') || !currentlyPlayingPanel.classList.contains('expanded')) {
          return;
        }
        
        // Check if the touch event originated from within the panel
        const target = e.target;
        if (target && currentlyPlayingPanel.contains(target)) {
          return; // Don't close if touching/swiping within the panel
        }
        
        // Only close if touch is outside the panel
        currentlyPlayingPanel.classList.remove('expanded');
      }, { passive: true, capture: true });

      // Reset scrolling flag when scroll ends
      let scrollEndTimeout = null;
      document.addEventListener('scroll', () => {
        clearTimeout(scrollEndTimeout);
        scrollEndTimeout = setTimeout(() => {
          isScrolling = false;
        }, 150);
      }, { passive: true });

      currentlyPlayingPlayBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const groupId = getSelectedGroupId();
        if (!groupId) {
          return;
        }
        
        const wasPlaying = currentlyPlayingPlayBtn.classList.contains('playing');
        currentlyPlayingPlayBtn.disabled = true;
        
        try {
          await handlePlaybackAction('playpause');
          setTimeout(() => {
            updateCurrentlyPlaying();
            currentlyPlayingPlayBtn.disabled = false;
          }, 600);
        } catch (error) {
          console.error('Playback toggle failed:', error);
          currentlyPlayingPlayBtn.disabled = false;
          setTimeout(() => updateCurrentlyPlaying(), 500);
        }
      });

      function setActiveGroup(groupId, name, { refreshFavorites = false } = {}) {
        currentGroupId = groupId || null;
        currentGroupName = currentGroupId ? name || currentGroupName || 'Group' : 'No group selected';
        updateActiveGroupDisplay();
        evaluateFavoritesAvailability();
        if (refreshFavorites && currentHouseholdId) {
          loadFavorites(currentHouseholdId).catch((error) => {
            console.error('Failed to refresh favorites', error);
          });
        }
        if (groupId) {
          startPlaybackRefresh();
        } else {
          stopPlaybackRefresh();
        }
      }

      window.addEventListener('load', () => {
        applyAuthFeedback();
        checkAuthAndInit();
      });
    </script>


  </body>
</html>
