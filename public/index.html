<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Sonos Controller</title>
    <style>
      :root {
        color-scheme: light dark;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
        --bg-primary: #ffffff;
        --bg-secondary: #f8f9fa;
        --bg-tertiary: #f1f3f5;
        --text-primary: #1a1a1a;
        --text-secondary: #6b7280;
        --text-tertiary: #9ca3af;
        --border-color: #e5e7eb;
        --accent: #000000;
        --accent-hover: #1a1a1a;
        --success: #10b981;
        --error: #ef4444;
        --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      }

      @media (prefers-color-scheme: dark) {
        :root {
          --bg-primary: #0a0a0a;
          --bg-secondary: #141414;
          --bg-tertiary: #1a1a1a;
          --text-primary: #fafafa;
          --text-secondary: #a1a1aa;
          --text-tertiary: #71717a;
          --border-color: #27272a;
          --accent: #ffffff;
          --accent-hover: #f4f4f5;
        }
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        background: var(--bg-secondary);
        color: var(--text-primary);
        min-height: 100vh;
        display: flex;
        align-items: stretch;
        justify-content: center;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .container {
        width: min(480px, 100vw);
        padding: 20px;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        gap: 24px;
      }

      .app-tabs {
        display: flex;
        gap: 4px;
        background: var(--bg-tertiary);
        padding: 4px;
        border-radius: 12px;
        margin-bottom: 8px;
      }

      .tab-button {
        flex: 1;
        padding: 10px 16px;
        border-radius: 8px;
        border: none;
        background: transparent;
        color: var(--text-secondary);
        font-weight: 500;
        font-size: 0.9375rem;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .tab-button.active {
        background: var(--bg-primary);
        color: var(--text-primary);
        box-shadow: var(--shadow-sm);
      }

      .tab-button:hover:not(.active) {
        color: var(--text-primary);
      }

      h1 {
        font-size: 1.5rem;
        font-weight: 600;
        margin: 0;
        text-align: center;
        letter-spacing: -0.02em;
      }

      p.status {
        margin: 0;
        text-align: center;
        font-weight: 500;
        font-size: 0.875rem;
      }

      p.status.connected {
        color: var(--success);
      }

      p.status.disconnected {
        color: var(--error);
      }

      .feedback {
        min-height: 1.25rem;
        text-align: center;
        font-size: 0.875rem;
        color: var(--text-secondary);
      }

      .feedback.error {
        color: var(--error);
      }

      section {
        background: var(--bg-primary);
        border-radius: 16px;
        padding: 20px;
        border: 1px solid var(--border-color);
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      label {
        font-size: 0.8125rem;
        font-weight: 500;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.05em;
        margin-bottom: 8px;
        display: block;
      }

      select {
        width: 100%;
        padding: 12px 16px;
        border-radius: 10px;
        border: 1px solid var(--border-color);
        background: var(--bg-primary);
        color: var(--text-primary);
        font-size: 0.9375rem;
        font-weight: 500;
        appearance: none;
        cursor: pointer;
        transition: border-color 0.2s ease;
      }

      select:focus {
        outline: none;
        border-color: var(--accent);
      }

      select:hover {
        border-color: var(--text-tertiary);
      }

      button {
        border: none;
        border-radius: 10px;
        padding: 12px 20px;
        font-size: 0.9375rem;
        font-weight: 500;
        background: var(--accent);
        color: var(--bg-primary);
        cursor: pointer;
        transition: all 0.2s ease;
      }

      button:hover:not(:disabled) {
        background: var(--accent-hover);
      }

      button:active:not(:disabled) {
        transform: scale(0.98);
      }

      button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }

      button.secondary {
        background: var(--bg-tertiary);
        color: var(--text-primary);
      }

      button.secondary:hover:not(:disabled) {
        background: var(--border-color);
      }

      .controls,
      .volume {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .control-buttons {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
      }

      .control-buttons button {
        padding: 14px 12px;
        font-size: 0.875rem;
      }

      .control-buttons button:first-child {
        grid-column: 1 / -1;
        padding: 16px;
        font-size: 0.9375rem;
      }

      .slider-row {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      input[type='range'] {
        width: 100%;
        height: 6px;
        accent-color: var(--accent);
        cursor: pointer;
      }

      .volume-value {
        min-width: 3.5rem;
        text-align: right;
        font-variant-numeric: tabular-nums;
        font-size: 0.875rem;
        font-weight: 500;
        color: var(--text-secondary);
      }

      .group-chip {
        display: inline-flex;
        align-items: center;
        padding: 10px 16px;
        border-radius: 10px;
        border: 1px solid var(--border-color);
        background: var(--bg-tertiary);
        font-size: 0.875rem;
        font-weight: 500;
        min-width: 140px;
        justify-content: center;
        color: var(--text-primary);
      }

      .settings-row {
        display: grid;
        grid-template-columns: 1fr auto auto;
        gap: 12px;
        align-items: center;
        margin-bottom: 12px;
        background: var(--bg-secondary);
        padding: 16px;
        border-radius: 12px;
        border: 1px solid var(--border-color);
      }

      .favorites {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .vibe-filters {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
        margin-bottom: 4px;
      }

      .vibe-filter-btn {
        padding: 8px 16px;
        border-radius: 8px;
        border: 1px solid var(--border-color);
        background: var(--bg-secondary);
        color: var(--text-secondary);
        font-size: 0.8125rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .vibe-filter-btn:hover {
        background: var(--bg-tertiary);
        color: var(--text-primary);
      }

      .vibe-filter-btn.active {
        background: var(--accent);
        color: var(--bg-primary);
        border-color: var(--accent);
      }

      .favorites-grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
      }

      .favorites-status {
        font-size: 0.875rem;
        color: var(--text-secondary);
      }

      .section-title {
        font-size: 0.9375rem;
        font-weight: 600;
        letter-spacing: -0.01em;
        color: var(--text-primary);
      }

      .playlist-card {
        display: flex;
        flex-direction: column;
        gap: 14px;
        padding: 16px;
        border-radius: 12px;
        border: 1px solid var(--border-color);
        background: var(--bg-primary);
        color: inherit;
        text-align: left;
        box-shadow: var(--shadow-sm);
        transition: all 0.2s ease;
        cursor: pointer;
      }

      .playlist-card:hover:not(:disabled) {
        box-shadow: var(--shadow-md);
        border-color: var(--text-tertiary);
      }

      .playlist-card-content {
        display: flex;
        align-items: center;
        gap: 14px;
      }

      .playlist-card:not(:disabled):active {
        transform: scale(0.99);
      }

      .playlist-card.disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .playlist-card.loading {
        cursor: progress;
      }

      .playlist-card.active {
        border-color: var(--accent);
        box-shadow: var(--shadow-md);
      }

      .playlist-art-wrapper {
        width: 60px;
        height: 60px;
        border-radius: 10px;
        overflow: hidden;
        flex-shrink: 0;
        background: var(--bg-tertiary);
        display: grid;
        place-items: center;
        box-shadow: var(--shadow-sm);
      }

      .playlist-art {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .playlist-meta {
        display: flex;
        flex-direction: column;
        gap: 6px;
        align-items: flex-start;
        flex: 1;
        min-width: 0;
      }

      .playlist-placeholder {
        font-size: 1.5rem;
        color: var(--text-tertiary);
      }

      .playlist-brand {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--text-tertiary);
        font-weight: 500;
      }

      .playlist-brand svg {
        width: 14px;
        height: 14px;
        fill: currentColor;
      }

      .playlist-name {
        font-size: 0.9375rem;
        font-weight: 500;
        color: var(--text-primary);
        line-height: 1.4;
        overflow: hidden;
        text-overflow: ellipsis;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        line-clamp: 2;
        -webkit-box-orient: vertical;
      }

      .playlist-status {
        font-size: 0.8125rem;
        color: var(--text-secondary);
      }

      .playlist-vibe-selector {
        display: flex;
        align-items: center;
        gap: 10px;
        padding-top: 12px;
        border-top: 1px solid var(--border-color);
      }

      .playlist-vibe-selector label {
        font-size: 0.8125rem;
        font-weight: 500;
        color: var(--text-secondary);
        white-space: nowrap;
      }

      .playlist-vibe-selector select {
        flex: 1;
        padding: 8px 12px;
        border-radius: 8px;
        border: 1px solid var(--border-color);
        background: var(--bg-secondary);
        color: var(--text-primary);
        font-size: 0.8125rem;
        font-weight: 500;
        appearance: none;
        cursor: pointer;
        transition: border-color 0.2s ease;
      }

      .playlist-vibe-selector select:focus {
        outline: none;
        border-color: var(--accent);
      }

      .playlist-vibe-selector select:hover {
        border-color: var(--text-tertiary);
      }

      .settings-actions {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-top: 8px;
        flex-wrap: wrap;
      }

      .settings-status {
        min-height: 1.2rem;
        font-size: 0.875rem;
        color: var(--text-secondary);
      }

      .rooms {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .room-card {
        display: flex;
        flex-direction: column;
        gap: 14px;
        padding: 16px;
        border-radius: 12px;
        background: var(--bg-primary);
        border: 1px solid var(--border-color);
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .room-card:hover {
        border-color: var(--text-tertiary);
        box-shadow: var(--shadow-sm);
      }

      .room-card.active {
        border-color: var(--accent);
        box-shadow: var(--shadow-md);
      }

      .room-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      .room-name {
        font-weight: 500;
        font-size: 0.9375rem;
        color: var(--text-primary);
      }

      .room-group-label {
        font-size: 0.8125rem;
        color: var(--text-secondary);
        font-weight: 400;
      }

      .room-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .room-actions button {
        font-size: 0.8125rem;
        padding: 8px 14px;
        border-radius: 8px;
        background: var(--bg-tertiary);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
      }

      .room-actions button:hover:not(:disabled) {
        background: var(--border-color);
      }

      .volume-row {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .volume-row span {
        font-size: 0.875rem;
        min-width: 56px;
        font-weight: 500;
        color: var(--text-secondary);
      }

      .hidden {
        display: none !important;
      }

      #auth-bar {
        display: flex;
        gap: 8px;
        margin-bottom: 8px;
      }

      #auth-bar button {
        flex: 1;
      }

      .select-group {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .currently-playing {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: var(--bg-primary);
        border-top: 1px solid var(--border-color);
        padding: 12px 16px 24px 16px;
        display: none;
        z-index: 100;
        box-shadow: 0 -4px 6px -1px rgba(0, 0, 0, 0.1);
        max-height: 100vh;
        overflow-y: auto;
        transition: transform 0.3s ease-out;
        transform: translateY(0);
      }

      .currently-playing.visible {
        display: block;
      }

      .currently-playing.expanded {
        transform: translateY(0);
      }

      .currently-playing-content {
        max-width: 480px;
        margin: 0 auto;
        display: flex;
        align-items: center;
        gap: 12px;
        cursor: pointer;
      }

      .currently-playing-content:not(:has(.currently-playing-play-btn:hover)):hover {
        opacity: 0.9;
      }

      .currently-playing-art {
        width: 56px;
        height: 56px;
        border-radius: 8px;
        overflow: hidden;
        flex-shrink: 0;
        background: var(--bg-tertiary);
        display: grid;
        place-items: center;
      }

      .currently-playing-art img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .currently-playing-art-placeholder {
        font-size: 1.25rem;
        color: var(--text-tertiary);
      }

      .currently-playing-info {
        flex: 1;
        min-width: 0;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .currently-playing-location {
        font-size: 0.75rem;
        color: var(--text-secondary);
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 4px;
      }

      .currently-playing-title {
        font-size: 0.9375rem;
        font-weight: 600;
        color: var(--text-primary);
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .currently-playing-artist {
        font-size: 0.8125rem;
        color: var(--text-secondary);
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .currently-playing-controls {
        display: flex;
        align-items: center;
        gap: 12px;
        flex-shrink: 0;
      }

      .currently-playing-group-indicator {
        width: 32px;
        height: 32px;
        border-radius: 6px;
        background: var(--bg-tertiary);
        border: 1px solid var(--border-color);
        display: grid;
        place-items: center;
        font-size: 0.75rem;
        font-weight: 600;
        color: var(--text-primary);
        position: relative;
      }

      .currently-playing-group-count {
        position: absolute;
        top: -4px;
        right: -4px;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: var(--accent);
        color: var(--bg-primary);
        font-size: 0.625rem;
        font-weight: 600;
        display: grid;
        place-items: center;
      }

      .currently-playing-play-btn {
        width: 56px;
        height: 56px;
        border-radius: 50%;
        background: var(--bg-primary);
        border: 2px solid var(--border-color);
        color: var(--text-primary);
        display: grid;
        place-items: center;
        cursor: pointer;
        transition: all 0.2s ease;
        flex-shrink: 0;
        box-shadow: var(--shadow-sm);
      }

      .currently-playing-play-btn:hover {
        background: var(--bg-tertiary);
        border-color: var(--accent);
        transform: scale(1.05);
        box-shadow: var(--shadow-md);
      }

      .currently-playing-play-btn:active {
        transform: scale(0.95);
      }

      .currently-playing-play-btn svg {
        width: 24px;
        height: 24px;
        fill: currentColor;
      }

      .currently-playing-play-btn.playing {
        background: var(--accent);
        border-color: var(--accent);
        color: var(--bg-primary);
      }

      .currently-playing-play-btn.playing:hover {
        background: var(--accent-hover);
        border-color: var(--accent-hover);
      }

      .currently-playing-play-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      .currently-playing-volume {
        flex-direction: column;
        gap: 20px;
        margin-top: 0;
        padding-top: 0;
        padding-bottom: 0;
        border-top: none;
        max-height: 0;
        overflow: hidden;
        opacity: 0;
        transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1), 
                    padding 0.4s cubic-bezier(0.4, 0, 0.2, 1), 
                    margin 0.4s cubic-bezier(0.4, 0, 0.2, 1), 
                    opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                    border-top 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .currently-playing.expanded .currently-playing-volume {
        margin-top: 12px;
        padding-top: 12px;
        padding-bottom: 8px;
        border-top: 1px solid var(--border-color);
        max-height: 500px;
        opacity: 1;
      }

      .currently-playing-room-volume {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px 0;
        min-height: 44px;
      }

      .currently-playing-room-name {
        min-width: 100px;
        font-size: 0.875rem;
        font-weight: 500;
        color: var(--text-primary);
      }

      .currently-playing-room-slider {
        flex: 1;
        height: 4px;
        accent-color: var(--accent);
        cursor: pointer;
      }

      .currently-playing-room-value {
        min-width: 2.5rem;
        text-align: right;
        font-size: 0.8125rem;
        font-weight: 500;
        color: var(--text-secondary);
        font-variant-numeric: tabular-nums;
      }

      body {
        padding-bottom: 0;
      }

      body.has-playing {
        padding-bottom: 100px;
      }
    </style>
  </head>
  <body>
    <main class="container">
      <h1>Sonos Controller</h1>
      <p id="status" class="status disconnected">Checking connectionâ€¦</p>
      <div id="feedback" class="feedback"></div>

      <div id="auth-bar" style="margin-bottom: 12px">
        <button id="signin-btn" onclick="login()">Sign in with Sonos</button>
        <button id="signout-btn" class="hidden" onclick="signout()">Sign out</button>
      </div>

      <div id="app-panels" class="hidden">
        <nav class="app-tabs">
          <button id="tab-control" class="tab-button active" type="button">Control</button>
          <button id="tab-settings" class="tab-button" type="button">Settings</button>
        </nav>

        <section id="panel-control">
          <div class="select-group">
            <label for="households">Household</label>
            <select id="households"></select>
          </div>

          <div class="controls">
            <span>Playback</span>
            <div class="control-buttons">
              <button data-action="playpause">Play / Pause</button>
              <button data-action="previous" class="secondary">Previous</button>
              <button data-action="next" class="secondary">Next</button>
            </div>
          </div>

          <div class="volume">
            <span>Volume</span>
            <div class="slider-row">
              <input id="volume-slider" type="range" min="0" max="100" step="1" value="35" />
              <span id="volume-value" class="volume-value">35%</span>
            </div>
          </div>

          <div class="favorites">
            <span class="section-title">Favorites</span>
            <div id="vibe-filters" class="vibe-filters"></div>
            <p id="favorites-status" class="favorites-status">Sign in to load favorites.</p>
            <div id="favorites-grid" class="favorites-grid"></div>
          </div>

        </section>

        <section id="panel-settings" class="hidden">
          <h3 class="section-title">Default Volumes (on play)</h3>
          <p id="settings-help" class="favorites-status">
            Set a default launch volume for each speaker. Leave blank to keep its current level.
          </p>
          <div id="settings-players"></div>
          <div class="settings-actions">
            <button id="settings-save" type="button">Save Defaults</button>
            <span id="settings-status" class="settings-status"></span>
          </div>
        </section>
      </div>

      <div id="currently-playing" class="currently-playing">
        <div class="currently-playing-content">
          <div class="currently-playing-art" id="currently-playing-art">
            <span class="currently-playing-art-placeholder">â™ª</span>
          </div>
          <div class="currently-playing-info">
            <div class="currently-playing-location" id="currently-playing-location">
              <span>No group selected</span>
            </div>
            <div class="currently-playing-title" id="currently-playing-title">
              Nothing playing
            </div>
            <div class="currently-playing-artist" id="currently-playing-artist">
              <span></span>
            </div>
          </div>
          <div class="currently-playing-controls">
            <div class="currently-playing-group-indicator" id="currently-playing-group-indicator" style="display: none;">
              <span>ðŸ”Š</span>
              <span class="currently-playing-group-count" id="currently-playing-group-count" style="display: none;">1</span>
            </div>
            <button class="currently-playing-play-btn" id="currently-playing-play-btn" type="button">
              <svg viewBox="0 0 24 24">
                <path d="M8 5v14l11-7z" />
              </svg>
            </button>
          </div>
        </div>
        <div class="currently-playing-volume" id="currently-playing-volume">
          <div id="currently-playing-rooms-list"></div>
        </div>
      </div>
    </main>

    <script>
      const SELECT_GROUP_MESSAGE = 'Ready to play';
      const READY_MESSAGE = 'Ready to play';
      const FAVORITE_SUCCESS_MESSAGE = 'Loaded â€¢ Shuffle / Repeat / Crossfade ON';
      const FAVORITE_ERROR_MESSAGE = 'Favorite failed to start';
      const LOADING_MESSAGE = 'Loadingâ€¦';
      const FAVORITE_SUCCESS_TOAST = 'Favorite loaded with shuffle, repeat, crossfade.';

      const statusLabel = document.getElementById('status');
      const feedbackLabel = document.getElementById('feedback');
      const signinButton = document.getElementById('signin-btn');
      const signoutButton = document.getElementById('signout-btn');
      const panelsContainer = document.getElementById('app-panels');
      const panelControl = document.getElementById('panel-control');
      const panelSettings = document.getElementById('panel-settings');
      const tabControlButton = document.getElementById('tab-control');
      const tabSettingsButton = document.getElementById('tab-settings');
      const householdSelect = document.getElementById('households');
      const volumeSlider = document.getElementById('volume-slider');
      const volumeValue = document.getElementById('volume-value');
      const favoritesGrid = document.getElementById('favorites-grid');
      const favoritesStatus = document.getElementById('favorites-status');
      const vibeFiltersContainer = document.getElementById('vibe-filters');
      const currentlyPlayingPanel = document.getElementById('currently-playing');
      const currentlyPlayingArt = document.getElementById('currently-playing-art');
      const currentlyPlayingLocation = document.getElementById('currently-playing-location');
      const currentlyPlayingTitle = document.getElementById('currently-playing-title');
      const currentlyPlayingArtist = document.getElementById('currently-playing-artist');
      const currentlyPlayingGroupIndicator = document.getElementById('currently-playing-group-indicator');
      const currentlyPlayingGroupCount = document.getElementById('currently-playing-group-count');
      const currentlyPlayingPlayBtn = document.getElementById('currently-playing-play-btn');
      const currentlyPlayingVolume = document.getElementById('currently-playing-volume');
      const currentlyPlayingRoomsList = document.getElementById('currently-playing-rooms-list');
      // Track panel state to prevent flickering
      let panelShouldBeVisible = false;
      let hidePanelTimeout = null;
      
const settingsPlayersWrap = document.getElementById('settings-players');
const settingsSaveButton = document.getElementById('settings-save');
const settingsStatusLabel = document.getElementById('settings-status');
const settingsHelpLabel = document.getElementById('settings-help');

settingsSaveButton.disabled = true;
settingsStatusLabel.textContent = '';

      let isSonosConnected = false;
      let currentHouseholdId = null;
      let currentGroupId = null;
      let currentGroupName = 'No group selected';
      let currentActiveFavoriteId = null;
      const favoritesRegistry = new Map();
      let latestPlayers = [];
      let latestGroups = [];
      let refreshTimer = null;
      let playlistVibes = {};
      let currentVibeFilter = null;
      let playbackRefreshTimer = null;
      let currentPlaybackState = null;
      let currentImageUrl = null;

      function login() {
        window.location.href = '/auth/sonos/login';
      }

async function signout() {
  try {
    await fetch('/auth/signout', { method: 'POST' });
  } catch (error) {
    console.error('Sign out failed:', error);
  }
  setAuthUI(false);
  showFeedback('Signed out of Sonos.');
}

function showTab(name) {
  const isControl = name === 'control';
  tabControlButton.classList.toggle('active', isControl);
  tabSettingsButton.classList.toggle('active', !isControl);
  panelControl.classList.toggle('hidden', !isControl);
  panelSettings.classList.toggle('hidden', isControl);
}

tabControlButton.addEventListener('click', () => {
  showTab('control');
});

tabSettingsButton.addEventListener('click', async () => {
  showTab('settings');
  await renderSettings();
});

function setAuthUI(loggedIn) {
  signinButton.classList.toggle('hidden', loggedIn);
  signoutButton.classList.toggle('hidden', !loggedIn);
  panelsContainer.classList.toggle('hidden', !loggedIn);
  if (!loggedIn) {
    showTab('control');
  }
  updateConnectionStatus(loggedIn);
}

async function checkAuthAndInit() {
  try {
    const response = await fetch('/auth/status');
    if (!response.ok) {
      throw new Error('Failed to check auth status');
    }

    const state = await response.json();
    const loggedIn = Boolean(state.loggedIn);
    setAuthUI(loggedIn);
    showTab('control');

    if (loggedIn) {
      await refreshUI();
    }
  } catch (error) {
          console.error('Auth status check failed:', error);
          setAuthUI(false);
        }
      }

      householdSelect.addEventListener('change', async (event) => {
        const householdId = event.target.value;
        currentHouseholdId = householdId || null;

        if (!householdId) {
          currentGroupId = null;
          currentGroupName = 'No group selected';
          updateActiveGroupDisplay();
          await loadFavorites(null);
          await loadPlayers(null);
          evaluateFavoritesAvailability();
          setVolumeControlAvailability(false);
          return;
        }

    showFeedback('Loading roomsâ€¦');
    await loadPlayers(householdId);
    await loadFavorites(householdId);
    if (!panelSettings.classList.contains('hidden')) {
      await renderSettings();
    }
    showFeedback('Rooms ready.');
  });

      document
        .querySelectorAll('[data-action]')
        .forEach((button) =>
          button.addEventListener('click', () => handlePlaybackAction(button.dataset.action))
        );

      volumeSlider.addEventListener('input', () => updateVolumeDisplay(volumeSlider.value));
      volumeSlider.addEventListener('change', () => setVolume(Number(volumeSlider.value)));
      const authMessages = {
        success: 'Sonos authorization complete. Ready to control playback.',
        error: 'Authorization failed. Please try logging in again.',
        missing_code: 'Login response missing authorization code.',
        invalid_state: 'Login validation failed. Please retry.'
      };

      function applyAuthFeedback() {
        const params = new URLSearchParams(window.location.search);
        const state = params.get('auth');

        if (state && authMessages[state]) {
          showFeedback(authMessages[state], state !== 'success');
          params.delete('auth');
          const newUrl = window.location.pathname + (params.toString() ? `?${params}` : '');
          window.history.replaceState({}, '', newUrl);
        }
      }

      function updateConnectionStatus(connected) {
        statusLabel.classList.toggle('connected', connected);
        statusLabel.classList.toggle('disconnected', !connected);
        statusLabel.textContent = connected ? 'Connected to Sonos' : 'Not connected';
        isSonosConnected = connected;

        if (!connected) {
          householdSelect.innerHTML = '';
          currentHouseholdId = null;
          setVolumeControlAvailability(false);
          favoritesStatus.textContent = 'Login required to load favorites.';
          vibeFiltersContainer.innerHTML = '';
          currentGroupId = null;
          currentGroupName = 'No group selected';
          updateActiveGroupDisplay();
          currentActiveFavoriteId = null;
          settingsPlayersWrap.innerHTML = '';
          settingsStatusLabel.textContent = '';
          if (settingsHelpLabel) {
            settingsHelpLabel.textContent = 'Sign in to load speakers.';
          }
          stopPlaybackRefresh();
          currentlyPlayingPanel.classList.remove('visible');
          document.body.classList.remove('has-playing');
        }

        settingsSaveButton.disabled = !connected;
        evaluateFavoritesAvailability();
      }

      function showFeedback(message, isError = false) {
        feedbackLabel.textContent = message ?? '';
        feedbackLabel.classList.toggle('error', Boolean(isError));
      }

      function getSelectedGroupId() {
        return currentGroupId;
      }

      function updateActiveGroupDisplay() {
        // Group display removed - groups are auto-created
      }


      async function loadHouseholds() {
        try {
          const response = await fetch('/api/households');

          if (response.status === 401) {
            setAuthUI(false);
            showFeedback('Login required to load Sonos households.', true);
            favoritesStatus.textContent = 'Login required to load favorites.';
            return;
          }

          if (!response.ok) {
            throw new Error(await response.text());
          }

          const data = await response.json();
          const households = Array.isArray(data.households) ? data.households : [];

          if (!households.length) {
            setAuthUI(true);
            showFeedback('No households returned for this account.', true);
            householdSelect.innerHTML = '';
            currentHouseholdId = null;
            currentGroupId = null;
            currentGroupName = 'No group selected';
            currentActiveFavoriteId = null;
            updateActiveGroupDisplay();
            setVolumeControlAvailability(false);
            await loadFavorites(null);
            await loadPlayers(null);
            evaluateFavoritesAvailability();
            return;
          }

          householdSelect.innerHTML = households
            .map(
              (household) =>
                `<option value="${household.id}">${household.name || household.id}</option>`
            )
            .join('');

          setAuthUI(true);
          showFeedback('Households loaded. Choose one to continue.');

          currentHouseholdId = householdSelect.value || null;

          if (currentHouseholdId) {
            await loadPlayers(currentHouseholdId);
            await loadFavorites(currentHouseholdId);
          } else {
            await loadFavorites(null);
            await loadPlayers(null);
            evaluateFavoritesAvailability();
          }

          if (!panelSettings.classList.contains('hidden')) {
            await renderSettings();
          }
        } catch (error) {
          console.error('Failed to load households:', error);
          showFeedback('Could not load households. Please try again.', true);
          setAuthUI(false);
          favoritesStatus.textContent = 'Unable to load favorites.';
      }
    }

      async function fetchGroupsPlayers(householdId) {
        if (!householdId) {
          return { groups: [], players: [] };
        }

        const response = await fetch(
          `/api/households/${encodeURIComponent(householdId)}/groups-players`
        );

        if (!response.ok) {
          throw new Error(await response.text());
        }

        return response.json();
      }

      async function renderSettings() {
        if (panelSettings.classList.contains('hidden')) {
          return;
        }

        settingsStatusLabel.textContent = '';

        if (!isSonosConnected) {
          settingsPlayersWrap.innerHTML = '';
          if (settingsHelpLabel) {
            settingsHelpLabel.textContent = 'Sign in to load speakers.';
          }
          settingsSaveButton.disabled = true;
          settingsSaveButton.onclick = null;
          return;
        }

        const householdId = householdSelect.value;
        if (!householdId) {
          settingsPlayersWrap.innerHTML = '';
          if (settingsHelpLabel) {
            settingsHelpLabel.textContent = 'Select a household to load speakers.';
          }
          settingsSaveButton.disabled = true;
          settingsSaveButton.onclick = null;
          return;
        }

        if (settingsHelpLabel) {
          settingsHelpLabel.textContent =
            'Set a default launch volume for each speaker. Leave blank to keep its current level.';
        }

        try {
          const [snapshot, defaults] = await Promise.all([
            fetchGroupsPlayers(householdId),
            fetch('/api/settings/volumes').then((response) => {
              if (!response.ok) {
                throw new Error('Failed to load saved volumes');
              }
              return response.json();
            })
          ]);

          const players = Array.isArray(snapshot.players) ? snapshot.players : [];
          settingsPlayersWrap.innerHTML = '';

          if (!players.length) {
            settingsSaveButton.disabled = true;
            settingsStatusLabel.textContent = 'No speakers found for this household.';
            settingsSaveButton.onclick = null;
            return;
          }

          players.forEach((player) => {
            const row = document.createElement('div');
            row.className = 'settings-row';
            row.dataset.playerId = player.id;

            const nameLabel = document.createElement('strong');
            nameLabel.textContent = player.name || player.id || 'Speaker';

            const rangeInput = document.createElement('input');
            rangeInput.type = 'range';
            rangeInput.min = '0';
            rangeInput.max = '100';

            const numberInput = document.createElement('input');
            numberInput.type = 'number';
            numberInput.min = '0';
            numberInput.max = '100';
            numberInput.placeholder = 'â€”';

            const defaultValue =
              defaults && typeof defaults[player.id] === 'number'
                ? Math.max(0, Math.min(100, Number(defaults[player.id])))
                : null;

            if (defaultValue === null || Number.isNaN(defaultValue)) {
              rangeInput.value = '50';
              numberInput.value = '';
            } else {
              rangeInput.value = String(defaultValue);
              numberInput.value = String(defaultValue);
            }

            rangeInput.addEventListener('input', (event) => {
              numberInput.value = event.target.value;
            });

            numberInput.addEventListener('input', (event) => {
              const raw = event.target.value.trim();
              if (raw === '') {
                return;
              }

              let numeric = Number(raw);
              if (Number.isNaN(numeric)) {
                numeric = '';
              } else {
                numeric = Math.max(0, Math.min(100, numeric));
              }

              if (numeric === '') {
                event.target.value = '';
              } else {
                event.target.value = String(numeric);
                rangeInput.value = String(numeric);
              }
            });

            row.appendChild(nameLabel);
            row.appendChild(rangeInput);
            row.appendChild(numberInput);
            settingsPlayersWrap.appendChild(row);
          });

          settingsSaveButton.disabled = false;
          settingsSaveButton.onclick = async () => {
            try {
              settingsSaveButton.disabled = true;
              settingsStatusLabel.textContent = 'Savingâ€¦';

              const payload = {};
              settingsPlayersWrap.querySelectorAll('.settings-row').forEach((row) => {
                const playerId = row.dataset.playerId;
                const input = row.querySelector('input[type="number"]');
                if (!playerId || !input) {
                  return;
                }

                const value = input.value.trim();
                if (value !== '') {
                  payload[playerId] = Number(value);
                }
              });

              const response = await fetch('/api/settings/volumes', {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
              });

              if (!response.ok) {
                throw new Error(await response.text());
              }

              settingsStatusLabel.textContent = 'Saved defaults.';
            } catch (error) {
              console.error('Failed to save volume defaults:', error);
              settingsStatusLabel.textContent = 'Failed to save defaults.';
            } finally {
              settingsSaveButton.disabled = false;
            }
          };
        } catch (error) {
          console.error('Failed to render settings:', error);
          settingsPlayersWrap.innerHTML = '';
          settingsStatusLabel.textContent = 'Failed to load speaker data.';
          settingsSaveButton.disabled = true;
          settingsSaveButton.onclick = null;
        }
      }

      async function loadPlaylistVibes() {
        try {
          const response = await fetch('/api/playlist-vibes');
          if (response.ok) {
            playlistVibes = await response.json();
          }
        } catch (error) {
          console.error('Failed to load playlist vibes:', error);
        }
      }

      async function setPlaylistVibe(playlistId, vibe) {
        if (vibe) {
          playlistVibes[playlistId] = vibe;
        } else {
          delete playlistVibes[playlistId];
        }

        try {
          const response = await fetch('/api/playlist-vibes', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(playlistVibes)
          });

          if (!response.ok) {
            throw new Error('Failed to save vibe');
          }

          applyVibeFilter();
        } catch (error) {
          console.error('Failed to save playlist vibe:', error);
        }
      }

      function renderVibeFilters() {
        vibeFiltersContainer.innerHTML = '';

        const allButton = document.createElement('button');
        allButton.className = 'vibe-filter-btn';
        allButton.textContent = 'All';
        allButton.classList.toggle('active', currentVibeFilter === null);
        allButton.addEventListener('click', () => {
          currentVibeFilter = null;
          applyVibeFilter();
        });
        vibeFiltersContainer.appendChild(allButton);

        ['Down', 'Down/Mid', 'Mid'].forEach((vibe) => {
          const button = document.createElement('button');
          button.className = 'vibe-filter-btn';
          button.textContent = vibe;
          button.classList.toggle('active', currentVibeFilter === vibe);
          button.addEventListener('click', () => {
            currentVibeFilter = vibe;
            applyVibeFilter();
          });
          vibeFiltersContainer.appendChild(button);
        });
      }

      function applyVibeFilter() {
        favoritesRegistry.forEach((entry) => {
          const vibe = playlistVibes[entry.favorite.id] || null;
          const shouldShow = currentVibeFilter === null || vibe === currentVibeFilter;
          entry.button.style.display = shouldShow ? '' : 'none';
        });
      }

      async function loadFavorites(householdId) {
        favoritesRegistry.clear();
        favoritesGrid.innerHTML = '';

        if (!householdId) {
          favoritesStatus.textContent = isSonosConnected
            ? 'Select a household to load favorites.'
            : 'Login required to load favorites.';
          vibeFiltersContainer.innerHTML = '';
          evaluateFavoritesAvailability();
          return;
        }

        favoritesStatus.textContent = 'Loading favoritesâ€¦';

        try {
          await loadPlaylistVibes();

          const params = new URLSearchParams({ householdId });
          const activeGroupId = getSelectedGroupId();
          if (activeGroupId) {
            params.set('groupId', activeGroupId);
          }

          const response = await fetch(`/api/favorites?${params.toString()}`);

          if (response.status === 401) {
            setAuthUI(false);
            favoritesStatus.textContent = 'Login required to load favorites.';
            return;
          }

          if (!response.ok) {
            throw new Error(await response.text());
          }

          const data = await response.json();
          const items = Array.isArray(data.items) ? data.items : [];
          currentActiveFavoriteId = data.activeFavorite ?? null;

          if (!items.length) {
            favoritesStatus.textContent = 'No favorites found.';
            vibeFiltersContainer.innerHTML = '';
            evaluateFavoritesAvailability();
            return;
          }

          favoritesStatus.textContent = '';

          items.forEach((favorite) => {
            const entry = createFavoriteCard(favorite);
            favoritesRegistry.set(favorite.id, entry);
            favoritesGrid.appendChild(entry.button);
          });

          renderVibeFilters();
          applyVibeFilter();
          evaluateFavoritesAvailability();
          markActiveFavorite(currentActiveFavoriteId);
        } catch (error) {
          console.error('Failed to load favorites:', error);
          favoritesStatus.textContent = 'Could not load favorites. Please try again.';
          vibeFiltersContainer.innerHTML = '';
          evaluateFavoritesAvailability();
        }
      }

      function createFavoriteCard(favorite) {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'playlist-card disabled';
        button.disabled = true;
        button.dataset.favoriteId = favorite.id;

        const artWrapper = document.createElement('div');
        artWrapper.className = 'playlist-art-wrapper';

        const imageUrl =
          favorite && favorite.imageUrl
            ? favorite.imageUrl
            : favorite && favorite.images && favorite.images.length && favorite.images[0].url
              ? favorite.images[0].url
              : favorite && favorite.container && favorite.container.imageUrl
                ? favorite.container.imageUrl
                : null;

        if (imageUrl) {
          const img = document.createElement('img');
          img.className = 'playlist-art';
          img.alt = `${favorite.name || 'Favorite'} cover art`;
          img.loading = 'lazy';
          img.src = imageUrl;
          img.addEventListener('error', () => img.classList.add('hidden'));
          artWrapper.appendChild(img);
        } else {
          const placeholder = document.createElement('span');
          placeholder.className = 'playlist-placeholder';
          placeholder.textContent = 'â˜…';
          artWrapper.appendChild(placeholder);
        }

        const meta = document.createElement('div');
        meta.className = 'playlist-meta';

        const brand = document.createElement('span');
        brand.className = 'playlist-brand';
        const brandIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        brandIcon.setAttribute('viewBox', '0 0 24 24');
        brandIcon.setAttribute('aria-hidden', 'true');
        const brandPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        brandPath.setAttribute(
          'd',
          'M12 17.27 18.18 21l-1.64-7.03L22 9.24l-7.19-.62L12 2 9.19 8.62 2 9.24l5.46 4.73L5.82 21z'
        );
        brandIcon.appendChild(brandPath);
        brand.appendChild(brandIcon);
        const serviceLabel =
          favorite && favorite.service && favorite.service.name
            ? favorite.service.name
            : favorite && favorite.programType
              ? favorite.programType
              : 'Sonos Favorite';
        brand.appendChild(document.createTextNode(' ' + serviceLabel));

        const title = document.createElement('span');
        title.className = 'playlist-name';
        title.textContent = favorite.name || 'Unnamed Favorite';

        const status = document.createElement('span');
        status.className = 'playlist-status';
        status.textContent = SELECT_GROUP_MESSAGE;

        meta.appendChild(brand);
        meta.appendChild(title);
        meta.appendChild(status);

        const cardContent = document.createElement('div');
        cardContent.className = 'playlist-card-content';
        cardContent.appendChild(artWrapper);
        cardContent.appendChild(meta);

        const vibeSelector = document.createElement('div');
        vibeSelector.className = 'playlist-vibe-selector';
        const vibeLabel = document.createElement('label');
        vibeLabel.textContent = 'Vibe:';
        const vibeSelect = document.createElement('select');
        vibeSelect.dataset.favoriteId = favorite.id;
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = 'â€”';
        vibeSelect.appendChild(defaultOption);
        ['Down', 'Down/Mid', 'Mid'].forEach((vibe) => {
          const option = document.createElement('option');
          option.value = vibe;
          option.textContent = vibe;
          vibeSelect.appendChild(option);
        });
        vibeSelect.value = playlistVibes[favorite.id] || '';
        vibeSelect.addEventListener('change', (event) => {
          event.stopPropagation();
          setPlaylistVibe(favorite.id, event.target.value);
        });
        vibeSelector.appendChild(vibeLabel);
        vibeSelector.appendChild(vibeSelect);

        button.appendChild(cardContent);
        button.appendChild(vibeSelector);

        const entry = {
          favorite,
          button,
          statusEl: status,
          loading: false,
          statusMessage: SELECT_GROUP_MESSAGE,
          vibeSelect
        };

        button.addEventListener('click', (event) => {
          if (event.target === vibeSelect || event.target.closest('.playlist-vibe-selector')) {
            return;
          }
          playFavorite(entry);
        });

        return entry;
      }

      async function playFavorite(entry) {
        if (!currentHouseholdId) {
          showFeedback('Select a household first.', true);
          return;
        }

        setFavoriteLoading(entry, true);

        try {
          const groupResponse = await fetch(`/api/households/${encodeURIComponent(currentHouseholdId)}/create-all-group`, {
            method: 'POST'
          });

          if (!groupResponse.ok) {
            throw new Error('Failed to create group with all players');
          }

          const groupData = await groupResponse.json();
          const groupId = groupData.groupId;

          if (!groupId) {
            throw new Error('No group ID returned');
          }

          setActiveGroup(groupId, groupData.groupName || 'All Rooms');

          const commandPromise = sendCommand(
            `/api/groups/${encodeURIComponent(groupId)}/favorites/play`,
            {
              householdId: currentHouseholdId,
              favoriteId: entry.favorite.id,
              shuffle: true,
              repeat: true,
              crossfade: true
            },
            FAVORITE_SUCCESS_TOAST
          );

          const [success] = await Promise.all([commandPromise, delay(2000)]);
          setFavoriteLoading(entry, false);

          if (success) {
            // Store the group ID before loadPlayers might clear it
            const savedGroupId = groupId;
            await loadPlayers(currentHouseholdId);
            // Restore the group ID if it was cleared
            if (!getSelectedGroupId() && savedGroupId) {
              setActiveGroup(savedGroupId, groupData.groupName || 'All Rooms');
            }
            markActiveFavorite(entry.favorite.id);
            setTimeout(() => {
              updateCurrentlyPlaying();
            }, 1000);
          } else {
            updateFavoriteStatus(entry, FAVORITE_ERROR_MESSAGE);
          }
        } catch (error) {
          console.error('Failed to play favorite:', error);
          setFavoriteLoading(entry, false);
          updateFavoriteStatus(entry, FAVORITE_ERROR_MESSAGE);
          showFeedback('Failed to start playback. Please try again.', true);
        }

        evaluateFavoritesAvailability();
      }

      function setFavoriteLoading(entry, isLoading) {
        entry.loading = isLoading;
        entry.button.disabled = true;
        if (isLoading) {
          entry.button.classList.add('loading');
          updateFavoriteStatus(entry, LOADING_MESSAGE);
        } else {
          entry.button.classList.remove('loading');
        }
      }

      function updateFavoriteStatus(entry, message) {
        entry.statusMessage = message;
        entry.statusEl.textContent = message;
      }

      function evaluateFavoritesAvailability() {
        const enabled = isSonosConnected && Boolean(currentHouseholdId);

        favoritesRegistry.forEach((entry) => {
          if (entry.loading) {
            return;
          }

          entry.button.disabled = !enabled;
          entry.button.classList.toggle('disabled', !enabled);

          if (!enabled) {
            entry.button.classList.remove('active');
            updateFavoriteStatus(entry, 'Select a household to play');
          } else if (
            entry.statusMessage === SELECT_GROUP_MESSAGE ||
            entry.statusMessage === READY_MESSAGE ||
            entry.statusMessage === ''
          ) {
            updateFavoriteStatus(entry, READY_MESSAGE);
          }
        });

        if (enabled) {
          markActiveFavorite(currentActiveFavoriteId);
        }
      }

      function markActiveFavorite(favoriteId) {
        currentActiveFavoriteId = favoriteId || null;

        favoritesRegistry.forEach((entry) => {
          if (entry.loading) {
            return;
          }

          const isActive = Boolean(favoriteId) && entry.favorite.id === favoriteId;
          entry.button.classList.toggle('active', isActive);

          if (isActive) {
            updateFavoriteStatus(entry, FAVORITE_SUCCESS_MESSAGE);
          } else if (entry.statusMessage === FAVORITE_SUCCESS_MESSAGE) {
            updateFavoriteStatus(entry, READY_MESSAGE);
          }
        });
      }

      async function handlePlaybackAction(action) {
        const groupId = getSelectedGroupId();
        if (!groupId) {
          // Auto-grouping is handled on load, but if we still don't have a group, try to create one
          if (currentHouseholdId && latestPlayers.length > 0) {
            try {
              const groupResponse = await fetch(`/api/households/${encodeURIComponent(currentHouseholdId)}/create-all-group`, {
                method: 'POST'
              });
              if (groupResponse.ok) {
                const groupData = await groupResponse.json();
                if (groupData.groupId) {
                  setActiveGroup(groupData.groupId, groupData.groupName || 'All Rooms');
                  // Retry the action
                  handlePlaybackAction(action);
                  return;
                }
              }
            } catch (error) {
              console.error('Failed to auto-create group:', error);
            }
          }
          showFeedback('Unable to control playback. Please try again.', true);
          return;
        }

        const endpoints = {
          playpause: `/api/groups/${encodeURIComponent(groupId)}/playpause`,
          next: `/api/groups/${encodeURIComponent(groupId)}/next`,
          previous: `/api/groups/${encodeURIComponent(groupId)}/previous`
        };

        const endpoint = endpoints[action];
        if (!endpoint) {
          console.warn(`Unknown playback action requested: ${action}`);
          return;
        }

        await sendCommand(endpoint);
        setTimeout(() => updateCurrentlyPlaying(), 500);
      }

      async function setVolume(level) {
        const groupId = getSelectedGroupId();
        if (!groupId) {
          // Auto-grouping is handled on load, but if we still don't have a group, try to create one
          if (currentHouseholdId && latestPlayers.length > 0) {
            try {
              const groupResponse = await fetch(`/api/households/${encodeURIComponent(currentHouseholdId)}/create-all-group`, {
                method: 'POST'
              });
              if (groupResponse.ok) {
                const groupData = await groupResponse.json();
                if (groupData.groupId) {
                  setActiveGroup(groupData.groupId, groupData.groupName || 'All Rooms');
                  // Retry setting volume
                  setVolume(level);
                  return;
                }
              }
            } catch (error) {
              console.error('Failed to auto-create group:', error);
            }
          }
          showFeedback('Unable to change volume. Please try again.', true);
          return;
        }

        updateVolumeDisplay(level);
        const success = await sendCommand(
          `/api/groups/${encodeURIComponent(groupId)}/volume`,
          {
            volume: level
          },
          `Volume set to ${level}%.`
        );

        if (!success) {
          showFeedback('Unable to update volume. Please try again.', true);
        } else {
          setTimeout(() => updateCurrentlyPlaying(), 500);
        }
      }

      async function sendCommand(endpoint, body, successMessage = 'Command sent to Sonos.') {
        try {
          const response = await fetch(endpoint, {
            method: 'POST',
            headers: body ? { 'Content-Type': 'application/json' } : undefined,
            body: body ? JSON.stringify(body) : undefined
          });

          if (response.status === 401) {
            setAuthUI(false);
            showFeedback('Session expired. Please login again.', true);
            return false;
          }

          if (!response.ok) {
            throw new Error(await response.text());
          }

          if (successMessage) {
            showFeedback(successMessage);
          }
          return true;
        } catch (error) {
          console.error('Command failed:', error);
          showFeedback('Unable to reach Sonos. Please try again.', true);
          return false;
        }
      }

      function delay(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      function setVolumeControlAvailability(enabled) {
        volumeSlider.disabled = !enabled;
        if (!enabled) {
          volumeValue.textContent = '--%';
        } else {
          updateVolumeDisplay(volumeSlider.value);
        }
      }

      function updateVolumeDisplay(value) {
        volumeValue.textContent = `${Number(value)}%`;
      }

  setVolumeControlAvailability(false);
  evaluateFavoritesAvailability();
  applyAuthFeedback();
  showTab('control');

      async function loadPlayers(householdId) {
        if (!householdId) {
          latestPlayers = [];
          latestGroups = [];
          setVolumeControlAvailability(false);
          ensureActiveGroup([]);
          return;
        }

        try {
          clearTimeout(refreshTimer);
          refreshTimer = null;
          const response = await fetch(`/api/households/${encodeURIComponent(householdId)}/players`);

          if (response.status === 401) {
            setAuthUI(false);
            favoritesStatus.textContent = 'Login required to load favorites.';
            setVolumeControlAvailability(false);
            return;
          }

          if (!response.ok) {
            throw new Error(await response.text());
          }

          const data = await response.json();
          latestPlayers = Array.isArray(data.players) ? data.players : [];
          latestGroups = Array.isArray(data.groups) ? data.groups : [];

          ensureActiveGroup(latestPlayers);
          let activeGroupId = getSelectedGroupId();
          
          // Automatically create and select a group with all players if none is selected
          if (!activeGroupId && latestPlayers.length > 0 && currentHouseholdId) {
            try {
              const groupResponse = await fetch(`/api/households/${encodeURIComponent(currentHouseholdId)}/create-all-group`, {
                method: 'POST'
              });
              
              if (groupResponse.ok) {
                const groupData = await groupResponse.json();
                if (groupData.groupId) {
                  setActiveGroup(groupData.groupId, groupData.groupName || 'All Rooms');
                  activeGroupId = groupData.groupId;
                }
              }
            } catch (error) {
              console.error('Failed to auto-create group:', error);
            }
          }
          
          // Check for currently playing content after a short delay to ensure everything is loaded
          setTimeout(async () => {
            // Use the active group (either existing or newly created)
            if (activeGroupId) {
              updateCurrentlyPlayingRooms(activeGroupId);
              await updateCurrentlyPlaying();
              startPlaybackRefresh();
            } else if (latestGroups.length > 0) {
              // If still no group, check all groups to find which one is playing
              for (const group of latestGroups) {
                const groupId = group.id || group.groupId;
                if (!groupId) continue;
                
                try {
                  const response = await fetch(`/api/groups/${encodeURIComponent(groupId)}/playback/status`);
                  if (response.ok) {
                    const status = await response.json();
                    const playbackState = status.playbackState || status.state || 'STOPPED';
                    const isPlaying = playbackState === 'PLAYING' || playbackState === 'PLAYBACK_STATE_PLAYING';
                    const hasContent = !!(status.track || status.currentItem || status.item);
                    
                    if (isPlaying || hasContent || playbackState !== 'STOPPED') {
                      // Found a group with playback - set it as active
                      setActiveGroup(groupId, group.name || group.displayName || 'Group');
                      updateCurrentlyPlayingRooms(groupId);
                      await updateCurrentlyPlaying();
                      startPlaybackRefresh();
                      break;
                    }
                  }
                } catch (error) {
                  // Continue to next group
                  continue;
                }
              }
            }
          }, 500);
          
          setVolumeControlAvailability(Boolean(currentGroupId));
        } catch (error) {
          console.error('Failed to load players', error);
          setVolumeControlAvailability(false);
        }
      }

      function ensureActiveGroup(players) {
        if (currentGroupId && players.some((player) => player.groupId === currentGroupId)) {
          const active = players.find((player) => player.groupId === currentGroupId);
          if (active) {
            currentGroupName = active.groupName || active.name || currentGroupName;
          }
        } else {
          // Don't clear the group if panel is visible (we're in the middle of playback)
          if (panelShouldBeVisible && currentGroupId) {
            return; // Keep the existing group ID
          }
          const candidate = players.find((player) => player.groupId);
          if (candidate) {
            currentGroupId = candidate.groupId;
            currentGroupName = candidate.groupName || candidate.name || 'Group';
          } else {
            // Only clear if panel isn't visible
            if (!panelShouldBeVisible) {
              currentGroupId = null;
              currentGroupName = 'No group selected';
            }
          }
        }
        updateActiveGroupDisplay();
        evaluateFavoritesAvailability();
      }


      async function setPlayerVolume(playerId, level) {
        if (!playerId) {
          return;
        }

        const numericLevel = Number(level);

        try {
          const postResponse = await fetch(`/api/players/${encodeURIComponent(playerId)}/volume`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ level: numericLevel })
          });

          if (!postResponse.ok) {
            throw new Error(await postResponse.text());
          }

          const getResponse = await fetch(`/api/players/${encodeURIComponent(playerId)}/volume`);
          if (getResponse.ok) {
            const payload = await getResponse.json();
            const updatedLevel = Number(
              payload.volume ?? payload?.volume?.volume ?? payload.level ?? numericLevel
            );
            
            const roomRow = document.querySelector(`[data-player-id="${playerId}"]`);
            if (roomRow) {
              const slider = roomRow.querySelector('.currently-playing-room-slider');
              const value = roomRow.querySelector('.currently-playing-room-value');
              if (slider) slider.value = updatedLevel;
              if (value) value.textContent = updatedLevel;
            }
          }

          if (currentHouseholdId) {
            setTimeout(() => loadPlayers(currentHouseholdId), 500);
          }
        } catch (error) {
          console.error('Failed to update player volume:', error);
          showFeedback('Unable to update room volume. Please try again.', true);
        }
      }

      async function refreshUI() {
        await loadHouseholds();
      }

      setVolumeControlAvailability(false);
      evaluateFavoritesAvailability();
      updateActiveGroupDisplay();

      async function updateCurrentlyPlaying() {
        let groupId = getSelectedGroupId();
        
        // If no group is selected but we have groups, try the first one
        if (!groupId && latestGroups.length > 0 && isSonosConnected) {
          const firstGroup = latestGroups.find(g => g.id || g.groupId);
          if (firstGroup) {
            groupId = firstGroup.id || firstGroup.groupId;
            // Set it as active so refresh continues
            if (groupId && !currentGroupId) {
              setActiveGroup(groupId, firstGroup.name || firstGroup.displayName || 'Group');
            }
          }
        }
        
        if (!groupId || !isSonosConnected) {
          // Only hide if panel wasn't previously visible (don't hide during transitions)
          if (!panelShouldBeVisible) {
            clearTimeout(hidePanelTimeout);
            currentlyPlayingPanel.classList.remove('visible');
            document.body.classList.remove('has-playing');
          }
          return;
        }

        try {
          const response = await fetch(`/api/groups/${encodeURIComponent(groupId)}/playback/status`);
          if (!response.ok) {
            throw new Error('Failed to fetch playback status');
          }

          const status = await response.json();
          currentPlaybackState = status;

          const playbackState = status.playbackState || status.state || status.playback?.state || 'STOPPED';
          const isPlaying = playbackState === 'PLAYING' || playbackState === 'PLAYBACK_STATE_PLAYING';
          
          const item = status.currentItem || status.item || status.playback?.currentItem || null;
          const track = item?.track || item?.container?.metadata || status.track || null;
          
          // Determine if we should show the panel - be more permissive
          const hasContent = !!(track || item);
          const isActive = isPlaying || playbackState !== 'STOPPED';
          
          // If we have content OR are playing, show the panel
          // If panel was visible, keep it visible (don't hide during transitions)
          if (hasContent || isActive || panelShouldBeVisible) {
            panelShouldBeVisible = true;
            clearTimeout(hidePanelTimeout);
            
            const groupInfo = latestGroups.find((g) => g.id === groupId || g.groupId === groupId);
            const groupName = groupInfo?.name || currentGroupName || 'Unknown Group';

            let playlistName = null;
            const activeFavoriteId = status.activeFavoriteId || currentActiveFavoriteId;
            if (activeFavoriteId) {
              const favoriteEntry = favoritesRegistry.get(activeFavoriteId);
              if (favoriteEntry && favoriteEntry.favorite) {
                playlistName = favoriteEntry.favorite.name || null;
              }
            }

            const title = track?.name || track?.title || item?.name || (isPlaying ? 'Loading...' : 'Unknown Track');
            
            let artist = '';
            if (track?.artist) {
              artist = typeof track.artist === 'string' ? track.artist : track.artist?.name || track.artist?.value || '';
            } else if (track?.albumArtist) {
              artist = typeof track.albumArtist === 'string' ? track.albumArtist : track.albumArtist?.name || track.albumArtist?.value || '';
            } else if (track?.creator) {
              artist = typeof track.creator === 'string' ? track.creator : track.creator?.name || track.creator?.value || '';
            }
            
            let album = '';
            if (track?.album) {
              album = typeof track.album === 'string' ? track.album : track.album?.name || track.album?.value || '';
            } else if (track?.albumName) {
              album = typeof track.albumName === 'string' ? track.albumName : track.albumName?.name || track.albumName?.value || '';
            }
            
            let imageUrl = null;
            if (track?.imageUrl) {
              imageUrl = typeof track.imageUrl === 'string' ? track.imageUrl : track.imageUrl?.url || track.imageUrl?.value || null;
            } else if (track?.albumArtUri) {
              imageUrl = typeof track.albumArtUri === 'string' ? track.albumArtUri : track.albumArtUri?.url || track.albumArtUri?.value || null;
            } else if (track?.albumArtURL) {
              imageUrl = typeof track.albumArtURL === 'string' ? track.albumArtURL : track.albumArtURL?.url || track.albumArtURL?.value || null;
            } else if (item?.imageUrl) {
              imageUrl = typeof item.imageUrl === 'string' ? item.imageUrl : item.imageUrl?.url || item.imageUrl?.value || null;
            } else if (item?.albumArtUri) {
              imageUrl = typeof item.albumArtUri === 'string' ? item.albumArtUri : item.albumArtUri?.url || item.albumArtUri?.value || null;
            }
            
            if (imageUrl && !imageUrl.startsWith('http')) {
              imageUrl = null;
            }

            currentlyPlayingTitle.textContent = title;
            currentlyPlayingArtist.innerHTML = '';
            if (artist) {
              const artistSpan = document.createElement('span');
              artistSpan.textContent = artist;
              currentlyPlayingArtist.appendChild(artistSpan);
            }
            if (album && artist) {
              const separator = document.createTextNode(' â€¢ ');
              currentlyPlayingArtist.appendChild(separator);
              const albumSpan = document.createElement('span');
              albumSpan.textContent = album;
              currentlyPlayingArtist.appendChild(albumSpan);
            }
            if (!artist && !album) {
              currentlyPlayingArtist.innerHTML = '<span>Sonos</span>';
            }

            currentlyPlayingLocation.innerHTML = `<span>${playlistName || groupName}</span>`;

            let finalImageUrl = null;
            if (imageUrl) {
              console.log('[CoverArt] Original imageUrl:', imageUrl);
              // Proxy all external images through our server to avoid CORS and mixed content issues
              if (imageUrl.startsWith('http://') || imageUrl.startsWith('https://')) {
                finalImageUrl = `/api/image-proxy?url=${encodeURIComponent(imageUrl)}`;
                console.log('[CoverArt] Proxying image through server:', finalImageUrl);
              } else {
                finalImageUrl = imageUrl;
                console.log('[CoverArt] Using image URL directly (not http/https):', finalImageUrl);
              }
            } else {
              console.log('[CoverArt] No imageUrl found in track/item data');
            }

            if (finalImageUrl !== currentImageUrl) {
              console.log('[CoverArt] Image URL changed, updating:', { old: currentImageUrl, new: finalImageUrl });
              currentImageUrl = finalImageUrl;
              if (finalImageUrl) {
                const img = document.createElement('img');
                img.src = finalImageUrl;
                img.alt = title;
                img.loading = 'lazy';
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.objectFit = 'cover';
                img.onerror = (e) => {
                  console.error('[CoverArt] Image load failed:', {
                    url: finalImageUrl,
                    originalUrl: imageUrl,
                    error: e,
                    imgSrc: img.src,
                    imgComplete: img.complete,
                    imgNaturalWidth: img.naturalWidth,
                    imgNaturalHeight: img.naturalHeight
                  });
                  currentlyPlayingArt.innerHTML = '<span class="currently-playing-art-placeholder">â™ª</span>';
                  currentImageUrl = null;
                };
                img.onload = () => {
                  console.log('[CoverArt] Image loaded successfully:', {
                    url: finalImageUrl,
                    originalUrl: imageUrl,
                    width: img.naturalWidth,
                    height: img.naturalHeight
                  });
                };
                console.log('[CoverArt] Setting image src and appending to DOM');
                currentlyPlayingArt.innerHTML = '';
                currentlyPlayingArt.appendChild(img);
              } else {
                console.log('[CoverArt] No finalImageUrl, showing placeholder');
                currentlyPlayingArt.innerHTML = '<span class="currently-playing-art-placeholder">â™ª</span>';
              }
            } else {
              console.log('[CoverArt] Image URL unchanged, skipping update');
            }

            const playerCount = latestPlayers.filter((p) => p.groupId === groupId).length;
            if (playerCount > 1) {
              currentlyPlayingGroupIndicator.style.display = 'grid';
              currentlyPlayingGroupCount.textContent = playerCount;
              currentlyPlayingGroupCount.style.display = 'grid';
            } else {
              currentlyPlayingGroupIndicator.style.display = 'none';
              currentlyPlayingGroupCount.style.display = 'none';
            }

            const playIcon = isPlaying
              ? '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16" rx="1"/><rect x="14" y="4" width="4" height="16" rx="1"/></svg>'
              : '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>';
            
            if (currentlyPlayingPlayBtn.innerHTML !== playIcon) {
              currentlyPlayingPlayBtn.innerHTML = playIcon;
            }
            
            currentlyPlayingPlayBtn.classList.toggle('playing', isPlaying);

            updateCurrentlyPlayingRooms(groupId);

            currentlyPlayingPanel.classList.add('visible');
            document.body.classList.add('has-playing');
          } else {
            // Only hide if we're truly stopped - use a delay to prevent flickering
            if (playbackState === 'STOPPED' && !isPlaying) {
              clearTimeout(hidePanelTimeout);
              hidePanelTimeout = setTimeout(() => {
                if (!panelShouldBeVisible) {
                  currentlyPlayingPanel.classList.remove('visible');
                  document.body.classList.remove('has-playing');
                  currentImageUrl = null;
                }
              }, 2000); // Wait 2 seconds before hiding
            }
          }
        } catch (error) {
          console.error('Failed to update currently playing:', error);
          currentlyPlayingPanel.classList.remove('visible');
          document.body.classList.remove('has-playing');
        }
      }

      function updateCurrentlyPlayingRooms(groupId) {
        if (!groupId || !latestPlayers.length) {
          currentlyPlayingRoomsList.innerHTML = '';
          return;
        }

        // Since we're auto-grouping all players, show all players
        // The groupId format is "RINCON_XXX:PORT" where RINCON_XXX is the coordinator
        // We'll show all players since they're all in the same auto-created group
        const groupPlayers = latestPlayers;
        
        console.log('[CurrentlyPlaying] Showing all players for group:', {
          groupId,
          playersCount: groupPlayers.length,
          players: groupPlayers.map(p => ({ id: p.id, name: p.name }))
        });
        
        currentlyPlayingRoomsList.innerHTML = '';

        groupPlayers.forEach((player) => {
          const roomRow = document.createElement('div');
          roomRow.className = 'currently-playing-room-volume';
          roomRow.dataset.playerId = player.id;

          const name = document.createElement('span');
          name.className = 'currently-playing-room-name';
          name.textContent = player.name || player.id || 'Room';

          const slider = document.createElement('input');
          slider.type = 'range';
          slider.className = 'currently-playing-room-slider';
          slider.min = '0';
          slider.max = '100';
          slider.value = Number.isFinite(Number(player.volume)) ? Number(player.volume) : 0;

          const value = document.createElement('span');
          value.className = 'currently-playing-room-value';
          value.textContent = `${slider.value}`;

          slider.addEventListener('input', (e) => {
            value.textContent = e.target.value;
          });

          slider.addEventListener('change', async (e) => {
            e.stopPropagation();
            const playerId = roomRow.dataset.playerId;
            if (playerId) {
              await setPlayerVolume(playerId, Number(e.target.value));
            }
          });

          slider.addEventListener('pointerdown', (e) => e.stopPropagation());
          slider.addEventListener('mousedown', (e) => e.stopPropagation());

          roomRow.appendChild(name);
          roomRow.appendChild(slider);
          roomRow.appendChild(value);
          currentlyPlayingRoomsList.appendChild(roomRow);
        });
        
      }

      function startPlaybackRefresh() {
        clearInterval(playbackRefreshTimer);
        playbackRefreshTimer = setInterval(() => {
          if (isSonosConnected && getSelectedGroupId()) {
            updateCurrentlyPlaying();
          }
        }, 3000);
        updateCurrentlyPlaying();
      }
      
      function stopPlaybackRefresh() {
        clearInterval(playbackRefreshTimer);
        playbackRefreshTimer = null;
      }


      // Use event delegation on the panel itself - simpler and more reliable
      currentlyPlayingPanel.addEventListener('click', (e) => {
        // Don't toggle if clicking on interactive elements
        const playBtn = e.target.closest('.currently-playing-play-btn');
        const roomVolume = e.target.closest('.currently-playing-room-volume');
        const roomSlider = e.target.closest('.currently-playing-room-slider');
        const rangeInput = e.target.closest('input[type="range"]');
        
        if (playBtn || roomVolume || roomSlider || rangeInput) {
          return;
        }
        
        // Toggle expanded state
        currentlyPlayingPanel.classList.toggle('expanded');
        
        // Update rooms when expanding (in case they weren't loaded yet)
        if (currentlyPlayingPanel.classList.contains('expanded')) {
          const groupId = getSelectedGroupId();
          if (groupId) {
            updateCurrentlyPlayingRooms(groupId);
          }
        }
      });

      // Close panel when clicking outside of it
      document.addEventListener('click', (e) => {
        if (!currentlyPlayingPanel.classList.contains('visible')) {
          return;
        }
        
        // If click is outside the panel, close it
        if (!currentlyPlayingPanel.contains(e.target)) {
          currentlyPlayingPanel.classList.remove('expanded');
        }
      });

      // Close panel when scrolling
      let scrollTimeout = null;
      document.addEventListener('scroll', () => {
        if (!currentlyPlayingPanel.classList.contains('visible') || !currentlyPlayingPanel.classList.contains('expanded')) {
          return;
        }
        
        // Debounce scroll events to avoid closing too frequently
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(() => {
          if (currentlyPlayingPanel.classList.contains('expanded')) {
            currentlyPlayingPanel.classList.remove('expanded');
          }
        }, 100);
      }, { passive: true });

      // Close panel on touchmove (mobile scrolling)
      document.addEventListener('touchmove', () => {
        if (!currentlyPlayingPanel.classList.contains('visible') || !currentlyPlayingPanel.classList.contains('expanded')) {
          return;
        }
        
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(() => {
          if (currentlyPlayingPanel.classList.contains('expanded')) {
            currentlyPlayingPanel.classList.remove('expanded');
          }
        }, 100);
      }, { passive: true });

      currentlyPlayingPlayBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const groupId = getSelectedGroupId();
        if (!groupId) {
          return;
        }
        
        const wasPlaying = currentlyPlayingPlayBtn.classList.contains('playing');
        currentlyPlayingPlayBtn.disabled = true;
        
        try {
          await handlePlaybackAction('playpause');
          setTimeout(() => {
            updateCurrentlyPlaying();
            currentlyPlayingPlayBtn.disabled = false;
          }, 600);
        } catch (error) {
          console.error('Playback toggle failed:', error);
          currentlyPlayingPlayBtn.disabled = false;
          setTimeout(() => updateCurrentlyPlaying(), 500);
        }
      });

      function setActiveGroup(groupId, name, { refreshFavorites = false } = {}) {
        currentGroupId = groupId || null;
        currentGroupName = currentGroupId ? name || currentGroupName || 'Group' : 'No group selected';
        updateActiveGroupDisplay();
        evaluateFavoritesAvailability();
        if (refreshFavorites && currentHouseholdId) {
          loadFavorites(currentHouseholdId).catch((error) => {
            console.error('Failed to refresh favorites', error);
          });
        }
        if (groupId) {
          startPlaybackRefresh();
        } else {
          stopPlaybackRefresh();
        }
      }

      window.addEventListener('load', () => {
        applyAuthFeedback();
        checkAuthAndInit();
      });
    </script>


  </body>
</html>
