<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Sonos Controller</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3ClinearGradient id='wood' x1='0' y1='0' x2='0' y2='100'%3E%3Cstop offset='0' stop-color='%23d4a574'/%3E%3Cstop offset='1' stop-color='%23c8956a'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect fill='url(%23wood)' width='100' height='100'/%3E%3Crect fill='%23a67c52' x='0' y='0' width='100' height='15'/%3E%3Crect fill='%23a67c52' x='0' y='20' width='15' height='60'/%3E%3Crect fill='%23a67c52' x='85' y='20' width='15' height='60'/%3E%3Crect fill='%238b6f47' x='20' y='40' width='60' height='15'/%3E%3Crect fill='%238b6f47' x='20' y='60' width='60' height='15'/%3E%3Crect fill='%23404040' x='70' y='70' width='20' height='20' rx='2'/%3E%3Ccircle fill='%23ffd700' cx='85' cy='15' r='6'/%3E%3Cpath fill='%23ffffff' opacity='0.7' d='M25 25 Q35 15 45 25 T65 25'/%3E%3Cpath fill='%23ffffff' opacity='0.5' d='M20 30 Q30 20 40 30 T60 30'/%3E%3C/svg%3E" />
    
    <!-- Apple Touch Icon (for iOS Home Screen) -->
    <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3ClinearGradient id='wood' x1='0' y1='0' x2='0' y2='100'%3E%3Cstop offset='0' stop-color='%23d4a574'/%3E%3Cstop offset='1' stop-color='%23c8956a'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect fill='url(%23wood)' width='100' height='100'/%3E%3Crect fill='%23a67c52' x='0' y='0' width='100' height='15'/%3E%3Crect fill='%23a67c52' x='0' y='20' width='15' height='60'/%3E%3Crect fill='%23a67c52' x='85' y='20' width='15' height='60'/%3E%3Crect fill='%238b6f47' x='20' y='40' width='60' height='15'/%3E%3Crect fill='%238b6f47' x='20' y='60' width='60' height='15'/%3E%3Crect fill='%23404040' x='70' y='70' width='20' height='20' rx='2'/%3E%3Ccircle fill='%23ffd700' cx='85' cy='15' r='6'/%3E%3Cpath fill='%23ffffff' opacity='0.7' d='M25 25 Q35 15 45 25 T65 25'/%3E%3Cpath fill='%23ffffff' opacity='0.5' d='M20 30 Q30 20 40 30 T60 30'/%3E%3C/svg%3E" />
    
    <!-- Open Graph / Social Sharing -->
    <meta property="og:image" content="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3ClinearGradient id='wood' x1='0' y1='0' x2='0' y2='100'%3E%3Cstop offset='0' stop-color='%23d4a574'/%3E%3Cstop offset='1' stop-color='%23c8956a'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect fill='url(%23wood)' width='100' height='100'/%3E%3Crect fill='%23a67c52' x='0' y='0' width='100' height='15'/%3E%3Crect fill='%23a67c52' x='0' y='20' width='15' height='60'/%3E%3Crect fill='%23a67c52' x='85' y='20' width='15' height='60'/%3E%3Crect fill='%238b6f47' x='20' y='40' width='60' height='15'/%3E%3Crect fill='%238b6f47' x='20' y='60' width='60' height='15'/%3E%3Crect fill='%23404040' x='70' y='70' width='20' height='20' rx='2'/%3E%3Ccircle fill='%23ffd700' cx='85' cy='15' r='6'/%3E%3Cpath fill='%23ffffff' opacity='0.7' d='M25 25 Q35 15 45 25 T65 25'/%3E%3Cpath fill='%23ffffff' opacity='0.5' d='M20 30 Q30 20 40 30 T60 30'/%3E%3C/svg%3E" />
    <meta property="og:title" content="Sonos Controller" />
    <meta property="og:type" content="website" />
    
    <!-- Web App Manifest -->
    <link rel="manifest" href="/manifest.json" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="apple-mobile-web-app-title" content="Sonos Controller" />
    <style>
      :root {
        color-scheme: light dark;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
        --bg-primary: #ffffff;
        --bg-secondary: #f8f9fa;
        --bg-tertiary: #f1f3f5;
        --text-primary: #1a1a1a;
        --text-secondary: #6b7280;
        --text-tertiary: #9ca3af;
        --border-color: #e5e7eb;
        --accent: #000000;
        --accent-hover: #1a1a1a;
        --success: #10b981;
        --error: #ef4444;
        --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      }

      @media (prefers-color-scheme: dark) {
        :root {
          --bg-primary: #0a0a0a;
          --bg-secondary: #141414;
          --bg-tertiary: #1a1a1a;
          --text-primary: #fafafa;
          --text-secondary: #a1a1aa;
          --text-tertiary: #71717a;
          --border-color: #27272a;
          --accent: #ffffff;
          --accent-hover: #f4f4f5;
        }
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        background: var(--bg-secondary);
        color: var(--text-primary);
        min-height: 100vh;
        display: flex;
        align-items: stretch;
        justify-content: center;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .container {
        width: min(480px, 100vw);
        padding: 20px;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        gap: 24px;
      }

      .header-wrapper {
        position: sticky;
        top: 0;
        z-index: 50;
        background: var(--bg-secondary);
        margin: -20px -20px 0 -20px;
        padding: 12px 20px;
        border-bottom: 1px solid var(--border-color);
        box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
      }

      .header-container {
        display: grid;
        grid-template-columns: 40px 1fr 40px;
        align-items: center;
        gap: 12px;
      }

      .hamburger-menu-btn {
        width: 40px;
        height: 40px;
        border: none;
        background: transparent;
        color: var(--text-primary);
        cursor: pointer;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        gap: 5px;
        padding: 8px;
        border-radius: 8px;
        transition: background 0.2s ease;
      }

      .hamburger-menu-btn:hover {
        background: var(--bg-tertiary);
      }

      .hamburger-menu-btn span {
        display: block;
        width: 20px;
        height: 2px;
        background: currentColor;
        border-radius: 1px;
        transition: all 0.3s ease;
      }

      h1 {
        font-size: 1.5rem;
        font-weight: 600;
        margin: 0;
        grid-column: 2;
        text-align: center;
        letter-spacing: -0.02em;
      }

      .household-title {
        font-size: 1.125rem;
        font-weight: 600;
        margin: 8px 0;
        text-align: center;
        color: var(--text-primary);
        min-height: 1.5rem;
      }

      p.status {
        margin: 0;
        text-align: center;
        font-weight: 500;
        font-size: 0.875rem;
      }

      p.status.connected {
        color: var(--success);
      }

      p.status.disconnected {
        color: var(--error);
      }

      .feedback {
        min-height: 1.25rem;
        text-align: center;
        font-size: 0.875rem;
        color: var(--text-secondary);
      }

      .feedback.error {
        color: var(--error);
      }

      section {
        background: var(--bg-primary);
        border-radius: 16px;
        padding: 20px;
        border: 1px solid var(--border-color);
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      label {
        font-size: 0.8125rem;
        font-weight: 500;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.05em;
        margin-bottom: 8px;
        display: block;
      }

      select {
        width: 100%;
        padding: 12px 16px;
        border-radius: 10px;
        border: 1px solid var(--border-color);
        background: var(--bg-primary);
        color: var(--text-primary);
        font-size: 0.9375rem;
        font-weight: 500;
        appearance: none;
        cursor: pointer;
        transition: border-color 0.2s ease;
      }

      select:focus {
        outline: none;
        border-color: var(--accent);
      }

      select:hover {
        border-color: var(--text-tertiary);
      }

      button {
        border: none;
        border-radius: 10px;
        padding: 12px 20px;
        font-size: 0.9375rem;
        font-weight: 500;
        background: var(--accent);
        color: var(--bg-primary);
        cursor: pointer;
        transition: all 0.2s ease;
      }

      button:hover:not(:disabled) {
        background: var(--accent-hover);
      }


      button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }

      button.secondary {
        background: var(--bg-tertiary);
        color: var(--text-primary);
      }

      button.secondary:hover:not(:disabled) {
        background: var(--border-color);
      }

      .controls,
      .volume {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .control-buttons {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
      }

      .control-buttons button {
        padding: 14px 12px;
        font-size: 0.875rem;
      }

      .control-buttons button:first-child {
        grid-column: 1 / -1;
        padding: 16px;
        font-size: 0.9375rem;
      }

      .slider-row {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      input[type='range'] {
        width: 100%;
        height: 6px;
        accent-color: var(--accent);
        cursor: pointer;
      }

      .volume-value {
        min-width: 3.5rem;
        text-align: right;
        font-variant-numeric: tabular-nums;
        font-size: 0.875rem;
        font-weight: 500;
        color: var(--text-secondary);
      }

      .group-chip {
        display: inline-flex;
        align-items: center;
        padding: 10px 16px;
        border-radius: 10px;
        border: 1px solid var(--border-color);
        background: var(--bg-tertiary);
        font-size: 0.875rem;
        font-weight: 500;
        min-width: 140px;
        justify-content: center;
        color: var(--text-primary);
      }

      .settings-row {
        display: grid;
        grid-template-columns: 1fr auto auto;
        gap: 12px;
        align-items: center;
        margin-bottom: 12px;
        background: var(--bg-secondary);
        padding: 16px;
        border-radius: 12px;
        border: 1px solid var(--border-color);
      }

      .favorites {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .vibe-filters {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
        margin-bottom: 4px;
      }

      .vibe-filter-btn {
        padding: 8px 16px;
        border-radius: 8px;
        border: 1px solid var(--border-color);
        background: var(--bg-secondary);
        color: var(--text-secondary);
        font-size: 0.8125rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .vibe-filter-btn:hover {
        background: var(--bg-tertiary);
        color: var(--text-primary);
      }

      .vibe-filter-btn.active {
        background: var(--accent);
        color: var(--bg-primary);
        border-color: var(--accent);
      }

      .favorites-grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
      }

      .favorites-status {
        font-size: 0.875rem;
        color: var(--text-secondary);
      }

      .section-title {
        font-size: 0.9375rem;
        font-weight: 600;
        letter-spacing: -0.01em;
        color: var(--text-primary);
      }

      .playlist-card {
        display: flex;
        flex-direction: column;
        gap: 14px;
        padding: 16px;
        border-radius: 12px;
        border: 1px solid var(--border-color);
        background: var(--bg-primary);
        color: inherit;
        text-align: left;
        box-shadow: var(--shadow-sm);
        transition: all 0.2s ease;
        cursor: pointer;
      }

      .playlist-card:hover:not(:disabled) {
        box-shadow: var(--shadow-md);
        border-color: var(--text-tertiary);
      }

      .playlist-card-content {
        display: flex;
        align-items: center;
        gap: 14px;
      }


      .playlist-card.disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .playlist-card.loading {
        cursor: progress;
      }

      .playlist-card.active {
        border-color: var(--accent);
        box-shadow: var(--shadow-md);
      }

      .playlist-art-wrapper {
        width: 60px;
        height: 60px;
        border-radius: 10px;
        overflow: hidden;
        flex-shrink: 0;
        background: var(--bg-tertiary);
        display: grid;
        place-items: center;
        box-shadow: var(--shadow-sm);
      }

      .playlist-art {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .playlist-meta {
        display: flex;
        flex-direction: column;
        gap: 6px;
        align-items: flex-start;
        flex: 1;
        min-width: 0;
      }

      .playlist-placeholder {
        font-size: 1.5rem;
        color: var(--text-tertiary);
      }

      .playlist-brand {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--text-tertiary);
        font-weight: 500;
      }

      .playlist-brand svg {
        width: 14px;
        height: 14px;
        fill: currentColor;
      }

      .playlist-name {
        font-size: 0.9375rem;
        font-weight: 500;
        color: var(--text-primary);
        line-height: 1.4;
        overflow: hidden;
        text-overflow: ellipsis;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        line-clamp: 2;
        -webkit-box-orient: vertical;
      }

      .playlist-status {
        font-size: 0.8125rem;
        color: var(--text-secondary);
      }

      .playlist-vibe-selector {
        display: flex;
        align-items: center;
        gap: 10px;
        padding-top: 12px;
        border-top: 1px solid var(--border-color);
      }

      .playlist-vibe-selector label {
        font-size: 0.8125rem;
        font-weight: 500;
        color: var(--text-secondary);
        white-space: nowrap;
      }

      .playlist-vibe-selector select {
        flex: 1;
        padding: 8px 12px;
        border-radius: 8px;
        border: 1px solid var(--border-color);
        background: var(--bg-secondary);
        color: var(--text-primary);
        font-size: 0.8125rem;
        font-weight: 500;
        appearance: none;
        cursor: pointer;
        transition: border-color 0.2s ease;
      }

      .playlist-vibe-selector select:focus {
        outline: none;
        border-color: var(--accent);
      }

      .playlist-vibe-selector select:hover {
        border-color: var(--text-tertiary);
      }

      .settings-actions {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-top: 8px;
        flex-wrap: wrap;
      }

      .settings-status {
        min-height: 1.2rem;
        font-size: 0.875rem;
        color: var(--text-secondary);
      }

      .rooms {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .room-card {
        display: flex;
        flex-direction: column;
        gap: 14px;
        padding: 16px;
        border-radius: 12px;
        background: var(--bg-primary);
        border: 1px solid var(--border-color);
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .room-card:hover {
        border-color: var(--text-tertiary);
        box-shadow: var(--shadow-sm);
      }

      .room-card.active {
        border-color: var(--accent);
        box-shadow: var(--shadow-md);
      }

      .room-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      .room-name {
        font-weight: 500;
        font-size: 0.9375rem;
        color: var(--text-primary);
      }

      .room-group-label {
        font-size: 0.8125rem;
        color: var(--text-secondary);
        font-weight: 400;
      }

      .room-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .room-actions button {
        font-size: 0.8125rem;
        padding: 8px 14px;
        border-radius: 8px;
        background: var(--bg-tertiary);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
      }

      .room-actions button:hover:not(:disabled) {
        background: var(--border-color);
      }

      .volume-row {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .volume-row span {
        font-size: 0.875rem;
        min-width: 56px;
        font-weight: 500;
        color: var(--text-secondary);
      }

      .hidden {
        display: none !important;
      }

      #auth-bar {
        display: flex;
        gap: 8px;
        margin-bottom: 8px;
      }

      #auth-bar button {
        flex: 1;
      }

      .select-group {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .currently-playing {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: var(--bg-primary);
        border-top: 1px solid var(--border-color);
        padding: 12px 16px 24px 16px;
        display: none;
        z-index: 100;
        box-shadow: 0 -4px 6px -1px rgba(0, 0, 0, 0.1);
        max-height: 100vh;
        overflow-y: auto;
        transition: transform 0.3s ease-out;
        transform: translateY(0);
      }

      .currently-playing.visible {
        display: block;
      }

      .currently-playing.expanded {
        transform: translateY(0);
      }

      .currently-playing-content {
        max-width: 480px;
        margin: 0 auto;
        display: flex;
        align-items: center;
        gap: 12px;
        cursor: pointer;
      }

      .currently-playing-content:not(:has(.currently-playing-play-btn:hover)):hover {
        opacity: 0.9;
      }

      .currently-playing-art {
        width: 56px;
        height: 56px;
        border-radius: 8px;
        overflow: hidden;
        flex-shrink: 0;
        background: var(--bg-tertiary);
        display: grid;
        place-items: center;
      }

      .currently-playing-art img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .currently-playing-art-placeholder {
        font-size: 1.25rem;
        color: var(--text-tertiary);
      }

      .currently-playing-info {
        flex: 1;
        min-width: 0;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .currently-playing-location {
        font-size: 0.75rem;
        color: var(--text-secondary);
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 4px;
      }

      .currently-playing-title {
        font-size: 0.9375rem;
        font-weight: 600;
        color: var(--text-primary);
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .currently-playing-artist {
        font-size: 0.8125rem;
        color: var(--text-secondary);
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .currently-playing-controls {
        display: flex;
        align-items: center;
        gap: 12px;
        flex-shrink: 0;
      }

      .currently-playing-group-indicator {
        width: 32px;
        height: 32px;
        border-radius: 6px;
        background: var(--bg-tertiary);
        border: 1px solid var(--border-color);
        display: grid;
        place-items: center;
        font-size: 0.75rem;
        font-weight: 600;
        color: var(--text-primary);
        position: relative;
      }

      .currently-playing-group-count {
        position: absolute;
        top: -4px;
        right: -4px;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: var(--accent);
        color: var(--bg-primary);
        font-size: 0.625rem;
        font-weight: 600;
        display: grid;
        place-items: center;
      }

      .currently-playing-play-btn {
        width: 56px;
        height: 56px;
        border-radius: 50%;
        background: var(--bg-primary);
        border: 2px solid var(--border-color);
        color: var(--text-primary);
        display: grid;
        place-items: center;
        cursor: pointer;
        transition: all 0.2s ease;
        flex-shrink: 0;
        box-shadow: var(--shadow-sm);
        padding: 0;
      }

      .currently-playing-play-btn:hover {
        background: var(--bg-tertiary);
        border-color: var(--accent);
        transform: scale(1.05);
        box-shadow: var(--shadow-md);
      }


      .currently-playing-play-btn svg {
        width: 24px;
        height: 24px;
        display: block;
      }

      .currently-playing-play-btn .play-icon {
        fill: currentColor;
      }

      .currently-playing-play-btn .pause-icon {
        display: none;
        stroke: currentColor;
        stroke-width: 2;
        stroke-linecap: round;
        stroke-linejoin: round;
      }

      .currently-playing-play-btn.playing .play-icon {
        display: none;
      }

      .currently-playing-play-btn.playing .pause-icon {
        display: block;
      }

      /* Hide play button when expanded */
      .currently-playing.expanded .currently-playing-play-btn {
        display: none;
      }

      .currently-playing-play-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      .currently-playing-volume {
        flex-direction: column;
        gap: 12px;
        margin-top: 0;
        padding: 0 16px;
        padding-top: 0;
        padding-bottom: 0;
        border-top: none;
        max-height: 0;
        overflow: hidden;
        opacity: 0;
        transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1), 
                    padding 0.4s cubic-bezier(0.4, 0, 0.2, 1), 
                    margin 0.4s cubic-bezier(0.4, 0, 0.2, 1), 
                    opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                    border-top 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .currently-playing.expanded .currently-playing-volume {
        margin-top: 12px;
        padding-top: 16px;
        padding-bottom: 8px;
        border-top: 1px solid var(--border-color);
        max-height: 500px;
        opacity: 1;
      }

      .currently-playing-room-volume {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px 0;
        min-height: 44px;
        border-top: 1px solid var(--border-color);
      }

      .currently-playing-room-volume:first-of-type {
        border-top: none;
      }

      .currently-playing-room-name {
        min-width: 100px;
        font-size: 0.875rem;
        font-weight: 500;
        color: var(--text-primary);
      }

      .currently-playing-room-slider {
        flex: 1;
        height: 4px;
        accent-color: var(--accent);
        cursor: pointer;
      }

      .currently-playing-room-value {
        min-width: 2.5rem;
        text-align: right;
        font-size: 0.8125rem;
        font-weight: 500;
        color: var(--text-secondary);
        font-variant-numeric: tabular-nums;
      }

      body {
        padding-bottom: 0;
      }

      body.has-playing {
        padding-bottom: 100px;
      }

      body.menu-open {
        overflow: hidden;
      }

      .menu-backdrop {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 998;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease;
      }

      .menu-backdrop.visible {
        opacity: 1;
        visibility: visible;
      }

      .menu-panel {
        position: fixed;
        top: 0;
        left: 0;
        bottom: 0;
        width: min(280px, 80vw);
        max-width: 280px;
        background: var(--bg-primary);
        border-right: 1px solid var(--border-color);
        z-index: 999;
        transform: translateX(-100%);
        transition: transform 0.3s ease;
        display: flex;
        flex-direction: column;
        box-shadow: var(--shadow-lg);
      }

      .menu-panel.open {
        transform: translateX(0);
      }

      .menu-header {
        padding: 20px;
        border-bottom: 1px solid var(--border-color);
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .menu-title {
        font-size: 1.125rem;
        font-weight: 600;
        color: var(--text-primary);
      }

      .menu-close-btn {
        width: 32px;
        height: 32px;
        border: none;
        background: transparent;
        color: var(--text-primary);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 6px;
        transition: background 0.2s ease;
      }

      .menu-close-btn:hover {
        background: var(--bg-tertiary);
      }

      .menu-items {
        flex: 1;
        padding: 12px 0;
        overflow-y: auto;
      }

      .menu-item {
        display: block;
        width: 100%;
        padding: 14px 20px;
        border: none;
        background: transparent;
        color: var(--text-primary);
        text-align: left;
        font-size: 0.9375rem;
        font-weight: 500;
        cursor: pointer;
        transition: background 0.2s ease;
      }

      .menu-item:hover {
        background: var(--bg-tertiary);
      }

      .menu-item.active {
        background: var(--bg-tertiary);
        color: var(--accent);
      }

      .menu-signout {
        margin-top: auto;
        padding: 12px 0;
        border-top: 1px solid var(--border-color);
      }

      .menu-signout .menu-item {
        color: var(--error);
      }

      .menu-signout .menu-item:hover {
        background: var(--bg-tertiary);
      }

      .currently-playing-playback-controls {
        display: none;
        justify-content: center;
        align-items: center;
        gap: 24px;
        margin: 20px 0 16px 0;
        padding: 0 16px;
      }

      .currently-playing.expanded .currently-playing-playback-controls {
        display: flex;
      }

      .playback-control-btn {
        width: 40px;
        height: 40px;
        border: none;
        background: transparent;
        color: var(--text-primary);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: all 0.2s ease;
        padding: 0;
      }

      .playback-control-btn:hover {
        background: var(--bg-tertiary);
        transform: scale(1.1);
      }


      .playback-control-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        transform: none;
      }

      .playback-control-btn svg {
        width: 20px;
        height: 20px;
        fill: currentColor;
      }

      .playback-control-btn.play-pause {
        width: 56px;
        height: 56px;
        background: var(--bg-primary);
        border: 2px solid var(--border-color);
        box-shadow: var(--shadow-sm);
      }

      .playback-control-btn.play-pause:hover {
        background: var(--bg-tertiary);
        border-color: var(--accent);
        transform: scale(1.05);
      }

      .playback-control-btn.play-pause.playing {
        background: var(--accent);
        border-color: var(--accent);
        color: var(--bg-primary);
      }

      .playback-control-btn.play-pause.playing:hover {
        background: var(--accent-hover);
        border-color: var(--accent-hover);
      }

      .playback-control-btn.play-pause svg {
        width: 24px;
        height: 24px;
      }

      /* Show/hide play/pause icons in expanded section */
      .playback-control-btn.play-pause #play-icon {
        display: block;
      }

      .playback-control-btn.play-pause #pause-icon {
        display: none;
      }

      .playback-control-btn.play-pause.playing #play-icon {
        display: none;
      }

      .playback-control-btn.play-pause.playing #pause-icon {
        display: block;
      }

      .currently-playing-master-volume {
        display: flex;
        flex-direction: column;
        gap: 12px;
        margin-bottom: 12px;
      }

      .master-volume-label {
        font-size: 0.875rem;
        font-weight: 600;
        color: var(--text-primary);
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }

      .master-volume-row {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .master-volume-slider {
        flex: 1;
        height: 4px;
        accent-color: var(--accent);
        cursor: pointer;
      }

      .master-volume-value {
        min-width: 2.5rem;
        text-align: right;
        font-size: 0.875rem;
        font-weight: 500;
        color: var(--text-secondary);
        font-variant-numeric: tabular-nums;
      }
    </style>
  </head>
  <body>
    <div id="menu-backdrop" class="menu-backdrop"></div>
    <div id="menu-panel" class="menu-panel">
      <div class="menu-header">
        <span class="menu-title">Menu</span>
        <button id="menu-close-btn" class="menu-close-btn" type="button" aria-label="Close menu">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" width="20" height="20">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      <div class="menu-items">
        <button id="menu-item-controls" class="menu-item active" type="button">Controls</button>
        <button id="menu-item-settings" class="menu-item" type="button">Settings</button>
      </div>
      <div class="menu-signout">
        <button id="menu-item-signout" class="menu-item" type="button">Sign out</button>
      </div>
    </div>

    <main class="container">
      <div class="header-wrapper">
        <div class="header-container">
          <button id="hamburger-menu-btn" class="hamburger-menu-btn" type="button" aria-label="Open menu">
            <span></span>
            <span></span>
            <span></span>
          </button>
          <h1>Sonos Controller</h1>
        </div>
      </div>
      <p id="status" class="status disconnected">Checking connectionâ€¦</p>
      <div id="feedback" class="feedback"></div>

      <div id="auth-bar" style="margin-bottom: 12px">
        <button id="signin-btn" onclick="login()">Sign in with Sonos</button>
      </div>

      <div id="app-panels" class="hidden">
        <div id="household-title" class="household-title"></div>

        <section id="panel-control">
          <div class="favorites">
            <span class="section-title">Favorites</span>
            <div id="vibe-filters" class="vibe-filters"></div>
            <p id="favorites-status" class="favorites-status">Sign in to load favorites.</p>
            <div id="favorites-grid" class="favorites-grid"></div>
          </div>
        </section>

        <section id="panel-settings" class="hidden">
          <h3 class="section-title">Default Volumes (on play)</h3>
          <p id="settings-help" class="favorites-status">
            Set a default launch volume for each speaker. Leave blank to keep its current level.
          </p>
          <div id="settings-players"></div>
          <div class="settings-actions">
            <button id="settings-save" type="button">Save Defaults</button>
            <span id="settings-status" class="settings-status"></span>
          </div>
        </section>
      </div>

      <div id="currently-playing" class="currently-playing">
        <div class="currently-playing-content">
          <div class="currently-playing-art" id="currently-playing-art">
            <span class="currently-playing-art-placeholder">â™ª</span>
          </div>
          <div class="currently-playing-info">
            <div class="currently-playing-location" id="currently-playing-location">
              <span>No group selected</span>
            </div>
            <div class="currently-playing-title" id="currently-playing-title">
              Nothing playing
            </div>
            <div class="currently-playing-artist" id="currently-playing-artist">
              <span></span>
            </div>
          </div>
          <div class="currently-playing-controls">
            <div class="currently-playing-group-indicator" id="currently-playing-group-indicator" style="display: none;">
              <span>ðŸ”Š</span>
              <span class="currently-playing-group-count" id="currently-playing-group-count" style="display: none;">1</span>
            </div>
            <button class="currently-playing-play-btn" id="currently-playing-play-btn" type="button">
              <svg class="play-icon" viewBox="0 0 24 24" fill="currentColor">
                <path d="M8 5v14l11-7z" />
              </svg>
              <svg class="pause-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="6" y="4" width="4" height="16" rx="1"/>
                <rect x="14" y="4" width="4" height="16" rx="1"/>
              </svg>
            </button>
          </div>
        </div>
        <div class="currently-playing-playback-controls" id="currently-playing-playback-controls">
          <button class="playback-control-btn" id="playback-prev-btn" type="button" aria-label="Previous">
            <svg viewBox="0 0 24 24" fill="currentColor">
              <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/>
            </svg>
          </button>
          <button class="playback-control-btn play-pause" id="playback-play-pause-btn" type="button" aria-label="Play/Pause">
            <svg id="play-icon" viewBox="0 0 24 24" fill="currentColor">
              <path d="M8 5v14l11-7z"/>
            </svg>
            <svg id="pause-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
              <rect x="6" y="4" width="4" height="16" rx="1"/>
              <rect x="14" y="4" width="4" height="16" rx="1"/>
            </svg>
          </button>
          <button class="playback-control-btn" id="playback-next-btn" type="button" aria-label="Next">
            <svg viewBox="0 0 24 24" fill="currentColor">
              <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/>
            </svg>
          </button>
        </div>
        <div class="currently-playing-volume" id="currently-playing-volume">
          <div class="currently-playing-master-volume" id="currently-playing-master-volume">
            <div class="master-volume-label">Master Volume</div>
            <div class="master-volume-row">
              <input id="master-volume-slider" type="range" class="master-volume-slider" min="0" max="100" step="1" value="0" />
              <span id="master-volume-value" class="master-volume-value">0%</span>
            </div>
          </div>
          <div id="currently-playing-rooms-list"></div>
        </div>
      </div>
    </main>

    <script>
      const SELECT_GROUP_MESSAGE = 'Ready to play';
      const READY_MESSAGE = 'Ready to play';
      const FAVORITE_SUCCESS_MESSAGE = 'Loaded â€¢ Shuffle / Repeat / Crossfade ON';
      const FAVORITE_ERROR_MESSAGE = 'Favorite failed to start';
      const LOADING_MESSAGE = 'Loadingâ€¦';
      const FAVORITE_SUCCESS_TOAST = 'Favorite loaded with shuffle, repeat, crossfade.';

      const statusLabel = document.getElementById('status');
      const feedbackLabel = document.getElementById('feedback');
      const signinButton = document.getElementById('signin-btn');
      const panelsContainer = document.getElementById('app-panels');
      const panelControl = document.getElementById('panel-control');
      const panelSettings = document.getElementById('panel-settings');
      const householdTitle = document.getElementById('household-title');
      const favoritesGrid = document.getElementById('favorites-grid');
      const favoritesStatus = document.getElementById('favorites-status');
      const vibeFiltersContainer = document.getElementById('vibe-filters');
      const currentlyPlayingPanel = document.getElementById('currently-playing');
      const currentlyPlayingArt = document.getElementById('currently-playing-art');
      const currentlyPlayingLocation = document.getElementById('currently-playing-location');
      const currentlyPlayingTitle = document.getElementById('currently-playing-title');
      const currentlyPlayingArtist = document.getElementById('currently-playing-artist');
      const currentlyPlayingGroupIndicator = document.getElementById('currently-playing-group-indicator');
      const currentlyPlayingGroupCount = document.getElementById('currently-playing-group-count');
      const currentlyPlayingPlayBtn = document.getElementById('currently-playing-play-btn');
      const currentlyPlayingVolume = document.getElementById('currently-playing-volume');
      const currentlyPlayingRoomsList = document.getElementById('currently-playing-rooms-list');
      
      // Hamburger menu elements
      const hamburgerMenuBtn = document.getElementById('hamburger-menu-btn');
      const menuBackdrop = document.getElementById('menu-backdrop');
      const menuPanel = document.getElementById('menu-panel');
      const menuCloseBtn = document.getElementById('menu-close-btn');
      const menuItemControls = document.getElementById('menu-item-controls');
      const menuItemSettings = document.getElementById('menu-item-settings');
      const menuItemSignout = document.getElementById('menu-item-signout');
      
      // Playback controls in now-playing section
      const playbackPrevBtn = document.getElementById('playback-prev-btn');
      const playbackPlayPauseBtn = document.getElementById('playback-play-pause-btn');
      const playbackNextBtn = document.getElementById('playback-next-btn');
      const playIcon = document.getElementById('play-icon');
      const pauseIcon = document.getElementById('pause-icon');
      
      // Master volume controls
      const masterVolumeSlider = document.getElementById('master-volume-slider');
      const masterVolumeValue = document.getElementById('master-volume-value');
      
      // Track panel state to prevent flickering
      let panelShouldBeVisible = false;
      let hidePanelTimeout = null;
      let currentHouseholdName = null;
      
const settingsPlayersWrap = document.getElementById('settings-players');
const settingsSaveButton = document.getElementById('settings-save');
const settingsStatusLabel = document.getElementById('settings-status');
const settingsHelpLabel = document.getElementById('settings-help');

settingsSaveButton.disabled = true;
settingsStatusLabel.textContent = '';

      let isSonosConnected = false;
      let currentHouseholdId = null;
      let currentGroupId = null;
      let currentGroupName = 'No group selected';
      let currentActiveFavoriteId = null;
      const favoritesRegistry = new Map();
      let latestPlayers = [];
      let latestGroups = [];
      let refreshTimer = null;
      let playlistVibes = {};
      let currentVibeFilter = null;
      let playbackRefreshTimer = null;
      let currentPlaybackState = null;
      // Track playback state locally (since API is unreliable)
      let trackedPlaybackState = null; // 'PLAYING' | 'PAUSED' | null
      let currentImageUrl = null;

      function login() {
        window.location.href = '/auth/sonos/login';
      }

async function signout() {
  try {
    await fetch('/auth/signout', { method: 'POST' });
  } catch (error) {
    console.error('Sign out failed:', error);
  }
  closeMenu();
  setAuthUI(false);
  showFeedback('Signed out of Sonos.');
}

function openMenu() {
  menuPanel.classList.add('open');
  menuBackdrop.classList.add('visible');
  document.body.classList.add('menu-open');
}

function closeMenu() {
  menuPanel.classList.remove('open');
  menuBackdrop.classList.remove('visible');
  document.body.classList.remove('menu-open');
}

function showView(name) {
  const isControl = name === 'control';
  menuItemControls.classList.toggle('active', isControl);
  menuItemSettings.classList.toggle('active', !isControl);
  panelControl.classList.toggle('hidden', !isControl);
  panelSettings.classList.toggle('hidden', isControl);
  closeMenu();
  
  if (!isControl) {
    renderSettings();
  }
}

// Hamburger menu event handlers
hamburgerMenuBtn.addEventListener('click', () => {
  openMenu();
});

menuCloseBtn.addEventListener('click', () => {
  closeMenu();
});

menuBackdrop.addEventListener('click', () => {
  closeMenu();
});

menuItemControls.addEventListener('click', () => {
  showView('control');
});

menuItemSettings.addEventListener('click', () => {
  showView('settings');
});

menuItemSignout.addEventListener('click', () => {
  signout();
});

function setAuthUI(loggedIn) {
  signinButton.classList.toggle('hidden', loggedIn);
  panelsContainer.classList.toggle('hidden', !loggedIn);
  if (!loggedIn) {
    showView('control');
    closeMenu();
  }
  updateConnectionStatus(loggedIn);
}

async function checkAuthAndInit() {
  try {
    const response = await fetch('/auth/status');
    if (!response.ok) {
      throw new Error('Failed to check auth status');
    }

    const state = await response.json();
    const loggedIn = Boolean(state.loggedIn);
    setAuthUI(loggedIn);
    showView('control');

    if (loggedIn) {
      await refreshUI();
    }
  } catch (error) {
          console.error('Auth status check failed:', error);
          setAuthUI(false);
        }
      }

      // Playback control handlers for now-playing section
      playbackPrevBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        await handlePlaybackAction('previous');
      });

      playbackPlayPauseBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        await handlePlaybackAction('playpause');
      });

      playbackNextBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        await handlePlaybackAction('next');
      });

      // Master volume handler
      masterVolumeSlider.addEventListener('input', (e) => {
        masterVolumeValue.textContent = `${Number(e.target.value)}%`;
      });

      masterVolumeSlider.addEventListener('change', async (e) => {
        e.stopPropagation();
        await setMasterVolume(Number(e.target.value));
      });
      const authMessages = {
        success: 'Sonos authorization complete. Ready to control playback.',
        error: 'Authorization failed. Please try logging in again.',
        missing_code: 'Login response missing authorization code.',
        invalid_state: 'Login validation failed. Please retry.'
      };

      function applyAuthFeedback() {
        const params = new URLSearchParams(window.location.search);
        const state = params.get('auth');

        if (state && authMessages[state]) {
          showFeedback(authMessages[state], state !== 'success');
          params.delete('auth');
          const newUrl = window.location.pathname + (params.toString() ? `?${params}` : '');
          window.history.replaceState({}, '', newUrl);
        }
      }

      function updateConnectionStatus(connected) {
        statusLabel.classList.toggle('connected', connected);
        statusLabel.classList.toggle('disconnected', !connected);
        statusLabel.textContent = connected ? 'Connected to Sonos' : 'Not connected';
        isSonosConnected = connected;

        if (!connected) {
          currentHouseholdId = null;
          currentHouseholdName = null;
          householdTitle.textContent = '';
          favoritesStatus.textContent = 'Login required to load favorites.';
          vibeFiltersContainer.innerHTML = '';
          currentGroupId = null;
          currentGroupName = 'No group selected';
          updateActiveGroupDisplay();
          currentActiveFavoriteId = null;
          settingsPlayersWrap.innerHTML = '';
          settingsStatusLabel.textContent = '';
          if (settingsHelpLabel) {
            settingsHelpLabel.textContent = 'Sign in to load speakers.';
          }
          stopPlaybackRefresh();
          currentlyPlayingPanel.classList.remove('visible');
          document.body.classList.remove('has-playing');
        }

        settingsSaveButton.disabled = !connected;
        evaluateFavoritesAvailability();
      }

      function showFeedback(message, isError = false) {
        feedbackLabel.textContent = message ?? '';
        feedbackLabel.classList.toggle('error', Boolean(isError));
      }

      function getSelectedGroupId() {
        return currentGroupId;
      }

      function updateActiveGroupDisplay() {
        // Group display removed - groups are auto-created
      }


      async function loadHouseholds() {
        try {
          const response = await fetch('/api/households');

          if (response.status === 401) {
            setAuthUI(false);
            showFeedback('Login required to load Sonos households.', true);
            favoritesStatus.textContent = 'Login required to load favorites.';
            return;
          }

          if (!response.ok) {
            throw new Error(await response.text());
          }

          const data = await response.json();
          const households = Array.isArray(data.households) ? data.households : [];

          if (!households.length) {
            setAuthUI(true);
            showFeedback('No households returned for this account.', true);
            currentHouseholdId = null;
            currentHouseholdName = null;
            householdTitle.textContent = '';
            currentGroupId = null;
            currentGroupName = 'No group selected';
            currentActiveFavoriteId = null;
            updateActiveGroupDisplay();
            await loadFavorites(null);
            await loadPlayers(null);
            evaluateFavoritesAvailability();
            return;
          }

          // Auto-select first household and display as title
          const firstHousehold = households[0];
          currentHouseholdId = firstHousehold.id || null;
          currentHouseholdName = firstHousehold.name || firstHousehold.id || '';
          householdTitle.textContent = currentHouseholdName;

          setAuthUI(true);
          showFeedback('Household loaded.');

          if (currentHouseholdId) {
            await loadPlayers(currentHouseholdId);
            await loadFavorites(currentHouseholdId);
          } else {
            await loadFavorites(null);
            await loadPlayers(null);
            evaluateFavoritesAvailability();
          }

          if (!panelSettings.classList.contains('hidden')) {
            await renderSettings();
          }
        } catch (error) {
          console.error('Failed to load households:', error);
          showFeedback('Could not load households. Please try again.', true);
          setAuthUI(false);
          favoritesStatus.textContent = 'Unable to load favorites.';
      }
    }

      async function fetchGroupsPlayers(householdId) {
        if (!householdId) {
          return { groups: [], players: [] };
        }

        const response = await fetch(
          `/api/households/${encodeURIComponent(householdId)}/groups-players`
        );

        if (!response.ok) {
          throw new Error(await response.text());
        }

        return response.json();
      }

      async function renderSettings() {
        if (panelSettings.classList.contains('hidden')) {
          return;
        }

        settingsStatusLabel.textContent = '';

        if (!isSonosConnected) {
          settingsPlayersWrap.innerHTML = '';
          if (settingsHelpLabel) {
            settingsHelpLabel.textContent = 'Sign in to load speakers.';
          }
          settingsSaveButton.disabled = true;
          settingsSaveButton.onclick = null;
          return;
        }

        const householdId = currentHouseholdId;
        if (!householdId) {
          settingsPlayersWrap.innerHTML = '';
          if (settingsHelpLabel) {
            settingsHelpLabel.textContent = 'No household available.';
          }
          settingsSaveButton.disabled = true;
          settingsSaveButton.onclick = null;
          return;
        }

        if (settingsHelpLabel) {
          settingsHelpLabel.textContent =
            'Set a default launch volume for each speaker. Leave blank to keep its current level.';
        }

        try {
          const [snapshot, defaults] = await Promise.all([
            fetchGroupsPlayers(householdId),
            fetch('/api/settings/volumes').then((response) => {
              if (!response.ok) {
                throw new Error('Failed to load saved volumes');
              }
              return response.json();
            })
          ]);

          const players = Array.isArray(snapshot.players) ? snapshot.players : [];
          settingsPlayersWrap.innerHTML = '';

          if (!players.length) {
            settingsSaveButton.disabled = true;
            settingsStatusLabel.textContent = 'No speakers found for this household.';
            settingsSaveButton.onclick = null;
            return;
          }

          players.forEach((player) => {
            const row = document.createElement('div');
            row.className = 'settings-row';
            row.dataset.playerId = player.id;

            const nameLabel = document.createElement('strong');
            nameLabel.textContent = player.name || player.id || 'Speaker';

            const rangeInput = document.createElement('input');
            rangeInput.type = 'range';
            rangeInput.min = '0';
            rangeInput.max = '100';

            const numberInput = document.createElement('input');
            numberInput.type = 'number';
            numberInput.min = '0';
            numberInput.max = '100';
            numberInput.placeholder = 'â€”';

            const defaultValue =
              defaults && typeof defaults[player.id] === 'number'
                ? Math.max(0, Math.min(100, Number(defaults[player.id])))
                : null;

            if (defaultValue === null || Number.isNaN(defaultValue)) {
              rangeInput.value = '50';
              numberInput.value = '';
            } else {
              rangeInput.value = String(defaultValue);
              numberInput.value = String(defaultValue);
            }

            rangeInput.addEventListener('input', (event) => {
              numberInput.value = event.target.value;
            });

            numberInput.addEventListener('input', (event) => {
              const raw = event.target.value.trim();
              if (raw === '') {
                return;
              }

              let numeric = Number(raw);
              if (Number.isNaN(numeric)) {
                numeric = '';
              } else {
                numeric = Math.max(0, Math.min(100, numeric));
              }

              if (numeric === '') {
                event.target.value = '';
              } else {
                event.target.value = String(numeric);
                rangeInput.value = String(numeric);
              }
            });

            row.appendChild(nameLabel);
            row.appendChild(rangeInput);
            row.appendChild(numberInput);
            settingsPlayersWrap.appendChild(row);
          });

          settingsSaveButton.disabled = false;
          settingsSaveButton.onclick = async () => {
            try {
              settingsSaveButton.disabled = true;
              settingsStatusLabel.textContent = 'Savingâ€¦';

              const payload = {};
              settingsPlayersWrap.querySelectorAll('.settings-row').forEach((row) => {
                const playerId = row.dataset.playerId;
                const input = row.querySelector('input[type="number"]');
                if (!playerId || !input) {
                  return;
                }

                const value = input.value.trim();
                if (value !== '') {
                  payload[playerId] = Number(value);
                }
              });

              const response = await fetch('/api/settings/volumes', {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
              });

              if (!response.ok) {
                throw new Error(await response.text());
              }

              settingsStatusLabel.textContent = 'Saved defaults.';
            } catch (error) {
              console.error('Failed to save volume defaults:', error);
              settingsStatusLabel.textContent = 'Failed to save defaults.';
            } finally {
              settingsSaveButton.disabled = false;
            }
          };
        } catch (error) {
          console.error('Failed to render settings:', error);
          settingsPlayersWrap.innerHTML = '';
          settingsStatusLabel.textContent = 'Failed to load speaker data.';
          settingsSaveButton.disabled = true;
          settingsSaveButton.onclick = null;
        }
      }

      async function loadPlaylistVibes() {
        try {
          const response = await fetch('/api/playlist-vibes');
          if (response.ok) {
            playlistVibes = await response.json();
          }
        } catch (error) {
          console.error('Failed to load playlist vibes:', error);
        }
      }

      async function setPlaylistVibe(playlistId, vibe) {
        if (vibe) {
          playlistVibes[playlistId] = vibe;
        } else {
          delete playlistVibes[playlistId];
        }

        try {
          const response = await fetch('/api/playlist-vibes', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(playlistVibes)
          });

          if (!response.ok) {
            throw new Error('Failed to save vibe');
          }

          applyVibeFilter();
        } catch (error) {
          console.error('Failed to save playlist vibe:', error);
        }
      }

      function renderVibeFilters() {
        vibeFiltersContainer.innerHTML = '';

        const allButton = document.createElement('button');
        allButton.className = 'vibe-filter-btn';
        allButton.textContent = 'All';
        allButton.classList.toggle('active', currentVibeFilter === null);
        allButton.addEventListener('click', () => {
          currentVibeFilter = null;
          applyVibeFilter();
        });
        vibeFiltersContainer.appendChild(allButton);

        ['Down', 'Down/Mid', 'Mid'].forEach((vibe) => {
          const button = document.createElement('button');
          button.className = 'vibe-filter-btn';
          button.textContent = vibe;
          button.classList.toggle('active', currentVibeFilter === vibe);
          button.addEventListener('click', () => {
            currentVibeFilter = vibe;
            applyVibeFilter();
          });
          vibeFiltersContainer.appendChild(button);
        });
      }

      function applyVibeFilter() {
        favoritesRegistry.forEach((entry) => {
          const vibe = playlistVibes[entry.favorite.id] || null;
          const shouldShow = currentVibeFilter === null || vibe === currentVibeFilter;
          entry.button.style.display = shouldShow ? '' : 'none';
        });
      }

      async function loadFavorites(householdId) {
        favoritesRegistry.clear();
        favoritesGrid.innerHTML = '';

        if (!householdId) {
          favoritesStatus.textContent = isSonosConnected
            ? 'Select a household to load favorites.'
            : 'Login required to load favorites.';
          vibeFiltersContainer.innerHTML = '';
          evaluateFavoritesAvailability();
          return;
        }

        favoritesStatus.textContent = 'Loading favoritesâ€¦';

        try {
          await loadPlaylistVibes();

          const params = new URLSearchParams({ householdId });
          const activeGroupId = getSelectedGroupId();
          if (activeGroupId) {
            params.set('groupId', activeGroupId);
          }

          const response = await fetch(`/api/favorites?${params.toString()}`);

          if (response.status === 401) {
            setAuthUI(false);
            favoritesStatus.textContent = 'Login required to load favorites.';
            return;
          }

          if (!response.ok) {
            throw new Error(await response.text());
          }

          const data = await response.json();
          const items = Array.isArray(data.items) ? data.items : [];
          currentActiveFavoriteId = data.activeFavorite ?? null;

          if (!items.length) {
            favoritesStatus.textContent = 'No favorites found.';
            vibeFiltersContainer.innerHTML = '';
            evaluateFavoritesAvailability();
            return;
          }

          favoritesStatus.textContent = '';

          items.forEach((favorite) => {
            const entry = createFavoriteCard(favorite);
            favoritesRegistry.set(favorite.id, entry);
            favoritesGrid.appendChild(entry.button);
          });

          renderVibeFilters();
          applyVibeFilter();
          evaluateFavoritesAvailability();
          markActiveFavorite(currentActiveFavoriteId);
        } catch (error) {
          console.error('Failed to load favorites:', error);
          favoritesStatus.textContent = 'Could not load favorites. Please try again.';
          vibeFiltersContainer.innerHTML = '';
          evaluateFavoritesAvailability();
        }
      }

      function createFavoriteCard(favorite) {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'playlist-card disabled';
        button.disabled = true;
        button.dataset.favoriteId = favorite.id;

        const artWrapper = document.createElement('div');
        artWrapper.className = 'playlist-art-wrapper';

        const imageUrl =
          favorite && favorite.imageUrl
            ? favorite.imageUrl
            : favorite && favorite.images && favorite.images.length && favorite.images[0].url
              ? favorite.images[0].url
              : favorite && favorite.container && favorite.container.imageUrl
                ? favorite.container.imageUrl
                : null;

        if (imageUrl) {
          const img = document.createElement('img');
          img.className = 'playlist-art';
          img.alt = `${favorite.name || 'Favorite'} cover art`;
          img.loading = 'lazy';
          img.src = imageUrl;
          img.addEventListener('error', () => img.classList.add('hidden'));
          artWrapper.appendChild(img);
        } else {
          const placeholder = document.createElement('span');
          placeholder.className = 'playlist-placeholder';
          placeholder.textContent = 'â˜…';
          artWrapper.appendChild(placeholder);
        }

        const meta = document.createElement('div');
        meta.className = 'playlist-meta';

        const brand = document.createElement('span');
        brand.className = 'playlist-brand';
        const brandIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        brandIcon.setAttribute('viewBox', '0 0 24 24');
        brandIcon.setAttribute('aria-hidden', 'true');
        const brandPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        brandPath.setAttribute(
          'd',
          'M12 17.27 18.18 21l-1.64-7.03L22 9.24l-7.19-.62L12 2 9.19 8.62 2 9.24l5.46 4.73L5.82 21z'
        );
        brandIcon.appendChild(brandPath);
        brand.appendChild(brandIcon);
        const serviceLabel =
          favorite && favorite.service && favorite.service.name
            ? favorite.service.name
            : favorite && favorite.programType
              ? favorite.programType
              : 'Sonos Favorite';
        brand.appendChild(document.createTextNode(' ' + serviceLabel));

        const title = document.createElement('span');
        title.className = 'playlist-name';
        title.textContent = favorite.name || 'Unnamed Favorite';

        const status = document.createElement('span');
        status.className = 'playlist-status';
        status.textContent = SELECT_GROUP_MESSAGE;

        meta.appendChild(brand);
        meta.appendChild(title);
        meta.appendChild(status);

        const cardContent = document.createElement('div');
        cardContent.className = 'playlist-card-content';
        cardContent.appendChild(artWrapper);
        cardContent.appendChild(meta);

        const vibeSelector = document.createElement('div');
        vibeSelector.className = 'playlist-vibe-selector';
        const vibeLabel = document.createElement('label');
        vibeLabel.textContent = 'Vibe:';
        const vibeSelect = document.createElement('select');
        vibeSelect.dataset.favoriteId = favorite.id;
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = 'â€”';
        vibeSelect.appendChild(defaultOption);
        ['Down', 'Down/Mid', 'Mid'].forEach((vibe) => {
          const option = document.createElement('option');
          option.value = vibe;
          option.textContent = vibe;
          vibeSelect.appendChild(option);
        });
        vibeSelect.value = playlistVibes[favorite.id] || '';
        vibeSelect.addEventListener('change', (event) => {
          event.stopPropagation();
          setPlaylistVibe(favorite.id, event.target.value);
        });
        vibeSelector.appendChild(vibeLabel);
        vibeSelector.appendChild(vibeSelect);

        button.appendChild(cardContent);
        button.appendChild(vibeSelector);

        const entry = {
          favorite,
          button,
          statusEl: status,
          loading: false,
          statusMessage: SELECT_GROUP_MESSAGE,
          vibeSelect
        };

        button.addEventListener('click', (event) => {
          if (event.target === vibeSelect || event.target.closest('.playlist-vibe-selector')) {
            return;
          }
          playFavorite(entry);
        });

        return entry;
      }

      async function playFavorite(entry) {
        if (!currentHouseholdId) {
          showFeedback('Select a household first.', true);
          return;
        }

        setFavoriteLoading(entry, true);

        try {
          const groupResponse = await fetch(`/api/households/${encodeURIComponent(currentHouseholdId)}/create-all-group`, {
            method: 'POST'
          });

          if (!groupResponse.ok) {
            throw new Error('Failed to create group with all players');
          }

          const groupData = await groupResponse.json();
          const groupId = groupData.groupId;

          if (!groupId) {
            throw new Error('No group ID returned');
          }

          setActiveGroup(groupId, groupData.groupName || 'All Rooms');

          const commandPromise = sendCommand(
            `/api/groups/${encodeURIComponent(groupId)}/favorites/play`,
            {
              householdId: currentHouseholdId,
              favoriteId: entry.favorite.id,
              shuffle: true,
              repeat: true,
              crossfade: true
            },
            FAVORITE_SUCCESS_TOAST
          );

          const [success] = await Promise.all([commandPromise, delay(2000)]);
          setFavoriteLoading(entry, false);

          if (success) {
            // Store the group ID before loadPlayers might clear it
            const savedGroupId = groupId;
            await loadPlayers(currentHouseholdId);
            // Restore the group ID if it was cleared
            if (!getSelectedGroupId() && savedGroupId) {
              setActiveGroup(savedGroupId, groupData.groupName || 'All Rooms');
            }
            markActiveFavorite(entry.favorite.id);
            setTimeout(() => {
              updateCurrentlyPlaying();
            }, 1000);
          } else {
            updateFavoriteStatus(entry, FAVORITE_ERROR_MESSAGE);
          }
        } catch (error) {
          console.error('Failed to play favorite:', error);
          setFavoriteLoading(entry, false);
          updateFavoriteStatus(entry, FAVORITE_ERROR_MESSAGE);
          showFeedback('Failed to start playback. Please try again.', true);
        }

        evaluateFavoritesAvailability();
      }

      function setFavoriteLoading(entry, isLoading) {
        entry.loading = isLoading;
        entry.button.disabled = true;
        if (isLoading) {
          entry.button.classList.add('loading');
          updateFavoriteStatus(entry, LOADING_MESSAGE);
        } else {
          entry.button.classList.remove('loading');
        }
      }

      function updateFavoriteStatus(entry, message) {
        entry.statusMessage = message;
        entry.statusEl.textContent = message;
      }

      function evaluateFavoritesAvailability() {
        const enabled = isSonosConnected && Boolean(currentHouseholdId);

        favoritesRegistry.forEach((entry) => {
          if (entry.loading) {
            return;
          }

          entry.button.disabled = !enabled;
          entry.button.classList.toggle('disabled', !enabled);

          if (!enabled) {
            entry.button.classList.remove('active');
            updateFavoriteStatus(entry, 'Select a household to play');
          } else if (
            entry.statusMessage === SELECT_GROUP_MESSAGE ||
            entry.statusMessage === READY_MESSAGE ||
            entry.statusMessage === ''
          ) {
            updateFavoriteStatus(entry, READY_MESSAGE);
          }
        });

        if (enabled) {
          markActiveFavorite(currentActiveFavoriteId);
        }
      }

      function markActiveFavorite(favoriteId) {
        currentActiveFavoriteId = favoriteId || null;

        favoritesRegistry.forEach((entry) => {
          if (entry.loading) {
            return;
          }

          const isActive = Boolean(favoriteId) && entry.favorite.id === favoriteId;
          entry.button.classList.toggle('active', isActive);

          if (isActive) {
            updateFavoriteStatus(entry, FAVORITE_SUCCESS_MESSAGE);
          } else if (entry.statusMessage === FAVORITE_SUCCESS_MESSAGE) {
            updateFavoriteStatus(entry, READY_MESSAGE);
          }
        });
      }

      async function handlePlaybackAction(action) {
        const groupId = getSelectedGroupId();
        if (!groupId) {
          // Auto-grouping is handled on load, but if we still don't have a group, try to create one
          if (currentHouseholdId && latestPlayers.length > 0) {
            try {
              const groupResponse = await fetch(`/api/households/${encodeURIComponent(currentHouseholdId)}/create-all-group`, {
                method: 'POST'
              });
              if (groupResponse.ok) {
                const groupData = await groupResponse.json();
                if (groupData.groupId) {
                  setActiveGroup(groupData.groupId, groupData.groupName || 'All Rooms');
                  // Retry the action
                  handlePlaybackAction(action);
                  return;
                }
              }
            } catch (error) {
              console.error('Failed to auto-create group:', error);
            }
          }
          showFeedback('Unable to control playback. Please try again.', true);
          return;
        }

        // Track state change for play/pause - toggle based on current tracked state
        if (action === 'playpause') {
          // Determine current state to toggle from
          const currentIsPlaying = trackedPlaybackState === 'PLAYING' || (trackedPlaybackState === null && currentPlaybackState?.playbackState === 'PLAYING');
          // Toggle tracked state
          if (currentIsPlaying) {
            trackedPlaybackState = 'PAUSED';
          } else {
            trackedPlaybackState = 'PLAYING';
          }
          console.log('[PlayPause] Tracked state after toggle:', trackedPlaybackState, '(was playing:', currentIsPlaying + ')');
        }

        const endpoints = {
          playpause: `/api/groups/${encodeURIComponent(groupId)}/playpause`,
          next: `/api/groups/${encodeURIComponent(groupId)}/next`,
          previous: `/api/groups/${encodeURIComponent(groupId)}/previous`
        };

        const endpoint = endpoints[action];
        if (!endpoint) {
          console.warn(`Unknown playback action requested: ${action}`);
          return;
        }

        await sendCommand(endpoint);
        setTimeout(() => updateCurrentlyPlaying(), 500);
      }

      async function setMasterVolume(level) {
        const groupId = getSelectedGroupId();
        if (!groupId) {
          // Auto-grouping is handled on load, but if we still don't have a group, try to create one
          if (currentHouseholdId && latestPlayers.length > 0) {
            try {
              const groupResponse = await fetch(`/api/households/${encodeURIComponent(currentHouseholdId)}/create-all-group`, {
                method: 'POST'
              });
              if (groupResponse.ok) {
                const groupData = await groupResponse.json();
                if (groupData.groupId) {
                  setActiveGroup(groupData.groupId, groupData.groupName || 'All Rooms');
                  // Retry setting volume
                  setMasterVolume(level);
                  return;
                }
              }
            } catch (error) {
              console.error('Failed to auto-create group:', error);
            }
          }
          showFeedback('Unable to change volume. Please try again.', true);
          return;
        }

        masterVolumeValue.textContent = `${level}%`;
        const success = await sendCommand(
          `/api/groups/${encodeURIComponent(groupId)}/volume`,
          {
            volume: level
          },
          `Volume set to ${level}%.`
        );

        if (!success) {
          showFeedback('Unable to update volume. Please try again.', true);
        } else {
          // Update individual player volumes proportionally
          updateIndividualVolumesFromMaster(level);
          setTimeout(() => updateCurrentlyPlaying(), 500);
        }
      }

      function updateIndividualVolumesFromMaster(masterLevel) {
        // Update all individual sliders to match master volume
        const roomRows = currentlyPlayingRoomsList.querySelectorAll('.currently-playing-room-volume');
        roomRows.forEach((row) => {
          const slider = row.querySelector('.currently-playing-room-slider');
          const value = row.querySelector('.currently-playing-room-value');
          if (slider && value) {
            slider.value = masterLevel;
            value.textContent = `${masterLevel}`;
          }
        });
      }

      async function sendCommand(endpoint, body, successMessage = 'Command sent to Sonos.') {
        try {
          const response = await fetch(endpoint, {
            method: 'POST',
            headers: body ? { 'Content-Type': 'application/json' } : undefined,
            body: body ? JSON.stringify(body) : undefined
          });

          if (response.status === 401) {
            setAuthUI(false);
            showFeedback('Session expired. Please login again.', true);
            return false;
          }

          if (!response.ok) {
            throw new Error(await response.text());
          }

          if (successMessage) {
            showFeedback(successMessage);
          }
          return true;
        } catch (error) {
          console.error('Command failed:', error);
          showFeedback('Unable to reach Sonos. Please try again.', true);
          return false;
        }
      }

      function delay(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

  evaluateFavoritesAvailability();
  applyAuthFeedback();
  showView('control');

      async function loadPlayers(householdId) {
        if (!householdId) {
          latestPlayers = [];
          latestGroups = [];
          ensureActiveGroup([]);
          return;
        }

        try {
          clearTimeout(refreshTimer);
          refreshTimer = null;
          const response = await fetch(`/api/households/${encodeURIComponent(householdId)}/players`);

          if (response.status === 401) {
            setAuthUI(false);
            favoritesStatus.textContent = 'Login required to load favorites.';
            return;
          }

          if (!response.ok) {
            throw new Error(await response.text());
          }

          const data = await response.json();
          latestPlayers = Array.isArray(data.players) ? data.players : [];
          latestGroups = Array.isArray(data.groups) ? data.groups : [];

          ensureActiveGroup(latestPlayers);
          let activeGroupId = getSelectedGroupId();
          
          // Automatically create and select a group with all players if none is selected
          if (!activeGroupId && latestPlayers.length > 0 && currentHouseholdId) {
            try {
              const groupResponse = await fetch(`/api/households/${encodeURIComponent(currentHouseholdId)}/create-all-group`, {
                method: 'POST'
              });
              
              if (groupResponse.ok) {
                const groupData = await groupResponse.json();
                if (groupData.groupId) {
                  setActiveGroup(groupData.groupId, groupData.groupName || 'All Rooms');
                  activeGroupId = groupData.groupId;
                }
              }
            } catch (error) {
              console.error('Failed to auto-create group:', error);
            }
          }
          
          // Check for currently playing content after a short delay to ensure everything is loaded
          setTimeout(async () => {
            // Use the active group (either existing or newly created)
            if (activeGroupId) {
              updateCurrentlyPlayingRooms(activeGroupId);
              await updateCurrentlyPlaying();
              startPlaybackRefresh();
            } else if (latestGroups.length > 0) {
              // If still no group, check all groups to find which one is playing
              for (const group of latestGroups) {
                const groupId = group.id || group.groupId;
                if (!groupId) continue;
                
                try {
                  const response = await fetch(`/api/groups/${encodeURIComponent(groupId)}/playback/status`);
                  if (response.ok) {
                    const status = await response.json();
                    const playbackState = status.playbackState || status.state || 'STOPPED';
                    const isPlaying = playbackState === 'PLAYING' || playbackState === 'PLAYBACK_STATE_PLAYING';
                    const hasContent = !!(status.track || status.currentItem || status.item);
                    
                    if (isPlaying || hasContent || playbackState !== 'STOPPED') {
                      // Found a group with playback - set it as active
                      setActiveGroup(groupId, group.name || group.displayName || 'Group');
                      updateCurrentlyPlayingRooms(groupId);
                      await updateCurrentlyPlaying();
                      startPlaybackRefresh();
                      break;
                    }
                  }
                } catch (error) {
                  // Continue to next group
                  continue;
                }
              }
            }
          }, 500);
        } catch (error) {
          console.error('Failed to load players', error);
        }
      }

      function ensureActiveGroup(players) {
        if (currentGroupId && players.some((player) => player.groupId === currentGroupId)) {
          const active = players.find((player) => player.groupId === currentGroupId);
          if (active) {
            currentGroupName = active.groupName || active.name || currentGroupName;
          }
        } else {
          // Don't clear the group if panel is visible (we're in the middle of playback)
          if (panelShouldBeVisible && currentGroupId) {
            return; // Keep the existing group ID
          }
          const candidate = players.find((player) => player.groupId);
          if (candidate) {
            currentGroupId = candidate.groupId;
            currentGroupName = candidate.groupName || candidate.name || 'Group';
          } else {
            // Only clear if panel isn't visible
            if (!panelShouldBeVisible) {
              currentGroupId = null;
              currentGroupName = 'No group selected';
            }
          }
        }
        updateActiveGroupDisplay();
        evaluateFavoritesAvailability();
      }


      async function setPlayerVolume(playerId, level) {
        if (!playerId) {
          return;
        }

        const numericLevel = Number(level);

        try {
          const postResponse = await fetch(`/api/players/${encodeURIComponent(playerId)}/volume`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ level: numericLevel })
          });

          if (!postResponse.ok) {
            throw new Error(await postResponse.text());
          }

          const getResponse = await fetch(`/api/players/${encodeURIComponent(playerId)}/volume`);
          if (getResponse.ok) {
            const payload = await getResponse.json();
            const updatedLevel = Number(
              payload.volume ?? payload?.volume?.volume ?? payload.level ?? numericLevel
            );
            
            const roomRow = document.querySelector(`[data-player-id="${playerId}"]`);
            if (roomRow) {
              const slider = roomRow.querySelector('.currently-playing-room-slider');
              const value = roomRow.querySelector('.currently-playing-room-value');
              if (slider) slider.value = updatedLevel;
              if (value) value.textContent = updatedLevel;
            }
          }

          if (currentHouseholdId) {
            setTimeout(() => loadPlayers(currentHouseholdId), 500);
          }
        } catch (error) {
          console.error('Failed to update player volume:', error);
          showFeedback('Unable to update room volume. Please try again.', true);
        }
      }

      async function refreshUI() {
        await loadHouseholds();
      }

      evaluateFavoritesAvailability();
      updateActiveGroupDisplay();

      async function updateCurrentlyPlaying() {
        let groupId = getSelectedGroupId();
        
        // If no group is selected but we have groups, try the first one
        if (!groupId && latestGroups.length > 0 && isSonosConnected) {
          const firstGroup = latestGroups.find(g => g.id || g.groupId);
          if (firstGroup) {
            groupId = firstGroup.id || firstGroup.groupId;
            // Set it as active so refresh continues
            if (groupId && !currentGroupId) {
              setActiveGroup(groupId, firstGroup.name || firstGroup.displayName || 'Group');
            }
          }
        }
        
        if (!groupId || !isSonosConnected) {
          // Only hide if panel wasn't previously visible (don't hide during transitions)
          if (!panelShouldBeVisible) {
            clearTimeout(hidePanelTimeout);
            currentlyPlayingPanel.classList.remove('visible');
            document.body.classList.remove('has-playing');
          }
          return;
        }

        try {
          const response = await fetch(`/api/groups/${encodeURIComponent(groupId)}/playback/status`);
          if (!response.ok) {
            throw new Error('Failed to fetch playback status');
          }

          const status = await response.json();
          currentPlaybackState = status;

          const apiPlaybackState = status.playbackState || status.state || status.playback?.state || 'STOPPED';
          
          // Normalize API state (handle PLAYBACK_STATE_PLAYING, PLAYING, etc.)
          let normalizedApiState = apiPlaybackState;
          if (typeof apiPlaybackState === 'string') {
            if (apiPlaybackState.includes('PLAYING')) {
              normalizedApiState = 'PLAYING';
            } else if (apiPlaybackState.includes('PAUSED') || apiPlaybackState.includes('IDLE')) {
              normalizedApiState = 'PAUSED';
            } else if (apiPlaybackState.includes('STOPPED')) {
              normalizedApiState = 'STOPPED';
            }
          }
          
          // Use tracked state if available (more reliable than API), otherwise use normalized API state
          let playbackState;
          if (trackedPlaybackState !== null) {
            // Use tracked state (from user actions) - this is more reliable than the API
            playbackState = trackedPlaybackState;
            console.log('[PlayPause] Using tracked state:', trackedPlaybackState, '(API said:', normalizedApiState + ')');
          } else if (normalizedApiState === 'STOPPED') {
            // API says STOPPED - trust it
            playbackState = 'STOPPED';
            trackedPlaybackState = 'STOPPED';
            console.log('[PlayPause] Using API STOPPED state');
          } else if (normalizedApiState === 'PAUSED') {
            // API says PAUSED - trust it
            playbackState = 'PAUSED';
            trackedPlaybackState = 'PAUSED';
            console.log('[PlayPause] Using API PAUSED state');
          } else {
            // API says PLAYING but we have no tracked state - initialize to PLAYING
            // (This happens on first load when music is already playing)
            playbackState = 'PLAYING';
            trackedPlaybackState = 'PLAYING';
            console.log('[PlayPause] Initializing tracked state to PLAYING (first load, API:', normalizedApiState + ')');
          }
          
          const isPlaying = playbackState === 'PLAYING';
          
          // DEBUG: Play/Pause state
          console.log('[PlayPause] State check:', {
            apiPlaybackState: status.playbackState || status.state || 'STOPPED',
            finalPlaybackState: playbackState,
            trackedPlaybackState,
            isPlaying,
            statusKeys: Object.keys(status)
          });
          
          const item = status.currentItem || status.item || status.playback?.currentItem || null;
          const track = item?.track || item?.container?.metadata || status.track || null;
          
          // Determine if we should show the panel - be more permissive
          const hasContent = !!(track || item);
          const isActive = isPlaying || playbackState !== 'STOPPED';
          
          // If we have content OR are playing, show the panel
          // If panel was visible, keep it visible (don't hide during transitions)
          if (hasContent || isActive || panelShouldBeVisible) {
            panelShouldBeVisible = true;
            clearTimeout(hidePanelTimeout);
            
            const groupInfo = latestGroups.find((g) => g.id === groupId || g.groupId === groupId);
            const groupName = groupInfo?.name || currentGroupName || 'Unknown Group';

            let playlistName = null;
            let playlistImageUrl = null;
            const activeFavoriteId = status.activeFavoriteId || currentActiveFavoriteId;
            if (activeFavoriteId) {
              const favoriteEntry = favoritesRegistry.get(activeFavoriteId);
              if (favoriteEntry && favoriteEntry.favorite) {
                playlistName = favoriteEntry.favorite.name || null;
                // Get playlist cover art
                const favorite = favoriteEntry.favorite;
                playlistImageUrl = favorite?.imageUrl
                  ? (typeof favorite.imageUrl === 'string' ? favorite.imageUrl : favorite.imageUrl?.url || favorite.imageUrl?.value || null)
                  : favorite?.images && favorite.images.length && favorite.images[0]?.url
                    ? favorite.images[0].url
                    : favorite?.container?.imageUrl
                      ? (typeof favorite.container.imageUrl === 'string' ? favorite.container.imageUrl : favorite.container.imageUrl?.url || favorite.container.imageUrl?.value || null)
                      : null;
              }
            }
            
            const title = track?.name || track?.title || item?.name || (isPlaying ? 'Loading...' : 'Unknown Track');
            
            let artist = '';
            if (track?.artist) {
              artist = typeof track.artist === 'string' ? track.artist : track.artist?.name || track.artist?.value || '';
            } else if (track?.albumArtist) {
              artist = typeof track.albumArtist === 'string' ? track.albumArtist : track.albumArtist?.name || track.albumArtist?.value || '';
            } else if (track?.creator) {
              artist = typeof track.creator === 'string' ? track.creator : track.creator?.name || track.creator?.value || '';
            }
            
            let album = '';
            if (track?.album) {
              album = typeof track.album === 'string' ? track.album : track.album?.name || track.album?.value || '';
            } else if (track?.albumName) {
              album = typeof track.albumName === 'string' ? track.albumName : track.albumName?.name || track.albumName?.value || '';
            }
            
            // Use playlist image instead of track image
            let imageUrl = playlistImageUrl;
            
            if (imageUrl && !imageUrl.startsWith('http')) {
              imageUrl = null;
            }

            currentlyPlayingTitle.textContent = title;
            currentlyPlayingArtist.innerHTML = '';
            if (artist) {
              const artistSpan = document.createElement('span');
              artistSpan.textContent = artist;
              currentlyPlayingArtist.appendChild(artistSpan);
            }
            if (album && artist) {
              const separator = document.createTextNode(' â€¢ ');
              currentlyPlayingArtist.appendChild(separator);
              const albumSpan = document.createElement('span');
              albumSpan.textContent = album;
              currentlyPlayingArtist.appendChild(albumSpan);
            }
            if (!artist && !album) {
              currentlyPlayingArtist.innerHTML = '<span>Sonos</span>';
            }

            currentlyPlayingLocation.innerHTML = `<span>${playlistName || groupName}</span>`;

            // Handle image loading - always proxy through server
            // Calculate the final URL we'll use (proxy URL if HTTP/HTTPS)
            let finalImageUrl = null;
            if (imageUrl) {
              if (imageUrl.startsWith('http://') || imageUrl.startsWith('https://')) {
                finalImageUrl = `/api/image-proxy?url=${encodeURIComponent(imageUrl)}`;
              } else {
                finalImageUrl = imageUrl;
              }
            }
            
            // Only update if the final URL has actually changed
            if (finalImageUrl && finalImageUrl !== currentImageUrl) {
              loadImage(finalImageUrl, imageUrl);
            } else if (!finalImageUrl) {
              // No image - only show placeholder if there's no image element
              if (!currentlyPlayingArt.querySelector('img')) {
                currentlyPlayingArt.innerHTML = '<span class="currently-playing-art-placeholder">â™ª</span>';
              }
            }
            
            function loadImage(url, originalUrl) {
              currentImageUrl = url;
              
              // Check if there's already an img element - if so, just update src
              const existingImg = currentlyPlayingArt.querySelector('img');
              if (existingImg) {
                existingImg.src = url;
                existingImg.alt = title;
                return;
              }
              
              // Otherwise create new img element
              const img = document.createElement('img');
              img.alt = title;
              img.loading = 'lazy';
              img.style.width = '100%';
              img.style.height = '100%';
              img.style.objectFit = 'cover';
              
              img.onerror = () => {
                currentlyPlayingArt.innerHTML = '<span class="currently-playing-art-placeholder">â™ª</span>';
                currentImageUrl = null;
              };
              
              currentlyPlayingArt.innerHTML = '';
              currentlyPlayingArt.appendChild(img);
              img.src = url;
            }

            const playerCount = latestPlayers.filter((p) => p.groupId === groupId).length;
            if (playerCount > 1) {
              currentlyPlayingGroupIndicator.style.display = 'grid';
              currentlyPlayingGroupCount.textContent = playerCount;
              currentlyPlayingGroupCount.style.display = 'grid';
            } else {
              currentlyPlayingGroupIndicator.style.display = 'none';
              currentlyPlayingGroupCount.style.display = 'none';
            }

            // Toggle play/pause icon for right-side button using CSS classes
            // When isPlaying is true, show pause icon (add .playing class)
            // When isPlaying is false, show play icon (remove .playing class)
            const hadPlayingClass = currentlyPlayingPlayBtn.classList.contains('playing');
            if (isPlaying) {
              currentlyPlayingPlayBtn.classList.add('playing');
            } else {
              currentlyPlayingPlayBtn.classList.remove('playing');
            }
            const hasPlayingClass = currentlyPlayingPlayBtn.classList.contains('playing');
            
            // Update playback controls in expanded section using CSS classes
            const hadExpandedPlayingClass = playbackPlayPauseBtn.classList.contains('playing');
            if (isPlaying) {
              playbackPlayPauseBtn.classList.add('playing');
            } else {
              playbackPlayPauseBtn.classList.remove('playing');
            }
            const hasExpandedPlayingClass = playbackPlayPauseBtn.classList.contains('playing');
            
            // DEBUG: Button state updates
            console.log('[PlayPause] Button updates:', {
              isPlaying,
              playbackState,
              rightButton: {
                exists: !!currentlyPlayingPlayBtn,
                hadPlaying: hadPlayingClass,
                hasPlaying: hasPlayingClass,
                classList: Array.from(currentlyPlayingPlayBtn.classList)
              },
              expandedButton: {
                exists: !!playbackPlayPauseBtn,
                hadPlaying: hadExpandedPlayingClass,
                hasPlaying: hasExpandedPlayingClass,
                classList: Array.from(playbackPlayPauseBtn.classList)
              }
            });

            // Update master volume from group volume
            const groupVolume = status.volume || 0;
            masterVolumeSlider.value = groupVolume;
            masterVolumeValue.textContent = `${groupVolume}%`;

            updateCurrentlyPlayingRooms(groupId);

            currentlyPlayingPanel.classList.add('visible');
            document.body.classList.add('has-playing');
          } else {
            // Only hide if we're truly stopped - use a delay to prevent flickering
            if (playbackState === 'STOPPED' && !isPlaying) {
              clearTimeout(hidePanelTimeout);
              hidePanelTimeout = setTimeout(() => {
                if (!panelShouldBeVisible) {
                  currentlyPlayingPanel.classList.remove('visible');
                  document.body.classList.remove('has-playing');
                  currentImageUrl = null;
                }
              }, 2000); // Wait 2 seconds before hiding
            }
          }
        } catch (error) {
          console.error('Failed to update currently playing:', error);
          currentlyPlayingPanel.classList.remove('visible');
          document.body.classList.remove('has-playing');
        }
      }

      function updateCurrentlyPlayingRooms(groupId) {
        if (!groupId || !latestPlayers.length) {
          currentlyPlayingRoomsList.innerHTML = '';
          return;
        }

        // Since we're auto-grouping all players, show all players
        // The groupId format is "RINCON_XXX:PORT" where RINCON_XXX is the coordinator
        // We'll show all players since they're all in the same auto-created group
        const groupPlayers = latestPlayers;
        
        currentlyPlayingRoomsList.innerHTML = '';

        groupPlayers.forEach((player) => {
          const roomRow = document.createElement('div');
          roomRow.className = 'currently-playing-room-volume';
          roomRow.dataset.playerId = player.id;

          const name = document.createElement('span');
          name.className = 'currently-playing-room-name';
          name.textContent = player.name || player.id || 'Room';

          const slider = document.createElement('input');
          slider.type = 'range';
          slider.className = 'currently-playing-room-slider';
          slider.min = '0';
          slider.max = '100';
          slider.value = Number.isFinite(Number(player.volume)) ? Number(player.volume) : 0;

          const value = document.createElement('span');
          value.className = 'currently-playing-room-value';
          value.textContent = `${slider.value}`;

          slider.addEventListener('input', (e) => {
            e.stopPropagation();
            value.textContent = e.target.value;
          });

          slider.addEventListener('change', async (e) => {
            e.stopPropagation();
            const playerId = roomRow.dataset.playerId;
            if (playerId) {
              await setPlayerVolume(playerId, Number(e.target.value));
            }
          });

          // Prevent panel from closing when interacting with slider
          slider.addEventListener('pointerdown', (e) => {
            e.stopPropagation();
          });
          slider.addEventListener('mousedown', (e) => {
            e.stopPropagation();
          });
          slider.addEventListener('touchstart', (e) => {
            e.stopPropagation();
          });
          slider.addEventListener('touchmove', (e) => {
            e.stopPropagation();
          });
          slider.addEventListener('touchend', (e) => {
            e.stopPropagation();
          });

          roomRow.appendChild(name);
          roomRow.appendChild(slider);
          roomRow.appendChild(value);
          currentlyPlayingRoomsList.appendChild(roomRow);
        });
        
      }

      function startPlaybackRefresh() {
        clearInterval(playbackRefreshTimer);
        playbackRefreshTimer = setInterval(() => {
          if (isSonosConnected && getSelectedGroupId()) {
            updateCurrentlyPlaying();
          }
        }, 3000);
        updateCurrentlyPlaying();
      }
      
      function stopPlaybackRefresh() {
        clearInterval(playbackRefreshTimer);
        playbackRefreshTimer = null;
      }


      // Use event delegation on the panel itself - simpler and more reliable
      currentlyPlayingPanel.addEventListener('click', (e) => {
        // Don't toggle if clicking on interactive elements
        const playBtn = e.target.closest('.currently-playing-play-btn');
        const roomVolume = e.target.closest('.currently-playing-room-volume');
        const roomSlider = e.target.closest('.currently-playing-room-slider');
        const rangeInput = e.target.closest('input[type="range"]');
        const playbackControls = e.target.closest('.currently-playing-playback-controls');
        const playbackControlBtn = e.target.closest('.playback-control-btn');
        const masterVolume = e.target.closest('.currently-playing-master-volume');
        
        if (playBtn || roomVolume || roomSlider || rangeInput || playbackControls || playbackControlBtn || masterVolume) {
          return;
        }
        
        // Toggle expanded state
        currentlyPlayingPanel.classList.toggle('expanded');
        
        // Update rooms when expanding (in case they weren't loaded yet)
        if (currentlyPlayingPanel.classList.contains('expanded')) {
          const groupId = getSelectedGroupId();
          if (groupId) {
            updateCurrentlyPlayingRooms(groupId);
          }
        }
      });

      // Close panel when clicking outside of it
      document.addEventListener('click', (e) => {
        if (!currentlyPlayingPanel.classList.contains('visible')) {
          return;
        }
        
        // If click is outside the panel, close it
        if (!currentlyPlayingPanel.contains(e.target)) {
          currentlyPlayingPanel.classList.remove('expanded');
        }
      });

      // Close panel when scrolling starts (only if scroll is outside the panel)
      let isScrolling = false;
      document.addEventListener('scroll', (e) => {
        if (!currentlyPlayingPanel.classList.contains('visible') || !currentlyPlayingPanel.classList.contains('expanded')) {
          return;
        }
        
        // Check if the scroll event originated from within the panel
        const target = e.target;
        if (target && currentlyPlayingPanel.contains(target)) {
          return; // Don't close if scrolling within the panel
        }
        
        // Check if the scroll happened on the document/body (outside the panel)
        if (target === document || target === document.body || target === document.documentElement) {
          // Close immediately when scrolling starts outside the panel
          if (!isScrolling) {
            isScrolling = true;
            currentlyPlayingPanel.classList.remove('expanded');
          }
        }
      }, { passive: true, capture: true });

      // Close panel on touchmove (mobile scrolling) - only if touch is outside the panel
      document.addEventListener('touchmove', (e) => {
        if (!currentlyPlayingPanel.classList.contains('visible') || !currentlyPlayingPanel.classList.contains('expanded')) {
          return;
        }
        
        // Check if the touch event originated from within the panel
        const target = e.target;
        if (target && currentlyPlayingPanel.contains(target)) {
          return; // Don't close if touching/swiping within the panel
        }
        
        // Only close if touch is outside the panel
        currentlyPlayingPanel.classList.remove('expanded');
      }, { passive: true, capture: true });

      // Reset scrolling flag when scroll ends
      let scrollEndTimeout = null;
      document.addEventListener('scroll', () => {
        clearTimeout(scrollEndTimeout);
        scrollEndTimeout = setTimeout(() => {
          isScrolling = false;
        }, 150);
      }, { passive: true });

      currentlyPlayingPlayBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const groupId = getSelectedGroupId();
        if (!groupId) {
          return;
        }
        
        const wasPlaying = currentlyPlayingPlayBtn.classList.contains('playing');
        currentlyPlayingPlayBtn.disabled = true;
        
        try {
          await handlePlaybackAction('playpause');
          setTimeout(() => {
            updateCurrentlyPlaying();
            currentlyPlayingPlayBtn.disabled = false;
          }, 600);
        } catch (error) {
          console.error('Playback toggle failed:', error);
          currentlyPlayingPlayBtn.disabled = false;
          setTimeout(() => updateCurrentlyPlaying(), 500);
        }
      });

      function setActiveGroup(groupId, name, { refreshFavorites = false } = {}) {
        currentGroupId = groupId || null;
        currentGroupName = currentGroupId ? name || currentGroupName || 'Group' : 'No group selected';
        updateActiveGroupDisplay();
        evaluateFavoritesAvailability();
        if (refreshFavorites && currentHouseholdId) {
          loadFavorites(currentHouseholdId).catch((error) => {
            console.error('Failed to refresh favorites', error);
          });
        }
        if (groupId) {
          startPlaybackRefresh();
        } else {
          stopPlaybackRefresh();
        }
      }

      window.addEventListener('load', () => {
        applyAuthFeedback();
        checkAuthAndInit();
      });
    </script>


  </body>
</html>
