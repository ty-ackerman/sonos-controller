<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
    <title>Sonos Controller</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3ClinearGradient id='wood' x1='0' y1='0' x2='0' y2='100'%3E%3Cstop offset='0' stop-color='%23d4a574'/%3E%3Cstop offset='1' stop-color='%23c8956a'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect fill='url(%23wood)' width='100' height='100'/%3E%3Crect fill='%23a67c52' x='0' y='0' width='100' height='15'/%3E%3Crect fill='%23a67c52' x='0' y='20' width='15' height='60'/%3E%3Crect fill='%23a67c52' x='85' y='20' width='15' height='60'/%3E%3Crect fill='%238b6f47' x='20' y='40' width='60' height='15'/%3E%3Crect fill='%238b6f47' x='20' y='60' width='60' height='15'/%3E%3Crect fill='%23404040' x='70' y='70' width='20' height='20' rx='2'/%3E%3Ccircle fill='%23ffd700' cx='85' cy='15' r='6'/%3E%3Cpath fill='%23ffffff' opacity='0.7' d='M25 25 Q35 15 45 25 T65 25'/%3E%3Cpath fill='%23ffffff' opacity='0.5' d='M20 30 Q30 20 40 30 T60 30'/%3E%3C/svg%3E" />
    
    <!-- Apple Touch Icon (for iOS Home Screen) -->
    <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3ClinearGradient id='wood' x1='0' y1='0' x2='0' y2='100'%3E%3Cstop offset='0' stop-color='%23d4a574'/%3E%3Cstop offset='1' stop-color='%23c8956a'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect fill='url(%23wood)' width='100' height='100'/%3E%3Crect fill='%23a67c52' x='0' y='0' width='100' height='15'/%3E%3Crect fill='%23a67c52' x='0' y='20' width='15' height='60'/%3E%3Crect fill='%23a67c52' x='85' y='20' width='15' height='60'/%3E%3Crect fill='%238b6f47' x='20' y='40' width='60' height='15'/%3E%3Crect fill='%238b6f47' x='20' y='60' width='60' height='15'/%3E%3Crect fill='%23404040' x='70' y='70' width='20' height='20' rx='2'/%3E%3Ccircle fill='%23ffd700' cx='85' cy='15' r='6'/%3E%3Cpath fill='%23ffffff' opacity='0.7' d='M25 25 Q35 15 45 25 T65 25'/%3E%3Cpath fill='%23ffffff' opacity='0.5' d='M20 30 Q30 20 40 30 T60 30'/%3E%3C/svg%3E" />
    
    <!-- Open Graph / Social Sharing -->
    <meta property="og:image" content="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3ClinearGradient id='wood' x1='0' y1='0' x2='0' y2='100'%3E%3Cstop offset='0' stop-color='%23d4a574'/%3E%3Cstop offset='1' stop-color='%23c8956a'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect fill='url(%23wood)' width='100' height='100'/%3E%3Crect fill='%23a67c52' x='0' y='0' width='100' height='15'/%3E%3Crect fill='%23a67c52' x='0' y='20' width='15' height='60'/%3E%3Crect fill='%23a67c52' x='85' y='20' width='15' height='60'/%3E%3Crect fill='%238b6f47' x='20' y='40' width='60' height='15'/%3E%3Crect fill='%238b6f47' x='20' y='60' width='60' height='15'/%3E%3Crect fill='%23404040' x='70' y='70' width='20' height='20' rx='2'/%3E%3Ccircle fill='%23ffd700' cx='85' cy='15' r='6'/%3E%3Cpath fill='%23ffffff' opacity='0.7' d='M25 25 Q35 15 45 25 T65 25'/%3E%3Cpath fill='%23ffffff' opacity='0.5' d='M20 30 Q30 20 40 30 T60 30'/%3E%3C/svg%3E" />
    <meta property="og:title" content="Sonos Controller" />
    <meta property="og:type" content="website" />
    
    <!-- Web App Manifest -->
    <link rel="manifest" href="/manifest.json" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="apple-mobile-web-app-title" content="Sonos Controller" />
    
    <!-- Google Fonts - Montserrat -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
      :root {
        color-scheme: light dark;
        font-family: 'Montserrat', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
        --bg-primary: #ffffff;
        --bg-secondary: #f8f9fa;
        --bg-tertiary: #f1f3f5;
        --text-primary: #1a1a1a;
        --text-secondary: #6b7280;
        --text-tertiary: #9ca3af;
        --border-color: #e5e7eb;
        --accent: #000000;
        --accent-hover: #1a1a1a;
        --success: #10b981;
        --error: #ef4444;
        --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      }

      @media (prefers-color-scheme: dark) {
        :root {
          --bg-primary: #0a0a0a;
          --bg-secondary: #141414;
          --bg-tertiary: #1a1a1a;
          --text-primary: #fafafa;
          --text-secondary: #a1a1aa;
          --text-tertiary: #71717a;
          --border-color: #27272a;
          --accent: #ffffff;
          --accent-hover: #f4f4f5;
        }
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        background: var(--bg-secondary);
        color: var(--text-primary);
        min-height: 100vh;
        display: flex;
        align-items: stretch;
        justify-content: center;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .container {
        width: min(480px, 100vw);
        padding: 12px 20px 20px 20px;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .header-wrapper {
        position: sticky;
        top: 0;
        z-index: 50;
        background: var(--bg-secondary);
        margin: -20px -20px 0 -20px;
        padding: 12px 20px;
        border-bottom: 1px solid var(--border-color);
        box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
      }

      .header-container {
        display: grid;
        grid-template-columns: 40px 1fr 40px;
        align-items: center;
        gap: 12px;
      }

      .hamburger-menu-btn {
        width: 40px;
        height: 40px;
        border: none;
        background: transparent;
        color: var(--text-primary);
        cursor: pointer;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        gap: 5px;
        padding: 8px;
        border-radius: 8px;
        transition: background 0.2s ease;
      }


      .hamburger-menu-btn span {
        display: block;
        width: 20px;
        height: 2px;
        background: currentColor;
        border-radius: 1px;
        transition: all 0.3s ease;
      }

      h1 {
        font-size: 1.5rem;
        font-weight: 600;
        margin: 0;
        grid-column: 2;
        text-align: center;
        letter-spacing: -0.02em;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
      }

      h1 .sonos-logo-header {
        height: 1.25rem;
        width: auto;
        display: block;
        filter: brightness(0);
      }

      @media (prefers-color-scheme: dark) {
        h1 .sonos-logo-header {
          filter: brightness(0) invert(1);
        }
      }

      h1 .controller-text {
        font-family: 'Montserrat', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
        font-weight: 400;
        letter-spacing: normal;
      }

      .household-title {
        font-size: 1.125rem;
        font-weight: 600;
        margin: 8px 0;
        text-align: center;
        color: var(--text-primary);
        min-height: 1.5rem;
      }

      p.status {
        display: none;
        margin: 0;
        text-align: center;
        font-weight: 500;
        font-size: 0.875rem;
      }

      p.status.connected {
        color: var(--success);
      }

      p.status.disconnected {
        color: var(--error);
      }

      .feedback {
        min-height: 1.25rem;
        text-align: center;
        font-size: 0.875rem;
        color: var(--text-secondary);
      }

      .feedback.error {
        color: var(--error);
      }

      /* Loading Overlay */
      .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: var(--bg-primary);
        z-index: 9999;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 1;
        transition: opacity 0.4s ease;
      }

      .loading-overlay.hidden {
        opacity: 0;
        pointer-events: none;
      }

      .loading-content {
        text-align: center;
      }

      .loading-text {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
      }

      .loading-text .alter-logo {
        height: 4rem;
        width: auto;
        display: block;
      }

      .loading-text .loading-x {
        font-size: 1.75rem;
        font-weight: 400;
        color: var(--text-secondary);
        font-family: 'Montserrat', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
        line-height: 1;
        min-height: 1.75rem;
        display: block;
        text-align: center;
        width: 100%;
        padding-bottom: 10px;
      }

      .loading-text .sonos-logo {
        height: 2rem;
        width: auto;
        display: block;
        filter: brightness(0);
      }

      @media (prefers-color-scheme: dark) {
        .loading-text .sonos-logo {
          filter: brightness(0) invert(1);
        }
      }

      .loading-text .alter-logo-light {
        display: block;
      }

      .loading-text .alter-logo-dark {
        display: none;
      }

      @media (prefers-color-scheme: dark) {
        .loading-text .alter-logo-light {
          display: none;
        }

        .loading-text .alter-logo-dark {
          display: block;
        }
      }


      /* Toast Notification */
      .toast {
        position: fixed;
        top: 64px; /* Position below header (40px button + 12px top padding + 12px bottom padding) */
        left: 50%;
        transform: translateX(-50%) translateY(-100%);
        z-index: 100; /* Below loading overlay (9999) but above content */
        width: min(480px, 100vw);
        padding: 12px 20px;
        background: var(--bg-primary);
        border-bottom: 1px solid var(--border-color);
        box-shadow: var(--shadow-md);
        transition: transform 0.3s ease;
      }

      .toast.show {
        transform: translateX(-50%) translateY(0);
      }

      .toast.hidden {
        transform: translateX(-50%) translateY(-100%);
      }

      .toast-content {
        text-align: center;
        font-size: 0.875rem;
        font-weight: 500;
        color: var(--text-primary);
      }

      section {
        background: var(--bg-primary);
        border-radius: 16px;
        padding: 20px;
        border: 1px solid var(--border-color);
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      label {
        font-size: 0.8125rem;
        font-weight: 500;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.05em;
        margin-bottom: 8px;
        display: block;
      }

      select {
        width: 100%;
        padding: 12px 16px;
        border-radius: 10px;
        border: 1px solid var(--border-color);
        background: var(--bg-primary);
        color: var(--text-primary);
        font-size: 0.9375rem;
        font-weight: 500;
        appearance: none;
        cursor: pointer;
        transition: border-color 0.2s ease;
      }


      button {
        border: none;
        border-radius: 10px;
        padding: 12px 20px;
        font-size: 0.9375rem;
        font-weight: 500;
        background: var(--accent);
        color: var(--bg-primary);
        cursor: pointer;
        transition: all 0.2s ease;
      }



      button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }

      button.secondary {
        background: var(--bg-tertiary);
        color: var(--text-primary);
      }


      .controls,
      .volume {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .control-buttons {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
      }

      .control-buttons button {
        padding: 14px 12px;
        font-size: 0.875rem;
      }

      .control-buttons button:first-child {
        grid-column: 1 / -1;
        padding: 16px;
        font-size: 0.9375rem;
      }

      .slider-row {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      input[type='range'] {
        width: 100%;
        height: 6px;
        accent-color: var(--accent);
        cursor: pointer;
      }

      .volume-value {
        min-width: 3.5rem;
        text-align: right;
        font-variant-numeric: tabular-nums;
        font-size: 0.875rem;
        font-weight: 500;
        color: var(--text-secondary);
      }

      .group-chip {
        display: inline-flex;
        align-items: center;
        padding: 10px 16px;
        border-radius: 10px;
        border: 1px solid var(--border-color);
        background: var(--bg-tertiary);
        font-size: 0.875rem;
        font-weight: 500;
        min-width: 140px;
        justify-content: center;
        color: var(--text-primary);
      }

      .settings-row {
        display: grid;
        grid-template-columns: 1fr auto auto;
        gap: 12px;
        align-items: center;
        margin-bottom: 12px;
        background: var(--bg-secondary);
        padding: 16px;
        border-radius: 12px;
        border: 1px solid var(--border-color);
      }

      .favorites {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .vibe-filters {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
        margin-bottom: 4px;
      }

      .vibe-filter-btn {
        padding: 8px 16px;
        border-radius: 8px;
        border: 1px solid var(--border-color);
        background: var(--bg-secondary);
        color: var(--text-secondary);
        font-size: 0.8125rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .vibe-filter-btn.active {
        background: var(--bg-tertiary);
        color: var(--text-primary);
        border-color: var(--border-color);
      }

      .vibe-filter-btn.active.down {
        background: #ffffff;
        color: #000000;
        border-color: #ffffff;
      }

      .vibe-filter-btn.active.down-mid {
        background: #808080;
        color: #ffffff;
        border-color: #808080;
      }

      .vibe-filter-btn.active.mid {
        background: #000000;
        color: #ffffff;
        border-color: #000000;
      }



      .favorites-grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
      }

      .favorites-status {
        font-size: 0.875rem;
        color: var(--text-secondary);
      }

      .section-title {
        font-size: 0.9375rem;
        font-weight: 600;
        letter-spacing: -0.01em;
        color: var(--text-primary);
      }

      .playlist-card {
        display: flex;
        flex-direction: column;
        gap: 14px;
        padding: 16px;
        border-radius: 12px;
        border: 1px solid var(--border-color);
        background: var(--bg-primary);
        color: inherit;
        text-align: left;
        box-shadow: var(--shadow-sm);
        transition: all 0.2s ease;
        cursor: pointer;
        position: relative;
      }


      .playlist-card-content {
        display: flex;
        align-items: center;
        gap: 14px;
      }


      .playlist-card.disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .playlist-card.loading {
        cursor: progress;
      }


      .playlist-art-wrapper {
        width: 60px;
        height: 60px;
        border-radius: 10px;
        overflow: hidden;
        flex-shrink: 0;
        background: var(--bg-tertiary);
        display: grid;
        place-items: center;
        box-shadow: var(--shadow-sm);
      }

      .playlist-art {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .playlist-meta {
        display: flex;
        flex-direction: column;
        gap: 6px;
        align-items: flex-start;
        flex: 1;
        min-width: 0;
      }

      .playlist-placeholder {
        font-size: 1.5rem;
        color: var(--text-tertiary);
      }

      .playlist-brand {
        display: none;
      }

      .playlist-brand svg {
        width: 14px;
        height: 14px;
        fill: currentColor;
      }

      .playlist-name {
        font-size: 1rem;
        font-weight: 600;
        color: var(--text-primary);
        line-height: 1.4;
        overflow: hidden;
        text-overflow: ellipsis;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        line-clamp: 2;
        -webkit-box-orient: vertical;
      }

      .playlist-name-row {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
      }

      .playlist-vibe-badge-inline {
        display: inline-flex;
        align-items: center;
        padding: 3px 8px;
        border-radius: 10px;
        background: var(--bg-tertiary);
        color: var(--text-primary);
        font-size: 0.75rem;
        font-weight: 500;
        border: 1px solid var(--border-color);
        flex-shrink: 0;
      }

      .playlist-vibe-badge-inline.down {
        background: #ffffff;
        color: #000000;
      }

      .playlist-vibe-badge-inline.down-mid {
        background: #808080;
        color: #ffffff;
      }

      .playlist-vibe-badge-inline.mid {
        background: #000000;
        color: #ffffff;
      }

      .playlist-status {
        font-size: 0.8125rem;
        color: var(--text-secondary);
        opacity: 0.7;
      }

      .playlist-card.active {
        border-color: var(--success);
        background: var(--bg-primary);
      }

      .playlist-card.active::after {
        content: '';
        position: absolute;
        top: 12px;
        right: 12px;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: var(--success);
      }

      /* Hide vibe selector and actions only on favorites (controls page) */
      #panel-control .playlist-vibe-selector {
        display: none;
      }

      #panel-control .playlist-card-actions {
        display: none;
      }

      /* Show vibe selector and actions on playlist management page */
      #panel-playlist-management .playlist-vibe-selector {
        display: none;
      }

      #panel-playlist-management .playlist-meta {
        gap: 8px;
      }

      #panel-playlist-management .playlist-card {
        gap: 12px;
      }

      #panel-playlist-management .playlist-name-row {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
      }

      #panel-playlist-management .playlist-vibe-select {
        display: inline-flex;
        align-items: center;
        padding: 4px 24px 4px 10px;
        border-radius: 10px;
        background: var(--bg-tertiary);
        color: var(--text-primary);
        font-size: 0.75rem;
        font-weight: 500;
        border: 1px solid var(--border-color);
        cursor: pointer;
        transition: all 0.2s ease;
        appearance: none;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23999' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 6px center;
        background-size: 10px;
        min-width: 80px;
      }

      #panel-playlist-management .playlist-vibe-select:hover {
        border-color: var(--accent);
        background-color: var(--bg-secondary);
      }

      #panel-playlist-management .playlist-vibe-select.down {
        background-color: #ffffff;
        color: #000000;
        border-color: #ffffff;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23333' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
      }

      #panel-playlist-management .playlist-vibe-select.down-mid {
        background-color: #808080;
        color: #ffffff;
        border-color: #808080;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23fff' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
      }

      #panel-playlist-management .playlist-vibe-select.mid {
        background-color: #000000;
        color: #ffffff;
        border-color: #000000;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23fff' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
      }

      #panel-playlist-management .playlist-card-actions {
        display: flex;
        justify-content: flex-end;
        padding-top: 0;
        margin-top: 0;
        gap: 8px;
      }

      /* Remove button removed - no longer needed */
      .playlist-card-remove-btn {
        display: none !important;
      }

      .playlist-card-actions button.delete {
        padding: 8px 16px;
        border-radius: 8px;
        border: 1px solid var(--border-color);
        background: var(--bg-primary);
        color: var(--error);
        font-size: 0.8125rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .playlist-card-actions button.delete:hover {
        background: var(--error);
        color: var(--bg-primary);
        border-color: var(--error);
      }

      #panel-playlist-management .playlist-card-actions button.hide {
        padding: 6px 12px;
        border-radius: 6px;
        border: 1px solid var(--border-color);
        background: transparent;
        color: var(--text-secondary);
        font-size: 0.75rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      #panel-playlist-management .playlist-card-actions button.hide:hover {
        background: var(--bg-secondary);
        color: var(--text-primary);
        border-color: var(--border-color);
      }

      #panel-playlist-management .playlist-card-actions button.show {
        padding: 6px 12px;
        border-radius: 6px;
        border: 1px solid var(--accent);
        background: transparent;
        color: var(--accent);
        font-size: 0.75rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      #panel-playlist-management .playlist-card-actions button.show:hover {
        background: var(--accent);
        color: var(--bg-primary);
      }

      .playlist-vibe-pill {
        display: inline-flex;
        align-items: center;
        padding: 4px 10px;
        border-radius: 12px;
        font-size: 0.75rem;
        font-weight: 500;
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }

      .playlist-vibe-pill.down {
        background: #ffffff;
        color: #000000;
        border: 1px solid var(--border-color);
      }

      .playlist-vibe-pill.down-mid {
        background: #808080;
        color: #ffffff;
      }

      .playlist-vibe-pill.mid {
        background: #000000;
        color: #ffffff;
      }

      .favorites-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 12px;
      }

      .favorites-toggle {
        padding: 6px 12px;
        border-radius: 6px;
        border: 1px solid var(--border-color);
        background: var(--bg-secondary);
        color: var(--text-primary);
        font-size: 0.875rem;
        cursor: pointer;
        text-align: left;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        transition: all 0.2s ease;
      }

      .favorites-toggle:hover {
        background: var(--bg-tertiary);
      }

      .favorites-content {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .favorites-content.hidden {
        display: none;
      }


      .settings-actions {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-top: 8px;
        flex-wrap: wrap;
      }

      .settings-status {
        min-height: 1.2rem;
        font-size: 0.875rem;
        color: var(--text-secondary);
      }

      .rooms {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .room-card {
        display: flex;
        flex-direction: column;
        gap: 14px;
        padding: 16px;
        border-radius: 12px;
        background: var(--bg-primary);
        border: 1px solid var(--border-color);
        cursor: pointer;
        transition: all 0.2s ease;
      }



      .room-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      .room-name {
        font-weight: 500;
        font-size: 0.9375rem;
        color: var(--text-primary);
      }

      .room-group-label {
        font-size: 0.8125rem;
        color: var(--text-secondary);
        font-weight: 400;
      }

      .room-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .room-actions button {
        font-size: 0.8125rem;
        padding: 8px 14px;
        border-radius: 8px;
        background: var(--bg-tertiary);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
      }


      .volume-row {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .volume-row span {
        font-size: 0.875rem;
        min-width: 56px;
        font-weight: 500;
        color: var(--text-secondary);
      }

      .hidden {
        display: none !important;
      }

      #auth-bar {
        display: flex;
        gap: 8px;
        margin-bottom: 8px;
      }

      #auth-bar button {
        flex: 1;
      }

      .select-group {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .currently-playing {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: var(--bg-primary);
        border-top: 1px solid var(--border-color);
        padding: 12px 16px 24px 16px;
        display: none;
        z-index: 50;
        box-shadow: 0 -4px 6px -1px rgba(0, 0, 0, 0.1);
        max-height: 100vh;
        overflow-y: auto;
        transition: transform 0.3s ease-out;
        transform: translateY(0);
      }

      .currently-playing.visible {
        display: block;
      }

      .currently-playing.expanded {
        transform: translateY(0);
      }

      .currently-playing-content {
        max-width: 480px;
        margin: 0 auto;
        display: flex;
        align-items: center;
        gap: 12px;
        cursor: pointer;
      }


      .currently-playing-art {
        width: 56px;
        height: 56px;
        border-radius: 8px;
        overflow: hidden;
        flex-shrink: 0;
        background: var(--bg-tertiary);
        display: grid;
        place-items: center;
      }

      .currently-playing-art img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .currently-playing-art-placeholder {
        font-size: 1.25rem;
        color: var(--text-tertiary);
      }

      .currently-playing-info {
        flex: 1;
        min-width: 0;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .currently-playing-location {
        font-size: 0.75rem;
        color: var(--text-secondary);
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 4px;
      }

      .currently-playing-title {
        font-size: 0.9375rem;
        font-weight: 600;
        color: var(--text-primary);
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .currently-playing-artist {
        font-size: 0.8125rem;
        color: var(--text-secondary);
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .currently-playing-loudness {
        font-size: 0.75rem;
        color: var(--text-secondary);
        margin-top: 4px;
        display: flex;
        align-items: center;
        gap: 4px;
      }

      .currently-playing-loudness .loudness-label {
        opacity: 0.8;
      }

      .currently-playing-controls {
        display: flex;
        align-items: center;
        gap: 12px;
        flex-shrink: 0;
      }

      .currently-playing-group-indicator {
        width: 32px;
        height: 32px;
        border-radius: 6px;
        background: var(--bg-tertiary);
        border: 1px solid var(--border-color);
        display: grid;
        place-items: center;
        font-size: 0.75rem;
        font-weight: 600;
        color: var(--text-primary);
        position: relative;
      }

      .currently-playing-group-count {
        position: absolute;
        top: -4px;
        right: -4px;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: var(--accent);
        color: var(--bg-primary);
        font-size: 0.625rem;
        font-weight: 600;
        display: grid;
        place-items: center;
      }


      .currently-playing-volume {
        flex-direction: column;
        gap: 12px;
        margin-top: 0;
        padding: 0 16px;
        padding-top: 0;
        padding-bottom: 0;
        border-top: none;
        max-height: 0;
        overflow: hidden;
        opacity: 0;
        transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1), 
                    padding 0.4s cubic-bezier(0.4, 0, 0.2, 1), 
                    margin 0.4s cubic-bezier(0.4, 0, 0.2, 1), 
                    opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                    border-top 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .currently-playing.expanded .currently-playing-volume {
        margin-top: 12px;
        padding-top: 16px;
        padding-bottom: 8px;
        border-top: 1px solid var(--border-color);
        max-height: 500px;
        opacity: 1;
      }

      .currently-playing-room-volume {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px 0;
        min-height: 44px;
        border-top: 1px solid var(--border-color);
      }

      .currently-playing-room-volume:first-of-type {
        border-top: none;
      }

      .currently-playing-room-name {
        min-width: 100px;
        font-size: 0.875rem;
        font-weight: 500;
        color: var(--text-primary);
      }

      .currently-playing-room-slider {
        flex: 1;
        height: 4px;
        accent-color: var(--accent);
        cursor: pointer;
      }

      .currently-playing-room-value {
        min-width: 2.5rem;
        text-align: right;
        font-size: 0.8125rem;
        font-weight: 500;
        color: var(--text-secondary);
        font-variant-numeric: tabular-nums;
      }

      body {
        padding-bottom: 0;
      }

      body.has-playing {
        padding-bottom: 100px;
      }

      body.menu-open {
        overflow: hidden;
      }

      .menu-backdrop {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 998;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease;
      }

      .menu-backdrop.visible {
        opacity: 1;
        visibility: visible;
      }

      .menu-panel {
        position: fixed;
        top: 0;
        left: 0;
        bottom: 0;
        width: min(280px, 80vw);
        max-width: 280px;
        background: var(--bg-primary);
        border-right: 1px solid var(--border-color);
        z-index: 999;
        transform: translateX(-100%);
        transition: transform 0.3s ease;
        display: flex;
        flex-direction: column;
        box-shadow: var(--shadow-lg);
        touch-action: pan-y;
      }

      .menu-panel.open {
        transform: translateX(0);
      }

      .menu-panel.dragging {
        transition: none;
      }

      .menu-header {
        padding: 20px;
        border-bottom: 1px solid var(--border-color);
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .menu-title {
        font-size: 1.125rem;
        font-weight: 600;
        color: var(--text-primary);
      }

      .menu-close-btn {
        width: 32px;
        height: 32px;
        border: none;
        background: transparent;
        color: var(--text-primary);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 6px;
        transition: background 0.2s ease;
      }


      .menu-items {
        flex: 1;
        padding: 12px 0;
        overflow-y: auto;
      }

      .menu-item {
        display: block;
        width: 100%;
        padding: 14px 20px;
        border: none;
        background: transparent;
        color: var(--text-primary);
        text-align: left;
        font-size: 0.9375rem;
        font-weight: 500;
        cursor: pointer;
        transition: background 0.2s ease;
      }



      .menu-signout {
        margin-top: auto;
        padding: 12px 0;
        border-top: 1px solid var(--border-color);
      }

      .menu-signout .menu-item {
        color: var(--error);
      }




      .currently-playing-master-volume {
        display: flex;
        flex-direction: column;
        gap: 12px;
        margin-bottom: 12px;
      }

      .master-volume-label {
        font-size: 0.875rem;
        font-weight: 600;
        color: var(--text-primary);
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }

      .master-volume-row {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .master-volume-slider {
        flex: 1;
        height: 4px;
        accent-color: var(--accent);
        cursor: pointer;
      }

      .master-volume-value {
        min-width: 2.5rem;
        text-align: right;
        font-size: 0.875rem;
        font-weight: 500;
        color: var(--text-secondary);
        font-variant-numeric: tabular-nums;
      }

      .playlist-management-section {
        margin-bottom: 32px;
      }

      .time-rules-section {
        margin-top: 32px;
        padding-top: 32px;
        border-top: 1px solid var(--border-color);
      }

      .base-schedule-section {
        margin-bottom: 32px;
        padding-bottom: 24px;
        border-bottom: 1px solid var(--border-color);
      }

      .day-overrides-section {
        margin-top: 24px;
      }

      .subsection-title {
        font-size: 1.125rem;
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: 8px;
        margin-top: 0;
      }

      .time-rules-list,
      .base-schedule-list,
      .day-overrides-list {
        display: flex;
        flex-direction: column;
        gap: 12px;
        margin-bottom: 16px;
      }

      .override-day-group {
        margin-bottom: 20px;
      }

      .override-day-header {
        font-size: 0.9375rem;
        font-weight: 600;
        color: var(--text-secondary);
        margin-bottom: 12px;
        margin-top: 0;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .time-rule-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 16px;
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        gap: 12px;
      }

      .time-rule-name {
        font-size: 0.9375rem;
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: 4px;
      }

      .time-rule-info {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .time-rule-time {
        font-size: 0.9375rem;
        font-weight: 500;
        color: var(--text-primary);
      }

      .time-rule-vibes {
        font-size: 0.8125rem;
        color: var(--text-secondary);
      }

      .time-rule-actions {
        display: flex;
        gap: 8px;
      }

      .time-rule-actions button {
        padding: 6px 12px;
        border-radius: 6px;
        border: 1px solid var(--border-color);
        background: var(--bg-tertiary);
        color: var(--text-primary);
        font-size: 0.8125rem;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .time-rule-actions button:hover {
        background: var(--bg-primary);
      }

      .time-rule-actions button.delete {
        color: var(--error);
      }

      .time-rule-actions button.delete:hover {
        background: var(--error);
        color: var(--bg-primary);
      }

      .add-rule-btn {
        padding: 10px 16px;
        border-radius: 8px;
        border: 1px solid var(--border-color);
        background: var(--accent);
        color: var(--bg-primary);
        font-size: 0.875rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .add-rule-btn:hover {
        background: var(--accent-hover);
      }

      .time-rule-editor-backdrop {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 1000;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
      }

      .time-rule-editor-backdrop.visible {
        opacity: 1;
        visibility: visible;
      }

      .time-rule-editor {
        position: relative;
        width: 100%;
        max-width: 500px;
        max-height: 90vh;
        overflow-y: auto;
        padding: 24px;
        background: var(--bg-primary);
        border: 1px solid var(--border-color);
        border-radius: 12px;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        transform: scale(0.95);
        transition: transform 0.3s ease;
      }

      .time-rule-editor-backdrop.visible .time-rule-editor {
        transform: scale(1);
      }

      .time-rule-editor-close {
        position: absolute;
        top: 16px;
        right: 16px;
        width: 32px;
        height: 32px;
        border: none;
        background: transparent;
        color: var(--text-primary);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 6px;
        transition: background 0.2s ease;
      }

      .time-rule-editor-close:hover {
        background: var(--bg-tertiary);
      }

      .time-rule-editor-title {
        font-size: 1rem;
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: 16px;
      }

      .time-rule-form {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .time-rule-field {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .time-rule-type-selector {
        display: flex;
        gap: 16px;
      }

      .time-rule-type-radio {
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
        font-size: 0.875rem;
        color: var(--text-primary);
      }

      .time-rule-type-radio input[type="radio"] {
        width: 18px;
        height: 18px;
        cursor: pointer;
        accent-color: var(--accent);
      }

      .time-rule-field label {
        font-size: 0.875rem;
        font-weight: 500;
        color: var(--text-primary);
      }

      .time-rule-field input[type="text"] {
        padding: 8px 12px;
        border-radius: 6px;
        border: 1px solid var(--border-color);
        background: var(--bg-primary);
        color: var(--text-primary);
        font-size: 0.875rem;
        font-family: inherit;
      }

      .time-rule-field input[type="text"]:focus {
        outline: none;
        border-color: var(--accent);
      }

      .time-rule-field-hint {
        font-size: 0.75rem;
        color: var(--text-secondary);
        margin-top: 4px;
      }

      .time-rule-field select {
        padding: 8px 12px;
        border-radius: 6px;
        border: 1px solid var(--border-color);
        background: var(--bg-primary);
        color: var(--text-primary);
        font-size: 0.875rem;
      }

      .time-rule-days {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .time-rule-day-checkbox {
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
        font-size: 0.875rem;
        color: var(--text-primary);
      }

      .time-rule-day-checkbox input[type="checkbox"] {
        width: 18px;
        height: 18px;
        cursor: pointer;
        accent-color: var(--accent);
      }

      .time-rule-vibes {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .time-rule-vibe-checkbox {
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
        font-size: 0.875rem;
        color: var(--text-primary);
      }

      .time-rule-vibe-checkbox input[type="checkbox"] {
        width: 18px;
        height: 18px;
        cursor: pointer;
        accent-color: var(--accent);
      }

      .time-rule-actions {
        display: flex;
        gap: 8px;
        margin-top: 8px;
      }

      .time-rule-actions button {
        padding: 8px 16px;
        border-radius: 6px;
        border: 1px solid var(--border-color);
        background: var(--bg-tertiary);
        color: var(--text-primary);
        font-size: 0.875rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .time-rule-actions button:hover {
        background: var(--bg-primary);
      }

      .time-rule-actions button:first-child {
        background: var(--accent);
        color: var(--bg-primary);
      }

      .time-rule-actions button:first-child:hover {
        background: var(--accent-hover);
      }

      .playlist-recommendations {
        margin-bottom: 32px;
        padding-bottom: 16px;
        border-bottom: 1px solid var(--border-color);
      }

      .recommendation-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 12px;
      }

      .recommendation-title {
        font-size: 1rem;
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: 4px;
      }

      .recommendation-rule-info {
        display: none;
      }

      .recommended-playlist-rule-context {
        display: flex;
        align-items: center;
        gap: 6px;
        margin-bottom: 6px;
        font-size: 0.8125rem;
        color: var(--text-secondary);
        flex-wrap: wrap;
      }

      .recommended-playlist-rule-name {
        font-size: 0.875rem;
        font-weight: 600;
        color: var(--text-primary);
      }

      .recommended-playlist-rule-separator {
        color: var(--text-tertiary);
        margin: 0 2px;
      }

      .recommended-playlist-rule-time {
        font-size: 0.75rem;
        font-weight: 500;
        color: var(--text-secondary);
      }

      .recommended-playlist-rule-vibes {
        font-size: 0.6875rem;
        font-weight: 500;
        color: var(--text-tertiary);
      }

      .recommendation-rule-card {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 10px 14px;
        background: var(--bg-secondary);
        border-radius: 8px;
        border: 1px solid var(--border-color);
        font-size: 0.875rem;
        flex-wrap: wrap;
      }

      .recommendation-rule-badge {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 3px 7px;
        border-radius: 4px;
        background: var(--accent);
        color: var(--bg-primary);
        font-size: 0.6875rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        flex-shrink: 0;
      }

      .recommendation-rule-badge svg {
        width: 10px;
        height: 10px;
        stroke: currentColor;
        fill: none;
        stroke-width: 2.5;
        stroke-linecap: round;
        stroke-linejoin: round;
      }

      .recommendation-rule-name {
        font-size: 0.875rem;
        font-weight: 600;
        color: var(--text-primary);
        margin: 0;
        flex-shrink: 0;
      }

      .recommendation-rule-separator {
        color: var(--text-tertiary);
        margin: 0 4px;
        flex-shrink: 0;
      }

      .recommendation-rule-time {
        color: var(--text-primary);
        font-weight: 500;
        flex-shrink: 0;
      }

      .recommendation-rule-vibes-list {
        display: flex;
        flex-wrap: wrap;
        gap: 4px;
        align-items: center;
      }

      .recommendation-rule-vibe-badge {
        display: inline-flex;
        align-items: center;
        padding: 3px 8px;
        border-radius: 10px;
        background: var(--bg-tertiary);
        color: var(--text-primary);
        font-size: 0.75rem;
        font-weight: 500;
        border: 1px solid var(--border-color);
      }

      .recommendation-rule-empty {
        padding: 10px 14px;
        background: var(--bg-secondary);
        border-radius: 8px;
        border: 1px solid var(--border-color);
        color: var(--text-secondary);
        font-size: 0.875rem;
        text-align: center;
      }

      .recommended-playlist {
        position: relative;
        display: flex;
        flex-direction: column;
        gap: 16px;
        padding: 16px;
        background: var(--bg-primary);
        border: 2px solid var(--accent);
        border-radius: 12px;
        margin-bottom: 16px;
        box-shadow: var(--shadow-md);
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .recommended-playlist:hover {
        box-shadow: var(--shadow-lg);
        transform: translateY(-2px);
      }

      .recommended-playlist-header {
        display: flex;
        align-items: flex-start;
        gap: 16px;
      }

      .recommended-playlist-art {
        width: 80px;
        height: 80px;
        border-radius: 10px;
        overflow: hidden;
        flex-shrink: 0;
        background: var(--bg-tertiary);
        display: grid;
        place-items: center;
        box-shadow: var(--shadow-sm);
      }

      .recommended-playlist-art img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .recommended-playlist-art .playlist-placeholder {
        font-size: 2rem;
        color: var(--text-tertiary);
      }

      .recommended-playlist-info {
        flex: 1;
        min-width: 0;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .recommended-playlist-badge {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 4px 8px;
        border-radius: 6px;
        background: var(--accent);
        color: var(--bg-primary);
        font-size: 0.75rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        width: fit-content;
      }

      .recommended-playlist-name {
        font-size: 1.125rem;
        font-weight: 600;
        color: var(--text-primary);
        line-height: 1.3;
        margin: 0;
      }

      .recommended-playlist-meta {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 8px;
      }

      .recommended-playlist-vibe-badge {
        display: inline-flex;
        align-items: center;
        padding: 4px 10px;
        border-radius: 12px;
        background: var(--bg-tertiary);
        color: var(--text-primary);
        font-size: 0.8125rem;
        font-weight: 500;
        border: 1px solid var(--border-color);
      }

      .recommended-playlist-actions {
        display: flex;
        gap: 8px;
      }

      .recommended-playlist-actions button {
        flex: 1;
        padding: 12px 20px;
        border-radius: 8px;
        border: none;
        background: var(--accent);
        color: var(--bg-primary);
        font-size: 0.9375rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
      }

      .recommended-playlist-actions button:hover {
        background: var(--accent-hover);
        transform: scale(1.02);
      }

      .recommended-playlist-actions button:active {
        transform: scale(0.98);
      }

      .recommended-playlist-actions button.secondary {
        background: var(--bg-tertiary);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
      }

      .recommended-playlist-actions button.secondary:hover {
        background: var(--bg-secondary);
      }

      .recommended-playlist-actions button svg {
        width: 18px;
        height: 18px;
        fill: currentColor;
      }

      .recommended-playlist-actions button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
      }

      .recommended-playlist-actions button.playing {
        background: var(--success);
        color: var(--bg-primary);
      }

      .recommended-playlist-actions button.playing:hover {
        background: var(--success);
        opacity: 0.9;
      }

      .recommended-playlist.loading {
        opacity: 0.7;
        pointer-events: none;
      }

      .alternatives-dropdown {
        margin-top: 12px;
      }

      .alternatives-toggle {
        width: 100%;
        padding: 8px 12px;
        border-radius: 6px;
        border: 1px solid var(--border-color);
        background: var(--bg-secondary);
        color: var(--text-primary);
        font-size: 0.875rem;
        cursor: pointer;
        text-align: left;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .alternatives-toggle:hover {
        background: var(--bg-tertiary);
      }

      .alternatives-list {
        margin-top: 8px;
        display: none;
        flex-direction: column;
        gap: 8px;
      }

      .alternatives-list.visible {
        display: flex;
      }

      .alternative-playlist {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 10px;
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .alternative-playlist:hover {
        background: var(--bg-tertiary);
      }

      .alternative-playlist-art {
        width: 40px;
        height: 40px;
        border-radius: 4px;
        overflow: hidden;
        flex-shrink: 0;
        background: var(--bg-tertiary);
        display: grid;
        place-items: center;
      }

      .alternative-playlist-art img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .alternative-playlist-info {
        flex: 1;
        min-width: 0;
      }

      .alternative-playlist-name {
        font-size: 0.875rem;
        font-weight: 500;
        color: var(--text-primary);
      }

      .alternative-playlist-vibe {
        font-size: 0.75rem;
        color: var(--text-secondary);
      }
    </style>
  </head>
  <body>
    <div id="menu-backdrop" class="menu-backdrop"></div>
    <div id="menu-panel" class="menu-panel">
      <div class="menu-header">
        <span class="menu-title">Menu</span>
        <button id="menu-close-btn" class="menu-close-btn" type="button" aria-label="Close menu">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" width="20" height="20">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      <div class="menu-items">
        <button id="menu-item-controls" class="menu-item active" type="button">Controls</button>
        <button id="menu-item-playlist-management" class="menu-item" type="button">Playlist Management</button>
        <button id="menu-item-settings" class="menu-item" type="button">Settings</button>
      </div>
      <div class="menu-signout">
        <button id="menu-item-signout" class="menu-item" type="button">Sign out</button>
      </div>
    </div>

    <main class="container">
      <div class="header-wrapper">
        <div class="header-container">
          <button id="hamburger-menu-btn" class="hamburger-menu-btn" type="button" aria-label="Open menu">
            <span></span>
            <span></span>
            <span></span>
          </button>
          <h1><img src="/images/sonos.svg" alt="Sonos" class="sonos-logo-header"> <span class="controller-text">Controller</span></h1>
        </div>
      </div>
      <p id="status" class="status disconnected">Checking connection</p>
      <div id="feedback" class="feedback"></div>

      <!-- Loading Screen Overlay -->
      <div id="loading-overlay" class="loading-overlay">
        <div class="loading-content">
          <div class="loading-text">
            <div>
              <img src="/images/alter-logo-light.png" alt="Alter" class="alter-logo alter-logo-light">
              <img src="/images/alter-logo-dark.png" alt="Alter" class="alter-logo alter-logo-dark">
            </div>
            <div class="loading-x"></div>
            <div>
              <img src="/images/sonos.svg" alt="Sonos" class="sonos-logo">
            </div>
          </div>
        </div>
      </div>

      <!-- Toast Notification -->
      <div id="toast" class="toast hidden">
        <div class="toast-content"></div>
      </div>

      <div id="auth-bar" class="hidden" style="margin-bottom: 12px">
        <button id="signin-btn" onclick="login()">Sign in with Sonos</button>
      </div>

      <div id="app-panels" class="hidden">
        <div id="household-title" class="household-title"></div>

        <section id="panel-control">
          <div class="playlist-recommendations" id="playlist-recommendations">
            <div class="recommendation-header">
              <div class="recommendation-title">Recommended Playlist</div>
            </div>
            <div id="recommendation-rule-info" class="recommendation-rule-info"></div>
            <div id="recommended-playlist-container"></div>
            <div id="alternatives-dropdown" class="alternatives-dropdown"></div>
          </div>
          <div class="favorites">
            <div class="favorites-header">
              <span class="section-title">Favourites</span>
              <button id="favorites-toggle" class="favorites-toggle" type="button">
                View All Favourites <span></span>
              </button>
            </div>
            <div id="favorites-content" class="favorites-content hidden">
              <div id="vibe-filters" class="vibe-filters"></div>
              <p id="favorites-status" class="favorites-status">Sign in to load favourites.</p>
              <div id="favorites-grid" class="favorites-grid"></div>
            </div>
          </div>
        </section>

        <section id="panel-playlist-management" class="hidden">
          <div class="playlist-management-section">
            <h3 class="section-title">Playlists</h3>
            <p id="playlist-management-status" class="favorites-status">Sign in to load playlists.</p>
            <div id="playlist-management-grid" class="favorites-grid"></div>
          </div>
          <div class="time-rules-section">
            <h3 class="section-title">Time-Based Rules</h3>
            <p class="favorites-status">Configure which vibes are allowed at different times of day.</p>
            
            <div class="base-schedule-section">
              <h4 class="subsection-title">Base Schedule</h4>
              <p class="favorites-status">Rules that apply to all days of the week.</p>
              <div id="base-schedule-list"></div>
              <button id="add-base-rule-btn" type="button" class="add-rule-btn">Add Base Rule</button>
            </div>
            
            <div class="day-overrides-section">
              <h4 class="subsection-title">Day Overrides</h4>
              <p class="favorites-status">Override the base schedule for specific days. Overrides replace base rules for overlapping time ranges.</p>
              <div id="day-overrides-list"></div>
              <button id="add-override-btn" type="button" class="add-rule-btn">Add Day Override</button>
            </div>
            <div id="time-rule-editor-backdrop" class="time-rule-editor-backdrop">
              <div id="time-rule-editor" class="time-rule-editor">
                <button id="time-rule-editor-close" class="time-rule-editor-close" type="button" aria-label="Close">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" width="20" height="20">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                  </svg>
                </button>
                <h4 id="time-rule-editor-title" class="time-rule-editor-title">Edit Time Rule</h4>
              <div class="time-rule-form">
                <div class="time-rule-field">
                  <label>Name (Optional)</label>
                  <input type="text" id="time-rule-name" placeholder="e.g., Mornings, Afternoons, Quiet Hours" maxlength="50">
                  <small class="time-rule-field-hint">Give this rule a descriptive name</small>
                </div>
                <div class="time-rule-field">
                  <label>Rule Type</label>
                  <div class="time-rule-type-selector">
                    <label class="time-rule-type-radio">
                      <input type="radio" name="rule-type" value="base" id="time-rule-type-base" checked>
                      <span>Base Schedule</span>
                    </label>
                    <label class="time-rule-type-radio">
                      <input type="radio" name="rule-type" value="override" id="time-rule-type-override">
                      <span>Day Override</span>
                    </label>
                  </div>
                </div>
                <div class="time-rule-field">
                  <label>Start Hour</label>
                  <select id="time-rule-start-hour">
                    <option value="0">12:00 AM</option>
                    <option value="1">1:00 AM</option>
                    <option value="2">2:00 AM</option>
                    <option value="3">3:00 AM</option>
                    <option value="4">4:00 AM</option>
                    <option value="5">5:00 AM</option>
                    <option value="6">6:00 AM</option>
                    <option value="7">7:00 AM</option>
                    <option value="8">8:00 AM</option>
                    <option value="9">9:00 AM</option>
                    <option value="10">10:00 AM</option>
                    <option value="11">11:00 AM</option>
                    <option value="12">12:00 PM</option>
                    <option value="13">1:00 PM</option>
                    <option value="14">2:00 PM</option>
                    <option value="15">3:00 PM</option>
                    <option value="16">4:00 PM</option>
                    <option value="17">5:00 PM</option>
                    <option value="18">6:00 PM</option>
                    <option value="19">7:00 PM</option>
                    <option value="20">8:00 PM</option>
                    <option value="21">9:00 PM</option>
                    <option value="22">10:00 PM</option>
                    <option value="23">11:00 PM</option>
                  </select>
                </div>
                <div class="time-rule-field">
                  <label>End Hour</label>
                  <select id="time-rule-end-hour">
                    <option value="0">12:00 AM</option>
                    <option value="1">1:00 AM</option>
                    <option value="2">2:00 AM</option>
                    <option value="3">3:00 AM</option>
                    <option value="4">4:00 AM</option>
                    <option value="5">5:00 AM</option>
                    <option value="6">6:00 AM</option>
                    <option value="7">7:00 AM</option>
                    <option value="8">8:00 AM</option>
                    <option value="9">9:00 AM</option>
                    <option value="10">10:00 AM</option>
                    <option value="11">11:00 AM</option>
                    <option value="12">12:00 PM</option>
                    <option value="13">1:00 PM</option>
                    <option value="14">2:00 PM</option>
                    <option value="15">3:00 PM</option>
                    <option value="16">4:00 PM</option>
                    <option value="17">5:00 PM</option>
                    <option value="18">6:00 PM</option>
                    <option value="19">7:00 PM</option>
                    <option value="20">8:00 PM</option>
                    <option value="21">9:00 PM</option>
                    <option value="22">10:00 PM</option>
                    <option value="23">11:00 PM</option>
                  </select>
                </div>
                <div class="time-rule-field" id="time-rule-days-field">
                  <label>Days</label>
                  <div class="time-rule-days">
                    <label class="time-rule-day-checkbox">
                      <input type="checkbox" value="everyday" id="time-rule-day-everyday">
                      <span>Every day</span>
                    </label>
                    <label class="time-rule-day-checkbox">
                      <input type="checkbox" value="0" id="time-rule-day-0">
                      <span>Sunday</span>
                    </label>
                    <label class="time-rule-day-checkbox">
                      <input type="checkbox" value="1" id="time-rule-day-1">
                      <span>Monday</span>
                    </label>
                    <label class="time-rule-day-checkbox">
                      <input type="checkbox" value="2" id="time-rule-day-2">
                      <span>Tuesday</span>
                    </label>
                    <label class="time-rule-day-checkbox">
                      <input type="checkbox" value="3" id="time-rule-day-3">
                      <span>Wednesday</span>
                    </label>
                    <label class="time-rule-day-checkbox">
                      <input type="checkbox" value="4" id="time-rule-day-4">
                      <span>Thursday</span>
                    </label>
                    <label class="time-rule-day-checkbox">
                      <input type="checkbox" value="5" id="time-rule-day-5">
                      <span>Friday</span>
                    </label>
                    <label class="time-rule-day-checkbox">
                      <input type="checkbox" value="6" id="time-rule-day-6">
                      <span>Saturday</span>
                    </label>
                  </div>
                </div>
                <div class="time-rule-field">
                  <label>Allowed Vibes</label>
                  <div class="time-rule-vibes">
                    <label class="time-rule-vibe-checkbox">
                      <input type="checkbox" value="Down" id="time-rule-vibe-down">
                      <span>Down</span>
                    </label>
                    <label class="time-rule-vibe-checkbox">
                      <input type="checkbox" value="Down/Mid" id="time-rule-vibe-down-mid">
                      <span>Down/Mid</span>
                    </label>
                    <label class="time-rule-vibe-checkbox">
                      <input type="checkbox" value="Mid" id="time-rule-vibe-mid">
                      <span>Mid</span>
                    </label>
                  </div>
                </div>
                <div class="time-rule-actions">
                  <button id="time-rule-save-btn" type="button">Save</button>
                  <button id="time-rule-cancel-btn" type="button">Cancel</button>
                </div>
              </div>
            </div>
          </div>
        </section>

        <section id="panel-settings" class="hidden">
          <h3 class="section-title">Default Volumes (on play)</h3>
          <p id="settings-help" class="favorites-status">
            Set a default launch volume for each speaker. Leave blank to keep its current level.
          </p>
          <div id="settings-players"></div>
          <div class="settings-actions">
            <button id="settings-save" type="button">Save Defaults</button>
            <span id="settings-status" class="settings-status"></span>
          </div>
        </section>
      </div>

      <div id="currently-playing" class="currently-playing">
        <div class="currently-playing-content">
          <div class="currently-playing-art" id="currently-playing-art">
            <span class="currently-playing-art-placeholder"></span>
          </div>
          <div class="currently-playing-info">
            <div class="currently-playing-location" id="currently-playing-location">
              <span>No group selected</span>
            </div>
            <div class="currently-playing-title" id="currently-playing-title">
              Nothing playing
            </div>
            <div class="currently-playing-artist" id="currently-playing-artist">
              <span></span>
            </div>
            <div class="currently-playing-loudness" id="currently-playing-loudness" style="display: none;">
              <span class="loudness-label"></span>
            </div>
          </div>
          <div class="currently-playing-controls">
            <div class="currently-playing-group-indicator" id="currently-playing-group-indicator" style="display: none;">
              <span></span>
              <span class="currently-playing-group-count" id="currently-playing-group-count" style="display: none;">1</span>
            </div>
          </div>
        </div>
        <div class="currently-playing-volume" id="currently-playing-volume">
          <div class="currently-playing-master-volume" id="currently-playing-master-volume">
            <div class="master-volume-label">Master Volume</div>
            <div class="master-volume-row">
              <input id="master-volume-slider" type="range" class="master-volume-slider" min="0" max="100" step="1" value="0" />
              <span id="master-volume-value" class="master-volume-value">0%</span>
            </div>
          </div>
          <div id="currently-playing-rooms-list"></div>
        </div>
      </div>
    </main>

    <script>
      const SELECT_GROUP_MESSAGE = 'Ready to play';
      const READY_MESSAGE = 'Ready to play';
      const FAVORITE_SUCCESS_MESSAGE = '';
      const FAVORITE_ERROR_MESSAGE = 'Favourite failed to start';
      const LOADING_MESSAGE = 'Loading';
      const FAVORITE_SUCCESS_TOAST = 'Favourite loaded with shuffle, repeat, crossfade.';

      const statusLabel = document.getElementById('status');
      const feedbackLabel = document.getElementById('feedback');
      const signinButton = document.getElementById('signin-btn');
      const authBar = document.getElementById('auth-bar');
      const loadingOverlay = document.getElementById('loading-overlay');
      const toast = document.getElementById('toast');
      const toastContent = document.querySelector('.toast-content');
      const panelsContainer = document.getElementById('app-panels');
      const panelControl = document.getElementById('panel-control');
      const panelSettings = document.getElementById('panel-settings');
      const panelPlaylistManagement = document.getElementById('panel-playlist-management');
      const householdTitle = document.getElementById('household-title');
      const favoritesGrid = document.getElementById('favorites-grid');
      const favoritesStatus = document.getElementById('favorites-status');
      const vibeFiltersContainer = document.getElementById('vibe-filters');
      const favoritesToggle = document.getElementById('favorites-toggle');
      const favoritesContent = document.getElementById('favorites-content');
      const currentlyPlayingPanel = document.getElementById('currently-playing');
      const currentlyPlayingArt = document.getElementById('currently-playing-art');
      const currentlyPlayingLocation = document.getElementById('currently-playing-location');
      const currentlyPlayingTitle = document.getElementById('currently-playing-title');
      const currentlyPlayingArtist = document.getElementById('currently-playing-artist');
      const currentlyPlayingLoudness = document.getElementById('currently-playing-loudness');
      const currentlyPlayingGroupIndicator = document.getElementById('currently-playing-group-indicator');
      const currentlyPlayingGroupCount = document.getElementById('currently-playing-group-count');
      const currentlyPlayingVolume = document.getElementById('currently-playing-volume');
      const currentlyPlayingRoomsList = document.getElementById('currently-playing-rooms-list');
      const recommendedPlaylistContainer = document.getElementById('recommended-playlist-container');
      const alternativesDropdown = document.getElementById('alternatives-dropdown');
      const recommendationRuleInfo = document.getElementById('recommendation-rule-info');
      
      // Hamburger menu elements
      const hamburgerMenuBtn = document.getElementById('hamburger-menu-btn');
      const menuBackdrop = document.getElementById('menu-backdrop');
      const menuPanel = document.getElementById('menu-panel');
      const menuCloseBtn = document.getElementById('menu-close-btn');
      const menuItemControls = document.getElementById('menu-item-controls');
      const menuItemPlaylistManagement = document.getElementById('menu-item-playlist-management');
      const menuItemSettings = document.getElementById('menu-item-settings');
      const menuItemSignout = document.getElementById('menu-item-signout');
      
      // Master volume controls
      const masterVolumeSlider = document.getElementById('master-volume-slider');
      let isMasterVolumeDragging = false;
      let masterVolumeExpectedValue = null; // Track expected volume after release
      let masterVolumeUpdateTimeout = null;
      const masterVolumeValue = document.getElementById('master-volume-value');
      
      // Track panel state to prevent flickering
      let panelShouldBeVisible = false;
      let hidePanelTimeout = null;
      let currentHouseholdName = null;
      
const settingsPlayersWrap = document.getElementById('settings-players');
const settingsSaveButton = document.getElementById('settings-save');
const settingsStatusLabel = document.getElementById('settings-status');
const settingsHelpLabel = document.getElementById('settings-help');

// Playlist management elements
const playlistManagementGrid = document.getElementById('playlist-management-grid');
const playlistManagementStatus = document.getElementById('playlist-management-status');
const baseScheduleList = document.getElementById('base-schedule-list');
const dayOverridesList = document.getElementById('day-overrides-list');
const addBaseRuleBtn = document.getElementById('add-base-rule-btn');
const addOverrideBtn = document.getElementById('add-override-btn');
const timeRuleEditorBackdrop = document.getElementById('time-rule-editor-backdrop');
const timeRuleEditor = document.getElementById('time-rule-editor');
const timeRuleEditorClose = document.getElementById('time-rule-editor-close');
const timeRuleName = document.getElementById('time-rule-name');
const timeRuleStartHour = document.getElementById('time-rule-start-hour');
const timeRuleEndHour = document.getElementById('time-rule-end-hour');
const timeRuleVibeDown = document.getElementById('time-rule-vibe-down');
const timeRuleVibeDownMid = document.getElementById('time-rule-vibe-down-mid');
const timeRuleVibeMid = document.getElementById('time-rule-vibe-mid');
const timeRuleSaveBtn = document.getElementById('time-rule-save-btn');
const timeRuleCancelBtn = document.getElementById('time-rule-cancel-btn');

settingsSaveButton.disabled = true;
settingsStatusLabel.textContent = '';

      let isSonosConnected = false;
      let currentHouseholdId = null;
      let currentGroupId = null;
      let currentGroupName = 'No group selected';
      let currentActiveFavoriteId = null;
      let currentActiveFavoriteIdTimestamp = 0; // Track when favorite was set
      let lastStatusUpdateTime = 0; // Track when status was last updated to ignore stale responses
      const recommendationCardButtons = new Map(); // Store recommendation card buttons by favorite ID
      const favoritesRegistry = new Map();
      let latestPlayers = [];
      let latestGroups = [];
      let refreshTimer = null;
      let playlistVibes = {};
      let currentVibeFilter = null;
      let playbackRefreshTimer = null;
      let currentPlaybackState = null;
      let currentImageUrl = null;
      let lastPlayActionTime = 0; // Track when last play action occurred to prevent refresh interference
      let previousTrackId = null; // Track previous track identifier for change detection
      let baseVolume = null; // Store base/reference volume level for loudness normalization

      function login() {
        window.location.href = '/auth/sonos/login';
      }

async function signout() {
  try {
    await fetch('/auth/signout', { method: 'POST' });
  } catch (error) {
    console.error('Sign out failed:', error);
  }
  closeMenu();
  setAuthUI(false);
  showFeedback('Signed out of Sonos.');
}

function openMenu() {
  menuPanel.classList.remove('dragging');
  menuPanel.classList.add('open');
  menuBackdrop.classList.add('visible');
  document.body.classList.add('menu-open');
}

function closeMenu() {
  menuPanel.classList.remove('dragging');
  menuPanel.classList.remove('open');
  menuBackdrop.classList.remove('visible');
  document.body.classList.remove('menu-open');
}

// Swipe gesture handling
let touchStartX = null;
let touchStartY = null;
let touchStartTime = null;
let isDragging = false;
let menuPanelWidth = 280;
const SWIPE_THRESHOLD = 50; // Minimum distance in pixels to trigger swipe
const SWIPE_VELOCITY_THRESHOLD = 0.3; // Minimum velocity (px/ms) to trigger swipe
const EDGE_THRESHOLD = 20; // Distance from left edge to detect edge swipe

function getMenuPanelWidth() {
  return menuPanel.offsetWidth || 280;
}

function updateMenuPanelTransform(deltaX) {
  const width = getMenuPanelWidth();
  const isMenuOpen = menuPanel.classList.contains('open');
  
  if (isMenuOpen) {
    // Menu is open - dragging left (deltaX is negative) to close
    // Start at 0, move towards -width
    const newX = Math.max(-width, Math.min(0, deltaX));
    menuPanel.style.transform = `translateX(${newX}px)`;
    
    // Update backdrop opacity based on menu position (0 = fully visible, -width = hidden)
    const opacity = Math.max(0, Math.min(1, (width + newX) / width));
    menuBackdrop.style.opacity = opacity.toString();
  } else {
    // Menu is closed - dragging right (deltaX is positive) to open
    // Start at -width, move towards 0
    const newX = Math.max(-width, Math.min(0, -width + deltaX));
    menuPanel.style.transform = `translateX(${newX}px)`;
    
    // Update backdrop opacity based on menu position
    const opacity = Math.max(0, Math.min(1, (width + newX) / width));
    menuBackdrop.style.opacity = opacity.toString();
    if (opacity > 0) {
      menuBackdrop.classList.add('visible');
    } else {
      menuBackdrop.classList.remove('visible');
    }
  }
}

function handleTouchStart(e) {
  const touch = e.touches[0];
  touchStartX = touch.clientX;
  touchStartY = touch.clientY;
  touchStartTime = Date.now();
  isDragging = false;
  
  const isMenuOpen = menuPanel.classList.contains('open');
  const isFromLeftEdge = touchStartX <= EDGE_THRESHOLD;
  
  // Don't interfere with specific interactive elements when menu is closed
  if (!isMenuOpen) {
    // When menu is closed, only allow swipe from left edge
    // Don't interfere with scrolling, inputs, buttons, links, or now-playing panel
    if (!isFromLeftEdge || 
        e.target.closest('input, textarea, select, button:not(.hamburger-menu-btn), a, .currently-playing, .favorites-grid, .playlist-card')) {
      return;
    }
  } else {
    // When menu is open, allow swipe to close from anywhere
    // But don't interfere with menu items, inputs, or scrolling within menu
    if (e.target.closest('.menu-item, input, textarea, select, button:not(.menu-close-btn), a')) {
      return;
    }
  }
  
  // Only start drag if:
  // 1. Menu is open (can swipe left to close from anywhere on main content)
  // 2. Menu is closed and touch started from left edge (can swipe right to open)
  if (isMenuOpen || isFromLeftEdge) {
    menuPanelWidth = getMenuPanelWidth();
    menuPanel.classList.add('dragging');
    isDragging = true;
  }
}

function handleTouchMove(e) {
  if (!isDragging || touchStartX === null) {
    return;
  }
  
  const touch = e.touches[0];
  const deltaX = touch.clientX - touchStartX;
  const deltaY = touch.clientY - touchStartY;
  
  // Check if this is primarily a horizontal swipe
  if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 10) {
    e.preventDefault(); // Prevent scrolling during horizontal swipe
    
    const isMenuOpen = menuPanel.classList.contains('open');
    const width = getMenuPanelWidth();
    
    if (isMenuOpen) {
      // Menu is open - only allow left swipe to close
      if (deltaX < 0) {
        updateMenuPanelTransform(deltaX);
      }
    } else {
      // Menu is closed - only allow right swipe to open
      if (deltaX > 0 && deltaX <= width) {
        updateMenuPanelTransform(deltaX);
      }
    }
  }
}

function handleTouchEnd(e) {
  if (!isDragging || touchStartX === null) {
    return;
  }
  
  const touch = e.changedTouches[0];
  const deltaX = touch.clientX - touchStartX;
  const deltaY = touch.clientY - touchStartY;
  const deltaTime = Date.now() - touchStartTime;
  const velocity = Math.abs(deltaX) / deltaTime;
  
  const isMenuOpen = menuPanel.classList.contains('open');
  const width = getMenuPanelWidth();
  
  // Determine if swipe should complete
  let shouldComplete = false;
  
  if (isMenuOpen) {
    // Menu is open - check if should close
    const closeThreshold = width * 0.3; // Close if dragged more than 30% of width
    shouldComplete = deltaX < -SWIPE_THRESHOLD || 
                     (deltaX < 0 && Math.abs(deltaX) > closeThreshold) ||
                     (deltaX < 0 && velocity > SWIPE_VELOCITY_THRESHOLD);
  } else {
    // Menu is closed - check if should open
    const openThreshold = width * 0.5; // Open if dragged more than 50% of width
    shouldComplete = deltaX > SWIPE_THRESHOLD && 
                     (deltaX > openThreshold || velocity > SWIPE_VELOCITY_THRESHOLD);
  }
  
  // Reset dragging state
  menuPanel.classList.remove('dragging');
  menuPanel.style.transform = '';
  menuBackdrop.style.opacity = '';
  isDragging = false;
  touchStartX = null;
  touchStartY = null;
  touchStartTime = null;
  
  // Complete or cancel the swipe
  if (shouldComplete) {
    // Clear inline styles to let CSS transitions handle the animation
    menuPanel.style.transform = '';
    menuBackdrop.style.opacity = '';
    
    if (isMenuOpen) {
      closeMenu();
    } else {
      openMenu();
    }
  } else {
    // Snap back to original state - use CSS transition
    menuPanel.style.transform = '';
    menuBackdrop.style.opacity = '';
    
    // Small delay to ensure transform is cleared before restoring classes
    requestAnimationFrame(() => {
      if (isMenuOpen) {
        menuPanel.classList.add('open');
        menuBackdrop.classList.add('visible');
      } else {
        menuPanel.classList.remove('open');
        menuBackdrop.classList.remove('visible');
      }
    });
  }
}

// Add touch event listeners
document.addEventListener('touchstart', handleTouchStart, { passive: true });
document.addEventListener('touchmove', handleTouchMove, { passive: false });
document.addEventListener('touchend', handleTouchEnd, { passive: true });

function showView(name) {
  const isControl = name === 'control';
  const isPlaylistManagement = name === 'playlist-management';
  const isSettings = name === 'settings';
  
  menuItemControls.classList.toggle('active', isControl);
  menuItemPlaylistManagement.classList.toggle('active', isPlaylistManagement);
  menuItemSettings.classList.toggle('active', isSettings);
  
  panelControl.classList.toggle('hidden', !isControl);
  panelPlaylistManagement.classList.toggle('hidden', !isPlaylistManagement);
  panelSettings.classList.toggle('hidden', !isSettings);
  
  closeMenu();
  
  if (isSettings) {
    renderSettings();
  } else if (isPlaylistManagement) {
    renderPlaylistManagement();
  } else if (isControl) {
    // Update recommendations when control panel is shown
    updatePlaylistRecommendations();
  }
}

// Hamburger menu event handlers
hamburgerMenuBtn.addEventListener('click', () => {
  openMenu();
});

menuCloseBtn.addEventListener('click', () => {
  closeMenu();
});

menuBackdrop.addEventListener('click', () => {
  closeMenu();
});

menuItemControls.addEventListener('click', () => {
  showView('control');
});

menuItemPlaylistManagement.addEventListener('click', () => {
  showView('playlist-management');
});

menuItemSettings.addEventListener('click', () => {
  showView('settings');
});

menuItemSignout.addEventListener('click', () => {
  signout();
});

// Favorites toggle handler
favoritesToggle.addEventListener('click', () => {
  const isHidden = favoritesContent.classList.contains('hidden');
  favoritesContent.classList.toggle('hidden', !isHidden);
  const arrow = favoritesToggle.querySelector('span');
  if (arrow) {
    arrow.textContent = isHidden ? '' : '';
  }
  favoritesToggle.innerHTML = `${isHidden ? 'Hide' : 'View'} All Favourites <span>${isHidden ? '' : ''}</span>`;
});

function setAuthUI(loggedIn) {
  signinButton.classList.toggle('hidden', loggedIn);
  authBar.classList.toggle('hidden', loggedIn);
  panelsContainer.classList.toggle('hidden', !loggedIn);
  if (!loggedIn) {
    showView('control');
    closeMenu();
  }
  updateConnectionStatus(loggedIn);
}

async function checkAuthAndInit() {
  try {
    const response = await fetch('/auth/status');
    if (!response.ok) {
      throw new Error('Failed to check auth status');
    }

    const state = await response.json();
    const loggedIn = Boolean(state.loggedIn);
    setAuthUI(loggedIn);
    showView('control');

    if (loggedIn) {
      await refreshUI();
    } else {
      // User needs to sign in, hide loading screen
      hideLoadingOverlay();
    }
  } catch (error) {
    console.error('Auth status check failed:', error);
    setAuthUI(false);
    hideLoadingOverlay();
  }
}

      // Playback control handlers for now-playing section

      // Master volume handler
      masterVolumeSlider.addEventListener('input', (e) => {
        const newValue = Number(e.target.value);
        masterVolumeValue.textContent = `${newValue}%`;
        
        // Send update immediately while dragging (debounced to avoid too many requests)
        if (isMasterVolumeDragging) {
          clearTimeout(masterVolumeUpdateTimeout);
          masterVolumeUpdateTimeout = setTimeout(() => {
            setMasterVolume(newValue, false); // false = don't show feedback for intermediate updates
          }, 50); // Debounce to 50ms
        }
      });

      masterVolumeSlider.addEventListener('mousedown', () => {
        isMasterVolumeDragging = true;
        masterVolumeExpectedValue = null; // Clear expected value when starting to drag
      });

      masterVolumeSlider.addEventListener('touchstart', () => {
        isMasterVolumeDragging = true;
        masterVolumeExpectedValue = null; // Clear expected value when starting to drag
      });

      masterVolumeSlider.addEventListener('change', async (e) => {
        e.stopPropagation();
        const finalValue = Number(e.target.value);
        masterVolumeExpectedValue = finalValue; // Set expected value on release
        isMasterVolumeDragging = false;
        clearTimeout(masterVolumeUpdateTimeout);
        await setMasterVolume(finalValue, true); // true = show feedback for final update
      });

      masterVolumeSlider.addEventListener('mouseup', async (e) => {
        if (isMasterVolumeDragging) {
          const finalValue = Number(e.target.value);
          masterVolumeExpectedValue = finalValue; // Set expected value on release
          isMasterVolumeDragging = false;
          clearTimeout(masterVolumeUpdateTimeout);
          await setMasterVolume(finalValue, true); // true = show feedback for final update
        }
      });

      masterVolumeSlider.addEventListener('touchend', async (e) => {
        if (isMasterVolumeDragging) {
          const finalValue = Number(e.target.value);
          masterVolumeExpectedValue = finalValue; // Set expected value on release
          isMasterVolumeDragging = false;
          clearTimeout(masterVolumeUpdateTimeout);
          await setMasterVolume(finalValue, true); // true = show feedback for final update
        }
      });
      const authMessages = {
        error: 'Authorization failed. Please try logging in again.',
        missing_code: 'Login response missing authorization code.',
        invalid_state: 'Login validation failed. Please retry.'
      };

      function applyAuthFeedback() {
        const params = new URLSearchParams(window.location.search);
        const state = params.get('auth');

        if (state && authMessages[state]) {
          showFeedback(authMessages[state], true);
          params.delete('auth');
          const newUrl = window.location.pathname + (params.toString() ? `?${params}` : '');
          window.history.replaceState({}, '', newUrl);
        }
      }

      function updateConnectionStatus(connected) {
        statusLabel.classList.toggle('connected', connected);
        statusLabel.classList.toggle('disconnected', !connected);
        statusLabel.textContent = connected ? 'Connected to Sonos' : 'Not connected';
        isSonosConnected = connected;

        if (!connected) {
          currentHouseholdId = null;
          currentHouseholdName = null;
          householdTitle.textContent = '';
          favoritesStatus.textContent = 'Login required to load favourites.';
          vibeFiltersContainer.innerHTML = '';
          currentGroupId = null;
          currentGroupName = 'No group selected';
          updateActiveGroupDisplay();
          currentActiveFavoriteId = null;
          settingsPlayersWrap.innerHTML = '';
          settingsStatusLabel.textContent = '';
          if (settingsHelpLabel) {
            settingsHelpLabel.textContent = 'Sign in to load speakers.';
          }
          stopPlaybackRefresh();
          currentlyPlayingPanel.classList.remove('visible');
          document.body.classList.remove('has-playing');
        }

        settingsSaveButton.disabled = !connected;
        evaluateFavoritesAvailability();
      }

      function showFeedback(message, isError = false) {
        feedbackLabel.textContent = message ?? '';
        feedbackLabel.classList.toggle('error', Boolean(isError));
      }

      function showLoadingOverlay() {
        loadingOverlay.classList.remove('hidden');
      }

      function hideLoadingOverlay() {
        loadingOverlay.classList.add('hidden');
      }

      function showToast(message) {
        toastContent.textContent = message;
        toast.classList.remove('hidden');
        toast.classList.add('show');
        
        // Auto-dismiss after 3.5 seconds
        setTimeout(() => {
          toast.classList.remove('show');
          setTimeout(() => {
            toast.classList.add('hidden');
          }, 300); // Wait for animation to complete
        }, 3500);
      }

      function getSelectedGroupId() {
        return currentGroupId;
      }

      function updateActiveGroupDisplay() {
        // Group display removed - groups are auto-created
      }


      async function loadHouseholds() {
        try {
          // Show loading overlay
          showLoadingOverlay();
          
          const response = await fetch('/api/households');

          if (response.status === 401) {
            hideLoadingOverlay();
            setAuthUI(false);
            showFeedback('Login required to load Sonos households.', true);
            favoritesStatus.textContent = 'Login required to load favourites.';
            return;
          }

          if (!response.ok) {
            throw new Error(await response.text());
          }

          const data = await response.json();
          const households = Array.isArray(data.households) ? data.households : [];

          if (!households.length) {
            hideLoadingOverlay();
            setAuthUI(true);
            showFeedback('No households returned for this account.', true);
            currentHouseholdId = null;
            currentHouseholdName = null;
            householdTitle.textContent = '';
            currentGroupId = null;
            currentGroupName = 'No group selected';
            currentActiveFavoriteId = null;
            updateActiveGroupDisplay();
            await loadFavorites(null);
            await loadPlayers(null);
            evaluateFavoritesAvailability();
            return;
          }

          // Auto-select first household and display as title
          const firstHousehold = households[0];
          currentHouseholdId = firstHousehold.id || null;
          currentHouseholdName = firstHousehold.name || firstHousehold.id || '';
          householdTitle.textContent = currentHouseholdName;

          setAuthUI(true);

          if (currentHouseholdId) {
            await loadPlayers(currentHouseholdId);
            await loadFavorites(currentHouseholdId);
          } else {
            await loadFavorites(null);
            await loadPlayers(null);
            evaluateFavoritesAvailability();
          }

          if (!panelSettings.classList.contains('hidden')) {
            await renderSettings();
          }

          // Hide loading overlay
          hideLoadingOverlay();
        } catch (error) {
          hideLoadingOverlay();
          console.error('Failed to load households:', error);
          showFeedback('Could not load households. Please try again.', true);
          setAuthUI(false);
          favoritesStatus.textContent = 'Unable to load favourites.';
        }
      }

      async function fetchGroupsPlayers(householdId) {
        if (!householdId) {
          return { groups: [], players: [] };
        }

        const response = await fetch(
          `/api/households/${encodeURIComponent(householdId)}/groups-players`
        );

        if (!response.ok) {
          throw new Error(await response.text());
        }

        return response.json();
      }

      async function renderSettings() {
        if (panelSettings.classList.contains('hidden')) {
          return;
        }

        settingsStatusLabel.textContent = '';

        if (!isSonosConnected) {
          settingsPlayersWrap.innerHTML = '';
          if (settingsHelpLabel) {
            settingsHelpLabel.textContent = 'Sign in to load speakers.';
          }
          settingsSaveButton.disabled = true;
          settingsSaveButton.onclick = null;
          return;
        }

        const householdId = currentHouseholdId;
        if (!householdId) {
          settingsPlayersWrap.innerHTML = '';
          if (settingsHelpLabel) {
            settingsHelpLabel.textContent = 'No household available.';
          }
          settingsSaveButton.disabled = true;
          settingsSaveButton.onclick = null;
          return;
        }

        if (settingsHelpLabel) {
          settingsHelpLabel.textContent =
            'Set a default launch volume for each speaker. Leave blank to keep its current level.';
        }

        try {
          // Always fetch fresh data from the database when settings panel loads
          // This ensures settings saved on other devices are immediately visible
          const [snapshot, defaults] = await Promise.all([
            fetchGroupsPlayers(householdId),
            fetch('/api/settings/volumes', {
              cache: 'no-store',
              headers: {
                'Cache-Control': 'no-cache'
              }
            }).then((response) => {
              if (!response.ok) {
                throw new Error('Failed to load saved volumes');
              }
              return response.json();
            })
          ]);

          const players = Array.isArray(snapshot.players) ? snapshot.players : [];
          settingsPlayersWrap.innerHTML = '';

          if (!players.length) {
            settingsSaveButton.disabled = true;
            settingsStatusLabel.textContent = 'No speakers found for this household.';
            settingsSaveButton.onclick = null;
            return;
          }

          players.forEach((player) => {
            const row = document.createElement('div');
            row.className = 'settings-row';
            row.dataset.playerId = player.id;

            const nameLabel = document.createElement('strong');
            nameLabel.textContent = player.name || player.id || 'Speaker';

            const rangeInput = document.createElement('input');
            rangeInput.type = 'range';
            rangeInput.min = '0';
            rangeInput.max = '100';

            const numberInput = document.createElement('input');
            numberInput.type = 'number';
            numberInput.min = '0';
            numberInput.max = '100';
            numberInput.placeholder = '';

            const defaultValue =
              defaults && typeof defaults[player.id] === 'number'
                ? Math.max(0, Math.min(100, Number(defaults[player.id])))
                : null;

            if (defaultValue === null || Number.isNaN(defaultValue)) {
              rangeInput.value = '50';
              numberInput.value = '';
            } else {
              rangeInput.value = String(defaultValue);
              numberInput.value = String(defaultValue);
            }

            rangeInput.addEventListener('input', (event) => {
              numberInput.value = event.target.value;
            });

            numberInput.addEventListener('input', (event) => {
              const raw = event.target.value.trim();
              if (raw === '') {
                return;
              }

              let numeric = Number(raw);
              if (Number.isNaN(numeric)) {
                numeric = '';
              } else {
                numeric = Math.max(0, Math.min(100, numeric));
              }

              if (numeric === '') {
                event.target.value = '';
              } else {
                event.target.value = String(numeric);
                rangeInput.value = String(numeric);
              }
            });

            row.appendChild(nameLabel);
            row.appendChild(rangeInput);
            row.appendChild(numberInput);
            settingsPlayersWrap.appendChild(row);
          });

          settingsSaveButton.disabled = false;
          settingsSaveButton.onclick = async () => {
            try {
              settingsSaveButton.disabled = true;
              settingsStatusLabel.textContent = 'Saving';

              const payload = {};
              settingsPlayersWrap.querySelectorAll('.settings-row').forEach((row) => {
                const playerId = row.dataset.playerId;
                const input = row.querySelector('input[type="number"]');
                if (!playerId || !input) {
                  return;
                }

                const value = input.value.trim();
                // Send all players: empty string for cleared values, number for set values
                // This allows the backend to delete volumes that are cleared
                payload[playerId] = value !== '' ? Number(value) : '';
              });

              const response = await fetch('/api/settings/volumes', {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
              });

              if (!response.ok) {
                throw new Error(await response.text());
              }

              settingsStatusLabel.textContent = 'Saved defaults.';
            } catch (error) {
              console.error('Failed to save volume defaults:', error);
              settingsStatusLabel.textContent = 'Failed to save defaults.';
            } finally {
              settingsSaveButton.disabled = false;
            }
          };
        } catch (error) {
          console.error('Failed to render settings:', error);
          settingsPlayersWrap.innerHTML = '';
          settingsStatusLabel.textContent = 'Failed to load speaker data.';
          settingsSaveButton.disabled = true;
          settingsSaveButton.onclick = null;
        }
      }

      // Playlist management functions
      let timeRules = [];
      let editingRuleId = null;

      async function renderPlaylistManagement() {
        if (panelPlaylistManagement.classList.contains('hidden')) {
          return;
        }

        if (!isSonosConnected || !currentHouseholdId) {
          playlistManagementStatus.textContent = 'Sign in to load playlists.';
          playlistManagementGrid.innerHTML = '';
          baseScheduleList.innerHTML = '';
          dayOverridesList.innerHTML = '';
          return;
        }

        try {
          await loadPlaylistVibes();
          await loadTimeRules();

          // Load favorites for playlist management (include hidden ones)
          const params = new URLSearchParams({ householdId: currentHouseholdId, includeHidden: 'true' });
          const response = await fetch(`/api/favorites?${params.toString()}`);

          if (response.status === 401) {
            setAuthUI(false);
            playlistManagementStatus.textContent = 'Login required to load playlists.';
            return;
          }

          if (!response.ok) {
            throw new Error(await response.text());
          }

          const data = await response.json();
          const items = Array.isArray(data.items) ? data.items : [];

          if (!items.length) {
            playlistManagementStatus.textContent = 'No playlists found.';
            playlistManagementGrid.innerHTML = '';
            renderTimeRules();
            return;
          }

          playlistManagementStatus.textContent = '';
          playlistManagementGrid.innerHTML = '';

          const cardPromises = items.map(async (favorite) => {
            const entry = await createPlaylistManagementCard(favorite);
            playlistManagementGrid.appendChild(entry.button);
            return entry;
          });
          await Promise.all(cardPromises);

          renderTimeRules();
        } catch (error) {
          console.error('Failed to load playlists:', error);
          playlistManagementStatus.textContent = 'Could not load playlists. Please try again.';
          playlistManagementGrid.innerHTML = '';
          baseScheduleList.innerHTML = '';
          dayOverridesList.innerHTML = '';
        }
      }

      async function createPlaylistManagementCard(favorite) {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'playlist-card';
        button.dataset.favoriteId = favorite.id;

        const cardContent = document.createElement('div');
        cardContent.className = 'playlist-card-content';

        const artWrapper = document.createElement('div');
        artWrapper.className = 'playlist-art-wrapper';

        const imageUrl =
          favorite && favorite.imageUrl
            ? favorite.imageUrl
            : favorite && favorite.images && favorite.images.length && favorite.images[0].url
              ? favorite.images[0].url
              : favorite && favorite.container && favorite.container.imageUrl
                ? favorite.container.imageUrl
                : null;

        if (imageUrl) {
          const img = document.createElement('img');
          img.className = 'playlist-art';
          img.alt = `${favorite.name || 'Playlist'} cover art`;
          img.loading = 'lazy';
          img.src = imageUrl;
          img.addEventListener('error', () => img.classList.add('hidden'));
          artWrapper.appendChild(img);
        } else {
          const placeholder = document.createElement('span');
          placeholder.className = 'playlist-placeholder';
          placeholder.textContent = '';
          artWrapper.appendChild(placeholder);
        }

        const meta = document.createElement('div');
        meta.className = 'playlist-meta';

        const nameRow = document.createElement('div');
        nameRow.className = 'playlist-name-row';

        const title = document.createElement('span');
        title.className = 'playlist-name';
        title.textContent = favorite.name || 'Unnamed Playlist';
        nameRow.appendChild(title);

        const vibeSelect = document.createElement('select');
        vibeSelect.className = 'playlist-vibe-select';
        vibeSelect.appendChild(new Option('', ''));
        ['Down', 'Down/Mid', 'Mid'].forEach((vibe) => {
          const option = document.createElement('option');
          option.value = vibe;
          option.textContent = vibe;
          vibeSelect.appendChild(option);
        });
        
        const currentVibe = playlistVibes[favorite.id] || '';
        vibeSelect.value = currentVibe;
        
        // Apply styling class based on current vibe
        if (currentVibe === 'Down') {
          vibeSelect.classList.add('down');
        } else if (currentVibe === 'Down/Mid') {
          vibeSelect.classList.add('down-mid');
        } else if (currentVibe === 'Mid') {
          vibeSelect.classList.add('mid');
        }
        
        vibeSelect.addEventListener('change', async (event) => {
          event.stopPropagation();
          const oldValue = vibeSelect.value;
          const oldClass = vibeSelect.className.match(/\b(down|down-mid|mid)\b/)?.[0];
          
          // Remove old class
          if (oldClass) {
            vibeSelect.classList.remove(oldClass);
          }
          
          // Apply new class and update value
          vibeSelect.value = event.target.value;
          if (event.target.value === 'Down') {
            vibeSelect.classList.add('down');
          } else if (event.target.value === 'Down/Mid') {
            vibeSelect.classList.add('down-mid');
          } else if (event.target.value === 'Mid') {
            vibeSelect.classList.add('mid');
          }
          
          try {
            await setPlaylistVibe(favorite.id, event.target.value);
            // Refresh the vibe selector to ensure it matches saved state
            await loadPlaylistVibes();
            const savedVibe = playlistVibes[favorite.id] || '';
            vibeSelect.value = savedVibe;
            
            // Update class based on saved vibe
            vibeSelect.className = 'playlist-vibe-select';
            if (savedVibe === 'Down') {
              vibeSelect.classList.add('down');
            } else if (savedVibe === 'Down/Mid') {
              vibeSelect.classList.add('down-mid');
            } else if (savedVibe === 'Mid') {
              vibeSelect.classList.add('mid');
            }
          } catch (error) {
            // Revert on error
            vibeSelect.value = oldValue;
            vibeSelect.className = 'playlist-vibe-select';
            if (oldClass) {
              vibeSelect.classList.add(oldClass);
            }
          }
        });
        
        nameRow.appendChild(vibeSelect);
        meta.appendChild(nameRow);
        cardContent.appendChild(artWrapper);
        cardContent.appendChild(meta);

        const cardActions = document.createElement('div');
        cardActions.className = 'playlist-card-actions';

        // Load hidden state for this favorite
        let isHidden = false;
        try {
          const hiddenResponse = await fetch(`/api/favorites/${encodeURIComponent(favorite.id)}/hidden`);
          if (hiddenResponse.ok) {
            const hiddenData = await hiddenResponse.json();
            isHidden = hiddenData.hidden === true;
          }
        } catch (error) {
          console.error('Failed to load hidden state:', error);
        }

        const toggleBtn = document.createElement('button');
        toggleBtn.textContent = isHidden ? 'Show' : 'Hide';
        toggleBtn.className = isHidden ? 'show' : 'hide';
        toggleBtn.type = 'button';
        toggleBtn.setAttribute('aria-label', isHidden ? 'Show in Controls' : 'Hide from Controls');
        toggleBtn.addEventListener('click', async (event) => {
          event.stopPropagation();
          const newHiddenState = !isHidden;
          const playlistName = favorite.name || 'this playlist';
          
          try {
            const response = await fetch(`/api/favorites/${encodeURIComponent(favorite.id)}/hidden`, {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ hidden: newHiddenState })
            });

            if (!response.ok) {
              let errorMessage = 'Failed to update favorite visibility';
              try {
                const errorData = await response.json();
                if (errorData.detail) {
                  errorMessage = errorData.detail;
                } else if (errorData.error) {
                  errorMessage = errorData.error;
                }
              } catch (parseError) {
                const errorText = await response.text();
                errorMessage = errorText || errorMessage;
              }
              throw new Error(errorMessage);
            }

            // Update the button state
            isHidden = newHiddenState;
            toggleBtn.textContent = isHidden ? 'Show' : 'Hide';
            toggleBtn.className = isHidden ? 'show' : 'hide';
            toggleBtn.setAttribute('aria-label', isHidden ? 'Show in Controls' : 'Hide from Controls');

            // Refresh the favorites view if it's open (to reflect the change)
            if (!panelControl.classList.contains('hidden')) {
              await loadFavorites(currentHouseholdId);
            }
          } catch (error) {
            console.error('Failed to update favorite visibility:', error);
            alert(`Failed to update favorite visibility. ${error.message || 'Please try again.'}`);
          }
        });

        cardActions.appendChild(toggleBtn);

        button.appendChild(cardContent);
        button.appendChild(cardActions);

        return { favorite, button, vibeSelect };
      }

      async function loadTimeRules() {
        try {
          const response = await fetch('/api/vibe-time-rules');
          if (response.ok) {
            timeRules = await response.json();
          } else {
            timeRules = [];
          }
        } catch (error) {
          console.error('Failed to load time rules:', error);
          timeRules = [];
        }
      }

      function createTimeRuleItem(rule) {
        const item = document.createElement('div');
        item.className = 'time-rule-item';

        const info = document.createElement('div');
        info.className = 'time-rule-info';

        // Add name if it exists
        if (rule.name) {
          const name = document.createElement('div');
          name.className = 'time-rule-name';
          name.textContent = rule.name;
          info.appendChild(name);
        }

        const time = document.createElement('div');
        time.className = 'time-rule-time';
        const startHour = rule.start_hour;
        const endHour = rule.end_hour;
        const startTime = formatHour(startHour);
        const endTime = formatHour(endHour);
        
        let daysText = 'Every day';
        if (rule.days && Array.isArray(rule.days) && rule.days.length > 0) {
          const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
          daysText = rule.days.map(d => dayNames[d]).join(', ');
        }
        
        time.textContent = `${startTime} - ${endTime} (${daysText})`;

        const vibes = document.createElement('div');
        vibes.className = 'time-rule-vibes';
        vibes.textContent = `Vibes: ${rule.allowed_vibes.join(', ')}`;

        info.appendChild(time);
        info.appendChild(vibes);

        const actions = document.createElement('div');
        actions.className = 'time-rule-actions';

        const editBtn = document.createElement('button');
        editBtn.textContent = 'Edit';
        editBtn.addEventListener('click', () => {
          editingRuleId = rule.id;
          timeRuleName.value = rule.name || '';
          timeRuleStartHour.value = rule.start_hour;
          timeRuleEndHour.value = rule.end_hour;
          timeRuleVibeDown.checked = rule.allowed_vibes.includes('Down');
          timeRuleVibeDownMid.checked = rule.allowed_vibes.includes('Down/Mid');
          timeRuleVibeMid.checked = rule.allowed_vibes.includes('Mid');
          
          // Set rule type
          const ruleTypeBase = document.getElementById('time-rule-type-base');
          const ruleTypeOverride = document.getElementById('time-rule-type-override');
          if (rule.rule_type === 'override') {
            ruleTypeOverride.checked = true;
            ruleTypeBase.checked = false;
            updateRuleEditorForType('override');
          } else {
            ruleTypeBase.checked = true;
            ruleTypeOverride.checked = false;
            updateRuleEditorForType('base');
          }
          
          // Set day checkboxes
          const everydayCheckbox = document.getElementById('time-rule-day-everyday');
          if (!rule.days || !Array.isArray(rule.days) || rule.days.length === 0) {
            everydayCheckbox.checked = true;
            for (let i = 0; i <= 6; i++) {
              document.getElementById(`time-rule-day-${i}`).checked = false;
            }
          } else {
            everydayCheckbox.checked = false;
            for (let i = 0; i <= 6; i++) {
              document.getElementById(`time-rule-day-${i}`).checked = rule.days.includes(i);
            }
          }
          
          openTimeRuleEditor();
        });

        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'Delete';
        deleteBtn.className = 'delete';
        deleteBtn.addEventListener('click', async () => {
          if (confirm('Are you sure you want to delete this rule?')) {
            try {
              const response = await fetch(`/api/vibe-time-rules/${rule.id}`, {
                method: 'DELETE'
              });
              if (response.ok) {
                await loadTimeRules();
                renderTimeRules();
              } else {
                throw new Error('Failed to delete rule');
              }
            } catch (error) {
              console.error('Failed to delete rule:', error);
              alert('Failed to delete rule. Please try again.');
            }
          }
        });

        actions.appendChild(editBtn);
        actions.appendChild(deleteBtn);

        item.appendChild(info);
        item.appendChild(actions);
        return item;
      }

      function renderTimeRules() {
        baseScheduleList.innerHTML = '';
        dayOverridesList.innerHTML = '';

        // Separate base and override rules
        const baseRules = timeRules.filter(r => r.rule_type === 'base');
        const overrideRules = timeRules.filter(r => r.rule_type === 'override');

        // Render base schedule
        if (baseRules.length === 0) {
          const emptyMsg = document.createElement('p');
          emptyMsg.className = 'favorites-status';
          emptyMsg.textContent = 'No base schedule rules. Add a rule to get started.';
          baseScheduleList.appendChild(emptyMsg);
        } else {
          baseRules.forEach((rule) => {
            const item = createTimeRuleItem(rule);
            baseScheduleList.appendChild(item);
          });
        }

        // Render day overrides, grouped by day
        if (overrideRules.length === 0) {
          const emptyMsg = document.createElement('p');
          emptyMsg.className = 'favorites-status';
          emptyMsg.textContent = 'No day overrides. Add an override to customize specific days.';
          dayOverridesList.appendChild(emptyMsg);
        } else {
          // Group overrides by day
          const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
          const overridesByDay = {};
          
          overrideRules.forEach(rule => {
            if (rule.days && rule.days.length > 0) {
              const day = rule.days[0];
              if (!overridesByDay[day]) {
                overridesByDay[day] = [];
              }
              overridesByDay[day].push(rule);
            }
          });

          // Render each day's overrides
          Object.keys(overridesByDay).sort().forEach(day => {
            const dayGroup = document.createElement('div');
            dayGroup.className = 'override-day-group';
            
            const dayHeader = document.createElement('h5');
            dayHeader.className = 'override-day-header';
            dayHeader.textContent = dayNames[parseInt(day)];
            dayGroup.appendChild(dayHeader);
            
            overridesByDay[day].forEach(rule => {
              const item = createTimeRuleItem(rule);
              dayGroup.appendChild(item);
            });
            
            dayOverridesList.appendChild(dayGroup);
          });
        }
      }

      function formatHour(hour) {
        const h = hour % 12 || 12;
        const ampm = hour < 12 ? 'AM' : 'PM';
        return `${h}:00 ${ampm}`;
      }

      addBaseRuleBtn.addEventListener('click', () => {
        editingRuleId = null;
        timeRuleName.value = '';
        timeRuleStartHour.value = '7';
        timeRuleEndHour.value = '12';
        timeRuleVibeDown.checked = false;
        timeRuleVibeDownMid.checked = false;
        timeRuleVibeMid.checked = false;
        
        // Set rule type to base
        const ruleTypeBase = document.getElementById('time-rule-type-base');
        const ruleTypeOverride = document.getElementById('time-rule-type-override');
        ruleTypeBase.checked = true;
        ruleTypeOverride.checked = false;
        updateRuleEditorForType('base');
        
        openTimeRuleEditor();
      });

      addOverrideBtn.addEventListener('click', () => {
        editingRuleId = null;
        timeRuleName.value = '';
        timeRuleStartHour.value = '7';
        timeRuleEndHour.value = '12';
        timeRuleVibeDown.checked = false;
        timeRuleVibeDownMid.checked = false;
        timeRuleVibeMid.checked = false;
        
        // Set rule type to override
        const ruleTypeBase = document.getElementById('time-rule-type-base');
        const ruleTypeOverride = document.getElementById('time-rule-type-override');
        ruleTypeBase.checked = false;
        ruleTypeOverride.checked = true;
        updateRuleEditorForType('override');
        
        // Set Monday as default day for override
        const everydayCheckbox = document.getElementById('time-rule-day-everyday');
        everydayCheckbox.checked = false;
        for (let i = 0; i <= 6; i++) {
          document.getElementById(`time-rule-day-${i}`).checked = (i === 1); // Monday
        }
        
        openTimeRuleEditor();
      });

      function updateRuleEditorForType(ruleType) {
        const daysFieldContainer = document.getElementById('time-rule-days-field');
        const everydayCheckbox = document.getElementById('time-rule-day-everyday');
        const everydayCheckboxLabel = everydayCheckbox?.closest('.time-rule-day-checkbox');
        
        if (ruleType === 'base') {
          // Hide day selection for base rules
          if (daysFieldContainer) {
            daysFieldContainer.style.display = 'none';
          }
          // Ensure "Every day" is checked (though it won't be visible)
          if (everydayCheckbox) {
            everydayCheckbox.checked = true;
            for (let i = 0; i <= 6; i++) {
              const dayCheckbox = document.getElementById(`time-rule-day-${i}`);
              if (dayCheckbox) {
                dayCheckbox.checked = false;
              }
            }
          }
        } else {
          // Show day selection for override rules
          if (daysFieldContainer) {
            daysFieldContainer.style.display = 'flex';
          }
          // Hide "Every day" option for overrides
          if (everydayCheckboxLabel) {
            everydayCheckboxLabel.style.display = 'none';
          }
          // Ensure "Every day" is unchecked
          if (everydayCheckbox) {
            everydayCheckbox.checked = false;
          }
        }
      }

      function openTimeRuleEditor() {
        const titleEl = document.getElementById('time-rule-editor-title');
        const ruleTypeBase = document.getElementById('time-rule-type-base');
        const ruleType = ruleTypeBase?.checked ? 'base' : 'override';
        
        if (titleEl) {
          titleEl.textContent = editingRuleId 
            ? `Edit ${ruleType === 'base' ? 'Base Schedule' : 'Day Override'} Rule` 
            : `Add ${ruleType === 'base' ? 'Base Schedule' : 'Day Override'} Rule`;
        }
        // Update UI based on current rule type selection
        updateRuleEditorForType(ruleType);
        timeRuleEditorBackdrop.classList.add('visible');
        document.body.style.overflow = 'hidden';
      }

      function closeTimeRuleEditor() {
        timeRuleEditorBackdrop.classList.remove('visible');
        document.body.style.overflow = '';
        editingRuleId = null;
        // Reset day field visibility
        const daysFieldContainer = document.getElementById('time-rule-days-field');
        if (daysFieldContainer) {
          daysFieldContainer.style.display = 'flex';
        }
        const everydayCheckbox = document.getElementById('time-rule-day-everyday');
        const everydayCheckboxLabel = everydayCheckbox?.closest('.time-rule-day-checkbox');
        if (everydayCheckboxLabel) {
          everydayCheckboxLabel.style.display = 'flex';
        }
      }

      // Handle rule type radio buttons
      const ruleTypeBase = document.getElementById('time-rule-type-base');
      const ruleTypeOverride = document.getElementById('time-rule-type-override');
      
      ruleTypeBase.addEventListener('change', () => {
        if (ruleTypeBase.checked) {
          updateRuleEditorForType('base');
          const titleEl = document.getElementById('time-rule-editor-title');
          if (titleEl) {
            titleEl.textContent = editingRuleId ? 'Edit Base Schedule Rule' : 'Add Base Schedule Rule';
          }
        }
      });
      
      ruleTypeOverride.addEventListener('change', () => {
        if (ruleTypeOverride.checked) {
          updateRuleEditorForType('override');
          const titleEl = document.getElementById('time-rule-editor-title');
          if (titleEl) {
            titleEl.textContent = editingRuleId ? 'Edit Day Override Rule' : 'Add Day Override Rule';
          }
        }
      });

      // Handle "Every day" checkbox (only for base rules, but we'll keep it for compatibility)
      const everydayCheckbox = document.getElementById('time-rule-day-everyday');
      if (everydayCheckbox) {
        everydayCheckbox.addEventListener('change', (e) => {
          if (e.target.checked) {
            // Uncheck all individual days
            for (let i = 0; i <= 6; i++) {
              document.getElementById(`time-rule-day-${i}`).checked = false;
            }
          }
        });
      }

      // Handle individual day checkboxes - for overrides, ensure only one is selected
      for (let i = 0; i <= 6; i++) {
        const dayCheckbox = document.getElementById(`time-rule-day-${i}`);
        if (dayCheckbox) {
          dayCheckbox.addEventListener('change', () => {
            if (dayCheckbox.checked) {
              if (everydayCheckbox) {
                everydayCheckbox.checked = false;
              }
              // For override type, uncheck other days (only one day allowed)
              const ruleTypeOverride = document.getElementById('time-rule-type-override');
              if (ruleTypeOverride && ruleTypeOverride.checked) {
                for (let j = 0; j <= 6; j++) {
                  if (j !== i) {
                    document.getElementById(`time-rule-day-${j}`).checked = false;
                  }
                }
              }
            }
          });
        }
      }

      timeRuleCancelBtn.addEventListener('click', () => {
        closeTimeRuleEditor();
      });

      timeRuleEditorClose.addEventListener('click', () => {
        closeTimeRuleEditor();
      });

      // Close modal when clicking backdrop (but not the modal content itself)
      timeRuleEditorBackdrop.addEventListener('click', (e) => {
        if (e.target === timeRuleEditorBackdrop) {
          closeTimeRuleEditor();
        }
      });

      // Prevent clicks inside the modal from closing it
      timeRuleEditor.addEventListener('click', (e) => {
        e.stopPropagation();
      });

      // Helper function to check if two time ranges overlap
      function timeRangesOverlap(start1, end1, start2, end2) {
        // Handle normal ranges
        if (start1 <= end1 && start2 <= end2) {
          return !(end1 < start2 || end2 < start1);
        }
        // Handle wraparound ranges (e.g., 22-6)
        if (start1 > end1) {
          // First range wraps around
          return timeRangesOverlap(0, end1, start2, end2) || timeRangesOverlap(start1, 23, start2, end2);
        }
        if (start2 > end2) {
          // Second range wraps around
          return timeRangesOverlap(start1, end1, 0, end2) || timeRangesOverlap(start1, end1, start2, 23);
        }
        return false;
      }

      // Client-side validation for overlapping overrides
      function validateOverrideOverlap(ruleType, days, startHour, endHour, currentRuleId) {
        if (ruleType !== 'override') {
          return null; // Only validate overrides
        }

        if (!days || days.length !== 1) {
          return 'Override rules must specify exactly one day.';
        }

        const overrideDay = days[0];
        
        // Check existing overrides for the same day
        const existingOverrides = timeRules.filter(r => 
          r.rule_type === 'override' &&
          r.days && 
          r.days.length === 1 && 
          r.days[0] === overrideDay &&
          (!currentRuleId || r.id !== currentRuleId)
        );

        // Check for time overlaps
        for (const existing of existingOverrides) {
          if (timeRangesOverlap(startHour, endHour, existing.start_hour, existing.end_hour)) {
            const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            return `This override overlaps with an existing override for ${dayNames[overrideDay]}. Please adjust the time range.`;
          }
        }

        return null; // No overlap
      }

      timeRuleSaveBtn.addEventListener('click', async () => {
        const name = timeRuleName.value.trim() || null;
        const startHour = parseInt(timeRuleStartHour.value, 10);
        const endHour = parseInt(timeRuleEndHour.value, 10);
        const allowedVibes = [];
        if (timeRuleVibeDown.checked) allowedVibes.push('Down');
        if (timeRuleVibeDownMid.checked) allowedVibes.push('Down/Mid');
        if (timeRuleVibeMid.checked) allowedVibes.push('Mid');

        if (allowedVibes.length === 0) {
          alert('Please select at least one vibe.');
          return;
        }

        // Get rule type
        const ruleTypeBase = document.getElementById('time-rule-type-base');
        const ruleType = ruleTypeBase.checked ? 'base' : 'override';

        // Get selected days based on rule type
        let days = null;
        if (ruleType === 'override') {
          // Override must have exactly one day
          days = [];
          for (let i = 0; i <= 6; i++) {
            const dayCheckbox = document.getElementById(`time-rule-day-${i}`);
            if (dayCheckbox && dayCheckbox.checked) {
              days.push(i);
            }
          }
          if (days.length !== 1) {
            alert('Day override rules must specify exactly one day.');
            return;
          }
        } else {
          // Base rules must have days = null
          days = null;
        }

        // Client-side validation for overlapping overrides
        const overlapError = validateOverrideOverlap(ruleType, days, startHour, endHour, editingRuleId);
        if (overlapError) {
          alert(overlapError);
          return;
        }

        try {
          const rule = {
            name: name,
            start_hour: startHour,
            end_hour: endHour,
            allowed_vibes: allowedVibes,
            days: days,
            rule_type: ruleType
          };

          if (editingRuleId) {
            rule.id = editingRuleId;
            const response = await fetch(`/api/vibe-time-rules/${editingRuleId}`, {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(rule)
            });
            if (!response.ok) {
              throw new Error('Failed to update rule');
            }
          } else {
            const response = await fetch('/api/vibe-time-rules', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(rule)
            });
            if (!response.ok) {
              throw new Error('Failed to create rule');
            }
          }

          closeTimeRuleEditor();
          await loadTimeRules();
          renderTimeRules();
        } catch (error) {
          console.error('Failed to save time rule:', error);
          const errorMessage = error?.message || 'Failed to save rule. Please try again.';
          if (errorMessage.includes('overlap')) {
            alert(errorMessage);
          } else {
            alert('Failed to save rule. Please try again.');
          }
        }
      });

      async function loadPlaylistVibes() {
        try {
          const response = await fetch('/api/playlist-vibes');
          if (response.ok) {
            playlistVibes = await response.json();
          }
        } catch (error) {
          console.error('Failed to load playlist vibes:', error);
        }
      }

      async function setPlaylistVibe(playlistId, vibe) {
        if (vibe) {
          playlistVibes[playlistId] = vibe;
        } else {
          delete playlistVibes[playlistId];
        }

        try {
          const response = await fetch('/api/playlist-vibes', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(playlistVibes)
          });

          if (!response.ok) {
            throw new Error('Failed to save vibe');
          }

          // Update the saved vibes from the response
          const saved = await response.json();
          playlistVibes = saved;

          applyVibeFilter();
          // Update recommendations when vibes change (if control panel is visible)
          if (!panelControl.classList.contains('hidden')) {
            updatePlaylistRecommendations();
          }
        } catch (error) {
          console.error('Failed to save playlist vibe:', error);
          // Revert the change on error
          if (vibe) {
            delete playlistVibes[playlistId];
          } else {
            // Reload from server to get correct state
            await loadPlaylistVibes();
          }
        }
      }

      async function updatePlaylistRecommendations() {
        if (!isSonosConnected || !currentHouseholdId) {
          recommendedPlaylistContainer.innerHTML = '';
          alternativesDropdown.innerHTML = '';
          recommendationRuleInfo.textContent = '';
          return;
        }

        try {
          // Get current time in user's local timezone
          const now = new Date();
          const currentHour = now.getHours();
          const currentDay = now.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
          const timezoneOffset = -now.getTimezoneOffset() / 60; // Offset in hours (e.g., -5 for EST)

          const params = new URLSearchParams({
            householdId: currentHouseholdId,
            hour: currentHour.toString(),
            day: currentDay.toString(),
            timezoneOffset: timezoneOffset.toString()
          });
          const url = `/api/playlist-recommendations?${params.toString()}`;
          const response = await fetch(url);

          if (!response.ok) {
            throw new Error('Failed to fetch recommendations');
          }

          const data = await response.json();
          const { primary, alternatives, currentRule, debug } = data;
          
          // Only log if there's an issue
          if (debug && (debug.activeRulesCount === 0 || debug.matchingPlaylistsCount === 0)) {
            console.warn('[Client] Recommendations issue:', {
              activeRulesCount: debug.activeRulesCount,
              matchingPlaylistsCount: debug.matchingPlaylistsCount
            });
          }

          // Clear rule info display (now integrated into card)
          recommendationRuleInfo.innerHTML = '';

          // Clear containers and button references
          recommendationCardButtons.clear();
          recommendedPlaylistContainer.innerHTML = '';
          alternativesDropdown.innerHTML = '';

          if (!primary) {
            const noRecs = document.createElement('p');
            noRecs.className = 'favorites-status';
            noRecs.textContent = 'No playlists match the current time rule.';
            recommendedPlaylistContainer.appendChild(noRecs);
            return;
          }

          // Render primary recommendation with rule context
          const primaryCard = createRecommendationCard(primary, true, currentRule);
          recommendedPlaylistContainer.appendChild(primaryCard);

          // Render alternatives if any
          if (alternatives && alternatives.length > 0) {
            const toggle = document.createElement('button');
            toggle.className = 'alternatives-toggle';
            toggle.textContent = `View ${alternatives.length} other option${alternatives.length > 1 ? 's' : ''}`;
            toggle.innerHTML = `${toggle.textContent} <span></span>`;
            
            let isOpen = false;
            toggle.addEventListener('click', () => {
              isOpen = !isOpen;
              alternativesList.classList.toggle('visible', isOpen);
              toggle.innerHTML = `${isOpen ? 'Hide' : 'View'} ${alternatives.length} other option${alternatives.length > 1 ? 's' : ''} <span>${isOpen ? '' : ''}</span>`;
            });

            const alternativesList = document.createElement('div');
            alternativesList.className = 'alternatives-list';

            alternatives.forEach((alt) => {
              const altCard = createRecommendationCard(alt, false);
              alternativesList.appendChild(altCard);
            });

            alternativesDropdown.appendChild(toggle);
            alternativesDropdown.appendChild(alternativesList);
          }
        } catch (error) {
          console.error('Failed to update playlist recommendations:', error);
          recommendedPlaylistContainer.innerHTML = '';
          alternativesDropdown.innerHTML = '';
          recommendationRuleInfo.textContent = '';
        }
      }

      function createRecommendationCard(favorite, isPrimary, currentRule) {
        const card = document.createElement('div');
        card.className = isPrimary ? 'recommended-playlist' : 'alternative-playlist';

        if (isPrimary) {
          // Primary recommendation card with enhanced design
          const header = document.createElement('div');
          header.className = 'recommended-playlist-header';

          const art = document.createElement('div');
          art.className = 'recommended-playlist-art';

          const imageUrl =
            favorite && favorite.imageUrl
              ? favorite.imageUrl
              : favorite && favorite.images && favorite.images.length && favorite.images[0].url
                ? favorite.images[0].url
                : favorite && favorite.container && favorite.container.imageUrl
                  ? favorite.container.imageUrl
                  : null;

          if (imageUrl) {
            const img = document.createElement('img');
            img.src = imageUrl;
            img.alt = `${favorite.name || 'Playlist'} cover art`;
            img.loading = 'lazy';
            img.addEventListener('error', () => {
              const placeholder = document.createElement('span');
              placeholder.className = 'playlist-placeholder';
              placeholder.textContent = '';
              art.innerHTML = '';
              art.appendChild(placeholder);
            });
            art.appendChild(img);
          } else {
            const placeholder = document.createElement('span');
            placeholder.className = 'playlist-placeholder';
            placeholder.textContent = '';
            art.appendChild(placeholder);
          }

          const info = document.createElement('div');
          info.className = 'recommended-playlist-info';

          // Recommended badge
          const badge = document.createElement('div');
          badge.className = 'recommended-playlist-badge';
          badge.innerHTML = '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg> Recommended';
          info.appendChild(badge);

          // Rule context (if available) - subtle line above playlist name
          if (currentRule) {
            const ruleContext = document.createElement('div');
            ruleContext.className = 'recommended-playlist-rule-context';
            
            const ruleName = document.createElement('span');
            ruleName.className = 'recommended-playlist-rule-name';
            ruleName.textContent = currentRule.name || 'Active Rule';
            ruleContext.appendChild(ruleName);
            
            const separator1 = document.createElement('span');
            separator1.className = 'recommended-playlist-rule-separator';
            separator1.textContent = '';
            ruleContext.appendChild(separator1);
            
            const ruleTime = document.createElement('span');
            ruleTime.className = 'recommended-playlist-rule-time';
            const startTime = formatHour(currentRule.start_hour);
            const endTime = formatHour(currentRule.end_hour);
            ruleTime.textContent = `${startTime} - ${endTime}`;
            ruleContext.appendChild(ruleTime);
            
            if (currentRule.allowed_vibes && currentRule.allowed_vibes.length > 0) {
              const separator2 = document.createElement('span');
              separator2.className = 'recommended-playlist-rule-separator';
              separator2.textContent = '';
              ruleContext.appendChild(separator2);
              
              const ruleVibes = document.createElement('span');
              ruleVibes.className = 'recommended-playlist-rule-vibes';
              ruleVibes.textContent = currentRule.allowed_vibes.join(', ');
              ruleContext.appendChild(ruleVibes);
            }
            
            info.appendChild(ruleContext);
          }

          // Playlist name
          const name = document.createElement('h3');
          name.className = 'recommended-playlist-name';
          name.textContent = favorite.name || 'Unnamed Playlist';

          // Meta information with vibe badge
          const meta = document.createElement('div');
          meta.className = 'recommended-playlist-meta';
          const vibeValue = playlistVibes[favorite.id];
          if (vibeValue) {
            const vibeBadge = document.createElement('span');
            vibeBadge.className = 'recommended-playlist-vibe-badge';
            vibeBadge.textContent = vibeValue;
            meta.appendChild(vibeBadge);
          }

          info.appendChild(name);
          info.appendChild(meta);

          header.appendChild(art);
          header.appendChild(info);
          card.appendChild(header);

          // Action button
          const actions = document.createElement('div');
          actions.className = 'recommended-playlist-actions';

          const playBtn = document.createElement('button');
          
          // Check if this playlist is currently active
          const isCurrentlyActive = currentActiveFavoriteId === favorite.id;
          if (isCurrentlyActive) {
            playBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg> Playing';
            playBtn.classList.add('playing');
          } else {
            playBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg> Play Now';
          }
          
          // Store button reference for updates
          recommendationCardButtons.set(favorite.id, playBtn);
          
          playBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            playBtn.disabled = true;
            playBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg> Loading...';
            card.classList.add('loading');
            
            try {
              const entry = favoritesRegistry.get(favorite.id);
              if (entry) {
                await playFavorite(entry);
              } else {
                const tempEntry = { favorite, button: null, statusEl: null, loading: false };
                await playFavorite(tempEntry);
              }
            } catch (error) {
              console.error('Failed to play recommended playlist:', error);
            } finally {
              playBtn.disabled = false;
              // Button state will be updated by markActiveFavorite/updateRecommendationCardButtons
              updateRecommendationCardButtons(currentActiveFavoriteId);
              card.classList.remove('loading');
            }
          });

          actions.appendChild(playBtn);
          card.appendChild(actions);

          // Make entire card clickable
          card.addEventListener('click', async (e) => {
            // Don't trigger if clicking the button (already handled)
            if (e.target.closest('button')) {
              return;
            }
            
            playBtn.disabled = true;
            playBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg> Loading...';
            card.classList.add('loading');
            
            try {
              const entry = favoritesRegistry.get(favorite.id);
              if (entry) {
                await playFavorite(entry);
              } else {
                const tempEntry = { favorite, button: null, statusEl: null, loading: false };
                await playFavorite(tempEntry);
              }
            } catch (error) {
              console.error('Failed to play recommended playlist:', error);
            } finally {
              playBtn.disabled = false;
              updateRecommendationCardButtons(currentActiveFavoriteId);
              card.classList.remove('loading');
            }
          });
        } else {
          // Alternative playlist card (simpler design)
          const art = document.createElement('div');
          art.className = 'alternative-playlist-art';

          const imageUrl =
            favorite && favorite.imageUrl
              ? favorite.imageUrl
              : favorite && favorite.images && favorite.images.length && favorite.images[0].url
                ? favorite.images[0].url
                : favorite && favorite.container && favorite.container.imageUrl
                  ? favorite.container.imageUrl
                  : null;

          if (imageUrl) {
            const img = document.createElement('img');
            img.src = imageUrl;
            img.alt = `${favorite.name || 'Playlist'} cover art`;
            img.loading = 'lazy';
            img.addEventListener('error', () => {
              const placeholder = document.createElement('span');
              placeholder.className = 'playlist-placeholder';
              placeholder.textContent = '';
              art.innerHTML = '';
              art.appendChild(placeholder);
            });
            art.appendChild(img);
          } else {
            const placeholder = document.createElement('span');
            placeholder.className = 'playlist-placeholder';
            placeholder.textContent = '';
            art.appendChild(placeholder);
          }

          const info = document.createElement('div');
          info.className = 'alternative-playlist-info';

          const name = document.createElement('div');
          name.className = 'alternative-playlist-name';
          name.textContent = favorite.name || 'Unnamed Playlist';

          info.appendChild(name);

          const vibeValue = playlistVibes[favorite.id];
          if (vibeValue) {
            const vibe = document.createElement('div');
            vibe.className = 'alternative-playlist-vibe';
            vibe.textContent = `Vibe: ${vibeValue}`;
            info.appendChild(vibe);
          }

          card.appendChild(art);
          card.appendChild(info);

          card.addEventListener('click', async () => {
            const entry = favoritesRegistry.get(favorite.id);
            if (entry) {
              await playFavorite(entry);
            } else {
              const tempEntry = { favorite, button: null, statusEl: null, loading: false };
              await playFavorite(tempEntry);
            }
          });
        }

        return card;
      }

      function renderVibeFilters() {
        vibeFiltersContainer.innerHTML = '';

        const allButton = document.createElement('button');
        allButton.className = 'vibe-filter-btn';
        allButton.textContent = 'All';
        const isAllActive = currentVibeFilter === null;
        allButton.classList.toggle('active', isAllActive);
        allButton.addEventListener('click', () => {
          // Remove active class and vibe classes from all buttons
          vibeFiltersContainer.querySelectorAll('.vibe-filter-btn').forEach(btn => {
            btn.classList.remove('active', 'down', 'down-mid', 'mid');
          });
          currentVibeFilter = null;
          allButton.classList.add('active');
          applyVibeFilter();
        });
        vibeFiltersContainer.appendChild(allButton);

        ['Down', 'Down/Mid', 'Mid'].forEach((vibe) => {
          const button = document.createElement('button');
          button.className = 'vibe-filter-btn';
          button.textContent = vibe;
          const isActive = currentVibeFilter === vibe;
          button.classList.toggle('active', isActive);
          if (isActive) {
            if (vibe === 'Down') {
              button.classList.add('down');
            } else if (vibe === 'Down/Mid') {
              button.classList.add('down-mid');
            } else if (vibe === 'Mid') {
              button.classList.add('mid');
            }
          }
          button.addEventListener('click', () => {
            // Remove active class and vibe classes from all buttons
            vibeFiltersContainer.querySelectorAll('.vibe-filter-btn').forEach(btn => {
              btn.classList.remove('active', 'down', 'down-mid', 'mid');
            });
            currentVibeFilter = vibe;
            button.classList.add('active');
            if (vibe === 'Down') {
              button.classList.add('down');
            } else if (vibe === 'Down/Mid') {
              button.classList.add('down-mid');
            } else if (vibe === 'Mid') {
              button.classList.add('mid');
            }
            applyVibeFilter();
          });
          vibeFiltersContainer.appendChild(button);
        });
      }

      function applyVibeFilter() {
        favoritesRegistry.forEach((entry) => {
          const vibe = playlistVibes[entry.favorite.id] || null;
          const shouldShow = currentVibeFilter === null || vibe === currentVibeFilter;
          entry.button.style.display = shouldShow ? '' : 'none';
        });
      }

      async function loadFavorites(householdId) {
        favoritesRegistry.clear();
        favoritesGrid.innerHTML = '';

        if (!householdId) {
          favoritesStatus.textContent = isSonosConnected
            ? 'Select a household to load favourites.'
            : 'Login required to load favourites.';
          vibeFiltersContainer.innerHTML = '';
          evaluateFavoritesAvailability();
          return;
        }

        favoritesStatus.textContent = 'Loading favourites';

        try {
          await loadPlaylistVibes();

          const params = new URLSearchParams({ householdId });
          const activeGroupId = getSelectedGroupId();
          if (activeGroupId) {
            params.set('groupId', activeGroupId);
          }

          const response = await fetch(`/api/favorites?${params.toString()}`);

          if (response.status === 401) {
            setAuthUI(false);
            favoritesStatus.textContent = 'Login required to load favourites.';
            return;
          }

          if (!response.ok) {
            throw new Error(await response.text());
          }

          const data = await response.json();
          const items = Array.isArray(data.items) ? data.items : [];
          currentActiveFavoriteId = data.activeFavorite ?? null;

          if (!items.length) {
            favoritesStatus.textContent = 'No favourites found.';
            vibeFiltersContainer.innerHTML = '';
            evaluateFavoritesAvailability();
            return;
          }

          favoritesStatus.textContent = '';

          items.forEach((favorite) => {
            const entry = createFavoriteCard(favorite);
            favoritesRegistry.set(favorite.id, entry);
            favoritesGrid.appendChild(entry.button);
          });

          renderVibeFilters();
          applyVibeFilter();
          evaluateFavoritesAvailability();
          markActiveFavorite(currentActiveFavoriteId);
          // Update recommendations when favorites are loaded
          if (!panelControl.classList.contains('hidden')) {
            updatePlaylistRecommendations();
          }
        } catch (error) {
          console.error('Failed to load favorites:', error);
          favoritesStatus.textContent = 'Could not load favourites. Please try again.';
          vibeFiltersContainer.innerHTML = '';
          evaluateFavoritesAvailability();
        }
      }

      function createFavoriteCard(favorite) {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'playlist-card disabled';
        button.disabled = true;
        button.dataset.favoriteId = favorite.id;

        const artWrapper = document.createElement('div');
        artWrapper.className = 'playlist-art-wrapper';

        const imageUrl =
          favorite && favorite.imageUrl
            ? favorite.imageUrl
            : favorite && favorite.images && favorite.images.length && favorite.images[0].url
              ? favorite.images[0].url
              : favorite && favorite.container && favorite.container.imageUrl
                ? favorite.container.imageUrl
                : null;

        if (imageUrl) {
          const img = document.createElement('img');
          img.className = 'playlist-art';
          img.alt = `${favorite.name || 'Favorite'} cover art`;
          img.loading = 'lazy';
          img.src = imageUrl;
          img.addEventListener('error', () => img.classList.add('hidden'));
          artWrapper.appendChild(img);
        } else {
          const placeholder = document.createElement('span');
          placeholder.className = 'playlist-placeholder';
          placeholder.textContent = '';
          artWrapper.appendChild(placeholder);
        }

        const meta = document.createElement('div');
        meta.className = 'playlist-meta';

        const nameRow = document.createElement('div');
        nameRow.className = 'playlist-name-row';

        const title = document.createElement('span');
        title.className = 'playlist-name';
        title.textContent = favorite.name || 'Unnamed Favourite';
        nameRow.appendChild(title);

        const vibe = playlistVibes[favorite.id] || '';
        let vibeBadge = null;
        if (vibe) {
          vibeBadge = document.createElement('span');
          vibeBadge.className = 'playlist-vibe-badge-inline';
          if (vibe === 'Down') {
            vibeBadge.className += ' down';
            vibeBadge.textContent = 'Down';
          } else if (vibe === 'Down/Mid') {
            vibeBadge.className += ' down-mid';
            vibeBadge.textContent = 'Down/Mid';
          } else if (vibe === 'Mid') {
            vibeBadge.className += ' mid';
            vibeBadge.textContent = 'Mid';
          }
          nameRow.appendChild(vibeBadge);
        }

        meta.appendChild(nameRow);

        const cardContent = document.createElement('div');
        cardContent.className = 'playlist-card-content';
        cardContent.appendChild(artWrapper);
        cardContent.appendChild(meta);

        button.appendChild(cardContent);

        const entry = {
          favorite,
          button,
          playButton: null, // Removed - clicking card plays it
          statusEl: null, // Keep for compatibility but won't be used
          loading: false,
          statusMessage: SELECT_GROUP_MESSAGE,
          vibeBadge: vibeBadge
        };

        button.addEventListener('click', (event) => {
          playFavorite(entry);
        });

        return entry;
      }

      async function playFavorite(entry) {
        if (!currentHouseholdId) {
          showFeedback('Select a household first.', true);
          return;
        }

        setFavoriteLoading(entry, true);

        try {
          const groupResponse = await fetch(`/api/households/${encodeURIComponent(currentHouseholdId)}/create-all-group`, {
            method: 'POST'
          });

          if (!groupResponse.ok) {
            throw new Error('Failed to create group with all players');
          }

          const groupData = await groupResponse.json();
          const groupId = groupData.groupId;

          if (!groupId) {
            throw new Error('No group ID returned');
          }

          setActiveGroup(groupId, groupData.groupName || 'All Rooms');

          // Set favorite as active immediately for optimistic UI update
          markActiveFavorite(entry.favorite.id);
          // Track play action time to prevent refresh interference
          lastPlayActionTime = Date.now();
          // Update now playing immediately with this favorite's metadata
          updateCurrentlyPlaying();

          const commandPromise = sendCommand(
            `/api/groups/${encodeURIComponent(groupId)}/favorites/play`,
            {
              householdId: currentHouseholdId,
              favoriteId: entry.favorite.id,
              shuffle: true,
              repeat: true,
              crossfade: true
            },
            FAVORITE_SUCCESS_TOAST
          );

          const [success] = await Promise.all([commandPromise, delay(2000)]);
          setFavoriteLoading(entry, false);

          if (success) {
            // Store the group ID before loadPlayers might clear it
            const savedGroupId = groupId;
            // Load players before updating currently playing to ensure group state is fresh
            await loadPlayers(currentHouseholdId);
            // Restore the group ID if it was cleared
            if (!getSelectedGroupId() && savedGroupId) {
              setActiveGroup(savedGroupId, groupData.groupName || 'All Rooms');
            }
            
            // Retry logic: if status doesn't match expected favoriteId, retry after short delay
            let retryCount = 0;
            const maxRetries = 3;
            const checkStatus = async () => {
              try {
                const params = new URLSearchParams();
                if (currentHouseholdId) {
                  params.set('householdId', currentHouseholdId);
                }
                const statusUrl = `/api/groups/${encodeURIComponent(savedGroupId)}/playback/status${params.toString() ? '?' + params.toString() : ''}`;
                const response = await fetch(statusUrl);
                if (response.ok) {
                  const status = await response.json();
                  if (status.activeFavoriteId === entry.favorite.id) {
                    // Status matches, update UI
                    updateCurrentlyPlaying();
                  } else if (retryCount < maxRetries) {
                    // Status doesn't match yet, retry
                    retryCount++;
                    setTimeout(checkStatus, 500);
                  } else {
                    // Max retries reached, update anyway
                    updateCurrentlyPlaying();
                  }
                } else {
                  updateCurrentlyPlaying();
                }
              } catch (error) {
                console.error('Failed to check status:', error);
                updateCurrentlyPlaying();
              }
            };
            
            // Check status after a short delay to allow server to update
            setTimeout(checkStatus, 300);
          } else {
            // Playback failed, clear active favorite
            markActiveFavorite(null);
          }
        } catch (error) {
          console.error('Failed to play favourite:', error);
          setFavoriteLoading(entry, false);
          markActiveFavorite(null);
          showFeedback('Failed to start playback. Please try again.', true);
        }

        evaluateFavoritesAvailability();
      }

      function setFavoriteLoading(entry, isLoading) {
        entry.loading = isLoading;
        entry.button.disabled = true;
        if (isLoading) {
          entry.button.classList.add('loading');
        } else {
          entry.button.classList.remove('loading');
        }
      }

      function updateFavoriteStatus(entry, message) {
        entry.statusMessage = message;
        // Status element may not exist for new cards, so check
        if (entry.statusEl) {
          entry.statusEl.textContent = message;
        }
      }

      function evaluateFavoritesAvailability() {
        const enabled = isSonosConnected && Boolean(currentHouseholdId);

        favoritesRegistry.forEach((entry) => {
          if (entry.loading) {
            return;
          }

          entry.button.disabled = !enabled;
          entry.button.classList.toggle('disabled', !enabled);
        });

        if (enabled) {
          markActiveFavorite(currentActiveFavoriteId);
        }
      }

      function markActiveFavorite(favoriteId) {
        currentActiveFavoriteId = favoriteId || null;
        currentActiveFavoriteIdTimestamp = Date.now();

        favoritesRegistry.forEach((entry) => {
          if (entry.loading) {
            return;
          }

          const isActive = Boolean(favoriteId) && entry.favorite.id === favoriteId;
          entry.button.classList.toggle('active', isActive);
        });

        // Update recommendation card buttons
        updateRecommendationCardButtons(favoriteId);
      }

      function updateRecommendationCardButtons(activeFavoriteId) {
        recommendationCardButtons.forEach((button, favoriteId) => {
          const isActive = Boolean(activeFavoriteId) && favoriteId === activeFavoriteId;
          
          if (isActive) {
            button.innerHTML = '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg> Playing';
            button.classList.add('playing');
          } else {
            button.innerHTML = '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg> Play Now';
            button.classList.remove('playing');
          }
        });
      }


      async function setMasterVolume(level, showFeedbackMessage = true) {
        const groupId = getSelectedGroupId();
        if (!groupId) {
          // Auto-grouping is handled on load, but if we still don't have a group, try to create one
          if (currentHouseholdId && latestPlayers.length > 0) {
            try {
              const groupResponse = await fetch(`/api/households/${encodeURIComponent(currentHouseholdId)}/create-all-group`, {
                method: 'POST'
              });
              if (groupResponse.ok) {
                const groupData = await groupResponse.json();
                if (groupData.groupId) {
                  setActiveGroup(groupData.groupId, groupData.groupName || 'All Rooms');
                  // Retry setting volume
                  setMasterVolume(level, showFeedbackMessage);
                  return;
                }
              }
            } catch (error) {
              console.error('Failed to auto-create group:', error);
            }
          }
          if (showFeedbackMessage) {
            showFeedback('Unable to change volume. Please try again.', true);
          }
          return;
        }

        masterVolumeValue.textContent = `${level}%`;
        // Update base volume when user manually adjusts volume
        baseVolume = level;
        const success = await sendCommand(
          `/api/groups/${encodeURIComponent(groupId)}/volume`,
          {
            volume: level
          },
          showFeedbackMessage ? `Volume set to ${level}%.` : null
        );

        if (!success) {
          if (showFeedbackMessage) {
            showFeedback('Unable to update volume. Please try again.', true);
          }
        } else {
          // Update individual player volumes proportionally
          updateIndividualVolumesFromMaster(level);
          // Only refresh status if not dragging (to avoid conflicts)
          if (!isMasterVolumeDragging) {
            setTimeout(() => updateCurrentlyPlaying(), 500);
          }
        }
      }

      function updateIndividualVolumesFromMaster(masterLevel) {
        // Update all individual sliders to match master volume (only if not being dragged)
        const roomRows = currentlyPlayingRoomsList.querySelectorAll('.currently-playing-room-volume');
        roomRows.forEach((row) => {
          const slider = row.querySelector('.currently-playing-room-slider');
          const value = row.querySelector('.currently-playing-room-value');
          if (slider && value) {
            // Only update if user is not currently dragging this slider
            if (slider.dataset.isDragging !== 'true') {
              slider.value = masterLevel;
            }
            value.textContent = `${masterLevel}`;
          }
        });
      }

      async function sendCommand(endpoint, body, successMessage = 'Command sent to Sonos.') {
        try {
          const response = await fetch(endpoint, {
            method: 'POST',
            headers: body ? { 'Content-Type': 'application/json' } : undefined,
            body: body ? JSON.stringify(body) : undefined
          });

          if (response.status === 401) {
            setAuthUI(false);
            showFeedback('Session expired. Please login again.', true);
            return false;
          }

          if (!response.ok) {
            throw new Error(await response.text());
          }

          if (successMessage) {
            showFeedback(successMessage);
          }
          return true;
        } catch (error) {
          console.error('Command failed:', error);
          showFeedback('Unable to reach Sonos. Please try again.', true);
          return false;
        }
      }

      function delay(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

  evaluateFavoritesAvailability();
  applyAuthFeedback();
  showView('control');

      async function loadPlayers(householdId) {
        if (!householdId) {
          latestPlayers = [];
          latestGroups = [];
          ensureActiveGroup([]);
          return;
        }

        try {
          clearTimeout(refreshTimer);
          refreshTimer = null;
          const response = await fetch(`/api/households/${encodeURIComponent(householdId)}/players`);

          if (response.status === 401) {
            setAuthUI(false);
            favoritesStatus.textContent = 'Login required to load favourites.';
            return;
          }

          if (!response.ok) {
            throw new Error(await response.text());
          }

          const data = await response.json();
          latestPlayers = Array.isArray(data.players) ? data.players : [];
          latestGroups = Array.isArray(data.groups) ? data.groups : [];

          ensureActiveGroup(latestPlayers);
          let activeGroupId = getSelectedGroupId();
          
          // Automatically create and select a group with all players if none is selected
          if (!activeGroupId && latestPlayers.length > 0 && currentHouseholdId) {
            try {
              const groupResponse = await fetch(`/api/households/${encodeURIComponent(currentHouseholdId)}/create-all-group`, {
                method: 'POST'
              });
              
              if (groupResponse.ok) {
                const groupData = await groupResponse.json();
                if (groupData.groupId) {
                  setActiveGroup(groupData.groupId, groupData.groupName || 'All Rooms');
                  activeGroupId = groupData.groupId;
                }
              }
            } catch (error) {
              console.error('Failed to auto-create group:', error);
            }
          }
          
          // Check for currently playing content after a short delay to ensure everything is loaded
          setTimeout(async () => {
            // Use the active group (either existing or newly created)
            if (activeGroupId) {
              updateCurrentlyPlayingRooms(activeGroupId);
              await updateCurrentlyPlaying();
              startPlaybackRefresh();
            } else if (latestGroups.length > 0) {
              // If still no group, check all groups to find which one is playing
              for (const group of latestGroups) {
                const groupId = group.id || group.groupId;
                if (!groupId) continue;
                
                try {
                  const params = new URLSearchParams();
                  if (currentHouseholdId) {
                    params.set('householdId', currentHouseholdId);
                  }
                  const statusUrl = `/api/groups/${encodeURIComponent(groupId)}/playback/status${params.toString() ? '?' + params.toString() : ''}`;
                  const response = await fetch(statusUrl);
                  if (response.ok) {
                    const status = await response.json();
                    const playbackState = status.playbackState || status.state || 'STOPPED';
                    const isPlaying = playbackState === 'PLAYING' || playbackState === 'PLAYBACK_STATE_PLAYING';
                    const hasContent = !!(status.track || status.currentItem || status.item);
                    
                    if (isPlaying || hasContent || playbackState !== 'STOPPED') {
                      // Found a group with playback - set it as active
                      setActiveGroup(groupId, group.name || group.displayName || 'Group');
                      updateCurrentlyPlayingRooms(groupId);
                      await updateCurrentlyPlaying();
                      startPlaybackRefresh();
                      break;
                    }
                  }
                } catch (error) {
                  // Continue to next group
                  continue;
                }
              }
            }
          }, 500);
        } catch (error) {
          console.error('Failed to load players', error);
        }
      }

      function ensureActiveGroup(players) {
        if (currentGroupId && players.some((player) => player.groupId === currentGroupId)) {
          const active = players.find((player) => player.groupId === currentGroupId);
          if (active) {
            currentGroupName = active.groupName || active.name || currentGroupName;
          }
        } else {
          // Don't clear the group if panel is visible (we're in the middle of playback)
          if (panelShouldBeVisible && currentGroupId) {
            return; // Keep the existing group ID
          }
          const candidate = players.find((player) => player.groupId);
          if (candidate) {
            currentGroupId = candidate.groupId;
            currentGroupName = candidate.groupName || candidate.name || 'Group';
          } else {
            // Only clear if panel isn't visible
            if (!panelShouldBeVisible) {
              currentGroupId = null;
              currentGroupName = 'No group selected';
            }
          }
        }
        updateActiveGroupDisplay();
        evaluateFavoritesAvailability();
      }


      async function setPlayerVolume(playerId, level, showFeedbackMessage = true) {
        if (!playerId) {
          return;
        }

        const numericLevel = Number(level);

        try {
          const postResponse = await fetch(`/api/players/${encodeURIComponent(playerId)}/volume`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ level: numericLevel })
          });

          if (!postResponse.ok) {
            throw new Error(await postResponse.text());
          }

          // Only fetch and update if not dragging (to avoid conflicts during drag)
          const roomRow = document.querySelector(`[data-player-id="${playerId}"]`);
          const slider = roomRow?.querySelector('.currently-playing-room-slider');
          const isDragging = slider && slider.dataset.isDragging === 'true';
          
          if (!isDragging) {
            const getResponse = await fetch(`/api/players/${encodeURIComponent(playerId)}/volume`);
            if (getResponse.ok) {
              const payload = await getResponse.json();
              const updatedLevel = Number(
                payload.volume ?? payload?.volume?.volume ?? payload.level ?? numericLevel
              );
              
              if (roomRow && slider) {
                const value = roomRow.querySelector('.currently-playing-room-value');
                const expectedValue = slider.dataset.expectedValue ? Number(slider.dataset.expectedValue) : null;
                
                // If we have an expected value, only update if server matches it (prevents snap-back)
                if (expectedValue !== null && expectedValue !== '') {
                  if (Math.abs(updatedLevel - expectedValue) <= 1) {
                    // Server volume matches expected - clear expected value and update
                    console.log('[Client] Player volume confirmed by server:', {
                      playerId,
                      expected: expectedValue,
                      received: updatedLevel,
                      match: true
                    });
                    slider.dataset.expectedValue = '';
                    slider.value = updatedLevel;
                    if (value) value.textContent = updatedLevel;
                  } else {
                    // Server hasn't caught up yet - keep slider at expected value to prevent snap-back
                    console.log('[Client] Player volume update ignored (waiting for server):', {
                      playerId,
                      expected: expectedValue,
                      received: updatedLevel,
                      difference: Math.abs(updatedLevel - expectedValue)
                    });
                    // Force slider to stay at expected value
                    slider.value = expectedValue;
                    if (value) value.textContent = expectedValue;
                  }
                } else {
                  // No expected value - safe to update normally
                  slider.value = updatedLevel;
                  if (value) value.textContent = updatedLevel;
                }
              }
            }
          }

          if (currentHouseholdId && !isDragging) {
            setTimeout(() => loadPlayers(currentHouseholdId), 500);
          }
        } catch (error) {
          console.error('Failed to update player volume:', error);
          if (showFeedbackMessage) {
            showFeedback('Unable to update room volume. Please try again.', true);
          }
        }
      }

      async function refreshUI() {
        await loadHouseholds();
      }

      evaluateFavoritesAvailability();
      updateActiveGroupDisplay();

      async function updateCurrentlyPlaying() {
        let groupId = getSelectedGroupId();
        
        // If no group is selected but we have groups, try the first one
        if (!groupId && latestGroups.length > 0 && isSonosConnected) {
          const firstGroup = latestGroups.find(g => g.id || g.groupId);
          if (firstGroup) {
            groupId = firstGroup.id || firstGroup.groupId;
            // Set it as active so refresh continues
            if (groupId && !currentGroupId) {
              setActiveGroup(groupId, firstGroup.name || firstGroup.displayName || 'Group');
            }
          }
        }
        
        if (!groupId || !isSonosConnected) {
          // Only hide if panel wasn't previously visible (don't hide during transitions)
          if (!panelShouldBeVisible) {
            clearTimeout(hidePanelTimeout);
            currentlyPlayingPanel.classList.remove('visible');
            document.body.classList.remove('has-playing');
          }
          return;
        }

        try {
          const params = new URLSearchParams();
          if (currentHouseholdId) {
            params.set('householdId', currentHouseholdId);
          }
          const statusUrl = `/api/groups/${encodeURIComponent(groupId)}/playback/status${params.toString() ? '?' + params.toString() : ''}`;
          const response = await fetch(statusUrl);
          if (!response.ok) {
            throw new Error('Failed to fetch playback status');
          }

          const status = await response.json();
          const statusUpdateTime = Date.now();
          
          // Log what we received from server
          console.log('[Client] Status received:', {
            groupId,
            volume: status.volume || 0,
            activeFavoriteId: status.activeFavoriteId,
            activeFavorite: status.activeFavorite ? {
              id: status.activeFavorite.id,
              name: status.activeFavorite.name
            } : null,
            playbackState: status.playbackState
          });
          
          // Ignore responses that arrive out of order (if we got a newer one recently)
          // Only ignore if we got an update in the last 500ms and this one seems stale
          if (lastStatusUpdateTime > 0 && statusUpdateTime < lastStatusUpdateTime - 500) {
            console.warn('[Client] Ignoring out-of-order status response:', {
              behind: lastStatusUpdateTime - statusUpdateTime,
              volume: status.volume,
              activeFavoriteId: status.activeFavoriteId
            });
            return;
          }
          lastStatusUpdateTime = statusUpdateTime;
          
          currentPlaybackState = status;

          const apiPlaybackState = status.playbackState || status.state || status.playback?.state || 'STOPPED';
          
          // Normalize API state (handle PLAYBACK_STATE_PLAYING, PLAYING, etc.)
          let normalizedApiState = apiPlaybackState;
          if (typeof apiPlaybackState === 'string') {
            if (apiPlaybackState.includes('PLAYING')) {
              normalizedApiState = 'PLAYING';
            } else if (apiPlaybackState.includes('PAUSED') || apiPlaybackState.includes('IDLE')) {
              normalizedApiState = 'PAUSED';
            } else if (apiPlaybackState.includes('STOPPED')) {
              normalizedApiState = 'STOPPED';
            }
          }
          
          // Use normalized API state for playback state
          let playbackState = normalizedApiState;
          
          const isPlaying = playbackState === 'PLAYING';
          
          const item = status.currentItem || status.item || status.playback?.currentItem || null;
          const track = item?.track || item?.container?.metadata || status.track || null;
          
          // Track change detection and volume adjustment based on replayGain
          if (track) {
            // Create a unique track identifier (use id if available, otherwise name + artist)
            const trackName = track.name || track.title || '';
            const trackArtist = typeof track.artist === 'string' ? track.artist : (track.artist?.name || track.artist?.value || '');
            const trackId = track.id || (trackName && trackArtist ? `${trackName}_${trackArtist}` : trackName || 'unknown');
            
            // Check if track has changed (only if we have a valid identifier)
            const trackChanged = trackId && trackId !== 'unknown' && trackId !== previousTrackId;
            
            if (trackChanged && isPlaying) {
              // Store base volume on first track or when user manually adjusts volume
              // If baseVolume is null, use current volume as base
              if (baseVolume === null) {
                const currentVolume = status.volume || 0;
                baseVolume = currentVolume;
              }
              
              // Apply volume adjustment if replayGain is available
              if (track.replayGain !== null && track.replayGain !== undefined && Number.isFinite(track.replayGain)) {
                const replayGain = Number(track.replayGain);
                
                // Convert dB to linear volume adjustment
                // replayGain is in dB, convert to linear: 10^(dB/20)
                const volumeAdjustment = Math.pow(10, replayGain / 20);
                
                // Calculate target volume based on base volume
                let targetVolume = baseVolume * volumeAdjustment;
                
                // Clamp between 0-100
                targetVolume = Math.max(0, Math.min(100, Math.round(targetVolume)));
                
                // Only adjust if the difference is significant (more than 1%)
                if (Math.abs(targetVolume - baseVolume) > 1) {
                  // Apply volume adjustment
                  sendCommand(
                    `/api/groups/${encodeURIComponent(groupId)}/volume`,
                    { volume: targetVolume },
                    `Volume adjusted for track loudness (${replayGain > 0 ? '+' : ''}${replayGain.toFixed(1)} dB).`
                  ).catch(err => {
                    console.error('Failed to adjust volume for replayGain:', err);
                  });
                }
              }
              
            }
            
            // Update previous track ID even if no replayGain (to prevent repeated adjustments)
            if (trackId && trackId !== 'unknown') {
              previousTrackId = trackId;
            }
          }
          
          // Reset track tracking when playback stops
          if (!isPlaying || playbackState === 'STOPPED') {
            previousTrackId = null;
          }
          
          // Determine if we should show the panel - be more permissive
          const hasContent = !!(track || item);
          const isActive = isPlaying || playbackState !== 'STOPPED';
          
          // If we have content OR are playing, show the panel
          // If panel was visible, keep it visible (don't hide during transitions)
          if (hasContent || isActive || panelShouldBeVisible) {
            panelShouldBeVisible = true;
            clearTimeout(hidePanelTimeout);
            
            const groupInfo = latestGroups.find((g) => g.id === groupId || g.groupId === groupId);
            const groupName = groupInfo?.name || currentGroupName || 'Unknown Group';

            // Sync currentActiveFavoriteId with status to keep highlighted favorite in sync with now playing
            // IMPORTANT: Only update if this status is for the current groupId to prevent cross-group confusion
            const statusActiveFavoriteId = status.activeFavoriteId;
            let activeFavoriteId = currentActiveFavoriteId;
            
            // Only sync FROM status if:
            // 1. Status has a non-null value (not null, not undefined)
            // 2. Status value differs from current
            // 3. Don't clear currentActiveFavoriteId if status returns null/undefined during active playback (might be stale)
            // 4. Only update if enough time has passed since last update (prevent rapid switching from race conditions)
            if (statusActiveFavoriteId !== undefined && statusActiveFavoriteId !== null) {
              if (statusActiveFavoriteId !== currentActiveFavoriteId) {
                // Only update if enough time has passed (2 seconds) to prevent rapid switching from stale responses
                const timeSinceLastUpdate = Date.now() - currentActiveFavoriteIdTimestamp;
                if (timeSinceLastUpdate > 2000 || currentActiveFavoriteIdTimestamp === 0) {
                  // Status has a different non-null value - update to match
                  console.log('[Client] activeFavoriteId changed:', {
                    from: currentActiveFavoriteId,
                    to: statusActiveFavoriteId,
                    groupId,
                    timeSinceLastUpdate
                  });
                  currentActiveFavoriteId = statusActiveFavoriteId;
                  currentActiveFavoriteIdTimestamp = Date.now();
                  markActiveFavorite(statusActiveFavoriteId);
                  activeFavoriteId = statusActiveFavoriteId;
                } else {
                  // Ignore rapid changes - likely stale responses from different groups or race conditions
                  console.warn('[Client] Ignoring rapid activeFavoriteId change:', {
                    from: currentActiveFavoriteId,
                    to: statusActiveFavoriteId,
                    groupId,
                    timeSinceLastUpdate,
                    reason: 'might be stale'
                  });
                }
              } else {
                // Status matches current - use it for display
                activeFavoriteId = statusActiveFavoriteId;
              }
            } else if (statusActiveFavoriteId === null && currentActiveFavoriteId && !isPlaying && playbackState === 'STOPPED') {
              // Only clear if playback has actually stopped (not just paused or during transitions)
              console.log('[Client] activeFavoriteId cleared:', {
                from: currentActiveFavoriteId,
                to: null,
                groupId,
                reason: 'playback stopped'
              });
              currentActiveFavoriteId = null;
              activeFavoriteId = null;
            }
            // If status is undefined or null during active playback, keep using currentActiveFavoriteId (don't clear it - might be stale)

            let playlistName = null;
            let playlistImageUrl = null;
            if (activeFavoriteId) {
              // Prefer favorite data from status response (more reliable, works across households)
              const statusFavorite = status.activeFavorite;
              
              if (statusFavorite && statusFavorite.id === activeFavoriteId && statusFavorite.name) {
                playlistName = statusFavorite.name;
                playlistImageUrl = statusFavorite.imageUrl || null;
                console.log('[Client] Playlist name resolved:', {
                  source: 'status.activeFavorite',
                  activeFavoriteId,
                  playlistName
                });
              } else {
                // Fallback to favoritesRegistry (client-side cache)
                const favoriteEntry = favoritesRegistry.get(activeFavoriteId);
                const reason = statusFavorite 
                  ? (statusFavorite.id === activeFavoriteId ? 'missing name' : 'ID mismatch')
                  : 'missing';
                
                // Always log the resolution attempt, even if favoritesRegistry is missing
                if (favoriteEntry && favoriteEntry.favorite) {
                  playlistName = favoriteEntry.favorite.name || null;
                  // Get playlist cover art
                  const favorite = favoriteEntry.favorite;
                  playlistImageUrl = favorite?.imageUrl
                    ? (typeof favorite.imageUrl === 'string' ? favorite.imageUrl : favorite.imageUrl?.url || favorite.imageUrl?.value || null)
                    : favorite?.images && favorite.images.length && favorite.images[0]?.url
                      ? favorite.images[0].url
                      : favorite?.container?.imageUrl
                        ? (typeof favorite.container.imageUrl === 'string' ? favorite.container.imageUrl : favorite.container.imageUrl?.url || favorite.container.imageUrl?.value || null)
                        : null;
                  console.log('[Client] Playlist name resolved:', {
                    source: 'favoritesRegistry',
                    activeFavoriteId,
                    playlistName,
                    statusIssue: reason
                  });
                } else {
                  // favoritesRegistry missing or incomplete - log it
                  console.log('[Client] Playlist name resolved:', {
                    source: 'favoritesRegistry',
                    activeFavoriteId,
                    playlistName: null,
                    statusIssue: reason,
                    favoritesRegistry: favoriteEntry ? 'present but no favorite' : 'missing'
                  });
                  
                  // Last resort: use status name if available
                  if (statusFavorite && statusFavorite.id === activeFavoriteId && statusFavorite.name) {
                    playlistName = statusFavorite.name;
                    playlistImageUrl = statusFavorite.imageUrl || null;
                    console.log('[Client] Playlist name resolved (fallback):', {
                      source: 'status.activeFavorite',
                      activeFavoriteId,
                      playlistName,
                      note: 'favoritesRegistry missing'
                    });
                  } else {
                    console.warn('[Client] Playlist name NOT FOUND:', {
                      activeFavoriteId,
                      statusActiveFavorite: statusFavorite ? {
                        id: statusFavorite.id,
                        hasName: !!statusFavorite.name,
                        idMatch: statusFavorite.id === activeFavoriteId
                      } : null,
                      favoritesRegistry: favoriteEntry ? 'present but no favorite' : 'missing'
                    });
                  }
                }
              }
            }
            
            const title = track?.name || track?.title || item?.name || (isPlaying ? 'Loading...' : 'Unknown Track');
            
            let artist = '';
            if (track?.artist) {
              artist = typeof track.artist === 'string' ? track.artist : track.artist?.name || track.artist?.value || '';
            } else if (track?.albumArtist) {
              artist = typeof track.albumArtist === 'string' ? track.albumArtist : track.albumArtist?.name || track.albumArtist?.value || '';
            } else if (track?.creator) {
              artist = typeof track.creator === 'string' ? track.creator : track.creator?.name || track.creator?.value || '';
            }
            
            let album = '';
            if (track?.album) {
              album = typeof track.album === 'string' ? track.album : track.album?.name || track.album?.value || '';
            } else if (track?.albumName) {
              album = typeof track.albumName === 'string' ? track.albumName : track.albumName?.name || track.albumName?.value || '';
            }
            
            // Use playlist image instead of track image
            let imageUrl = playlistImageUrl;
            
            if (imageUrl && !imageUrl.startsWith('http')) {
              imageUrl = null;
            }

            currentlyPlayingTitle.textContent = title;
            currentlyPlayingArtist.innerHTML = '';
            if (artist) {
              const artistSpan = document.createElement('span');
              artistSpan.textContent = artist;
              currentlyPlayingArtist.appendChild(artistSpan);
            }
            if (album && artist) {
              const separator = document.createTextNode('  ');
              currentlyPlayingArtist.appendChild(separator);
              const albumSpan = document.createElement('span');
              albumSpan.textContent = album;
              currentlyPlayingArtist.appendChild(albumSpan);
            }
            if (!artist && !album) {
              currentlyPlayingArtist.innerHTML = '<span>Sonos</span>';
            }

            // Update loudness indicator if replayGain is available
            if (track && track.replayGain !== null && track.replayGain !== undefined && Number.isFinite(track.replayGain)) {
              const replayGain = Number(track.replayGain);
              const loudnessLabel = currentlyPlayingLoudness.querySelector('.loudness-label');
              
              if (loudnessLabel) {
                // Determine loudness category
                let loudnessText = '';
                if (replayGain > 3) {
                  loudnessText = 'Loud';
                } else if (replayGain > -3) {
                  loudnessText = 'Normal';
                } else {
                  loudnessText = 'Quiet';
                }
                
                // Display with dB value
                loudnessLabel.textContent = `${loudnessText} (${replayGain > 0 ? '+' : ''}${replayGain.toFixed(1)} dB)`;
                currentlyPlayingLoudness.style.display = 'block';
              }
            } else {
              currentlyPlayingLoudness.style.display = 'none';
              // Debug: log when replayGain is not available
              if (track) {
              }
            }

            currentlyPlayingLocation.innerHTML = `<span>${playlistName || groupName}</span>`;

            // Handle image loading - always proxy through server
            // Calculate the final URL we'll use (proxy URL if HTTP/HTTPS)
            let finalImageUrl = null;
            if (imageUrl) {
              if (imageUrl.startsWith('http://') || imageUrl.startsWith('https://')) {
                finalImageUrl = `/api/image-proxy?url=${encodeURIComponent(imageUrl)}`;
              } else {
                finalImageUrl = imageUrl;
              }
            }
            
            // Only update if the final URL has actually changed
            if (finalImageUrl && finalImageUrl !== currentImageUrl) {
              loadImage(finalImageUrl, imageUrl);
            } else if (!finalImageUrl) {
              // No image - only show placeholder if there's no image element
              if (!currentlyPlayingArt.querySelector('img')) {
                currentlyPlayingArt.innerHTML = '<span class="currently-playing-art-placeholder"></span>';
              }
            }
            
            function loadImage(url, originalUrl) {
              currentImageUrl = url;
              
              // Check if there's already an img element - if so, just update src
              const existingImg = currentlyPlayingArt.querySelector('img');
              if (existingImg) {
                existingImg.src = url;
                existingImg.alt = title;
                return;
              }
              
              // Otherwise create new img element
              const img = document.createElement('img');
              img.alt = title;
              img.loading = 'lazy';
              img.style.width = '100%';
              img.style.height = '100%';
              img.style.objectFit = 'cover';
              
              img.onerror = () => {
                currentlyPlayingArt.innerHTML = '<span class="currently-playing-art-placeholder"></span>';
                currentImageUrl = null;
              };
              
              currentlyPlayingArt.innerHTML = '';
              currentlyPlayingArt.appendChild(img);
              img.src = url;
            }

            const playerCount = latestPlayers.filter((p) => p.groupId === groupId).length;
            if (playerCount > 1) {
              currentlyPlayingGroupIndicator.style.display = 'grid';
              currentlyPlayingGroupCount.textContent = playerCount;
              currentlyPlayingGroupCount.style.display = 'grid';
            } else {
              currentlyPlayingGroupIndicator.style.display = 'none';
              currentlyPlayingGroupCount.style.display = 'none';
            }

            // Toggle play/pause icon for right-side button using CSS classes
            // When isPlaying is true, show pause icon (add .playing class)
            // When isPlaying is false, show play icon (remove .playing class)

            // Update master volume from group volume (only if user is not dragging and volume matches expected)
            if (!isMasterVolumeDragging) {
              const groupVolume = status.volume || 0;
              // If we have an expected value, only update if server matches it (prevents snap-back)
              if (masterVolumeExpectedValue !== null) {
                if (Math.abs(groupVolume - masterVolumeExpectedValue) <= 1) {
                  // Server volume matches expected - clear expected value and update
                  console.log('[Client] Master volume confirmed by server:', {
                    expected: masterVolumeExpectedValue,
                    received: groupVolume,
                    match: true
                  });
                  masterVolumeExpectedValue = null;
                  masterVolumeSlider.value = groupVolume;
                  masterVolumeValue.textContent = `${groupVolume}%`;
                } else {
                  // Server hasn't caught up yet - keep slider at expected value to prevent snap-back
                  console.log('[Client] Master volume update ignored (waiting for server):', {
                    expected: masterVolumeExpectedValue,
                    received: groupVolume,
                    difference: Math.abs(groupVolume - masterVolumeExpectedValue)
                  });
                  // Force slider to stay at expected value
                  masterVolumeSlider.value = masterVolumeExpectedValue;
                  masterVolumeValue.textContent = `${masterVolumeExpectedValue}%`;
                }
              } else {
                // No expected value - safe to update normally
                masterVolumeSlider.value = groupVolume;
                masterVolumeValue.textContent = `${groupVolume}%`;
              }
            }

            updateCurrentlyPlayingRooms(groupId);

            currentlyPlayingPanel.classList.add('visible');
            document.body.classList.add('has-playing');
          } else {
            // Only hide if we're truly stopped - use a delay to prevent flickering
            if (playbackState === 'STOPPED' && !isPlaying) {
              clearTimeout(hidePanelTimeout);
              hidePanelTimeout = setTimeout(() => {
                if (!panelShouldBeVisible) {
                  currentlyPlayingPanel.classList.remove('visible');
                  document.body.classList.remove('has-playing');
                  currentImageUrl = null;
                }
              }, 2000); // Wait 2 seconds before hiding
            }
          }
        } catch (error) {
          console.error('Failed to update currently playing:', error);
          currentlyPlayingPanel.classList.remove('visible');
          document.body.classList.remove('has-playing');
        }
      }

      function updateCurrentlyPlayingRooms(groupId) {
        if (!groupId || !latestPlayers.length) {
          currentlyPlayingRoomsList.innerHTML = '';
          return;
        }

        // Since we're auto-grouping all players, show all players
        // The groupId format is "RINCON_XXX:PORT" where RINCON_XXX is the coordinator
        // We'll show all players since they're all in the same auto-created group
        const groupPlayers = latestPlayers;
        
        // Check if any sliders are currently being dragged
        const existingRows = currentlyPlayingRoomsList.querySelectorAll('.currently-playing-room-volume');
        const anyDragging = Array.from(existingRows).some(row => {
          const slider = row.querySelector('.currently-playing-room-slider');
          return slider && slider.dataset.isDragging === 'true';
        });
        
        // If any slider is being dragged, don't recreate the DOM - just update values
        if (anyDragging) {
          groupPlayers.forEach((player) => {
            const existingRow = currentlyPlayingRoomsList.querySelector(`[data-player-id="${player.id}"]`);
            if (existingRow) {
              const slider = existingRow.querySelector('.currently-playing-room-slider');
              const value = existingRow.querySelector('.currently-playing-room-value');
              const playerVolume = Number.isFinite(Number(player.volume)) ? Number(player.volume) : 0;
              
              // Only update if not being dragged
              if (slider && slider.dataset.isDragging !== 'true') {
                const expectedValue = slider.dataset.expectedValue ? Number(slider.dataset.expectedValue) : null;
                
                // If we have an expected value, only update if server matches it (prevents snap-back)
                if (expectedValue !== null && expectedValue !== '') {
                  if (Math.abs(playerVolume - expectedValue) <= 1) {
                    // Server volume matches expected - clear expected value and update
                    slider.dataset.expectedValue = '';
                    slider.value = playerVolume;
                    if (value) value.textContent = playerVolume;
                  } else {
                    // Server hasn't caught up yet - keep slider at expected value to prevent snap-back
                    slider.value = expectedValue;
                    if (value) value.textContent = expectedValue;
                  }
                } else {
                  // No expected value - safe to update normally
                  slider.value = playerVolume;
                  if (value) value.textContent = playerVolume;
                }
              }
            } else {
              // Player doesn't exist yet, create it
              const roomRow = createRoomVolumeRow(player);
              currentlyPlayingRoomsList.appendChild(roomRow);
            }
          });
          return;
        }
        
        // No sliders being dragged - safe to recreate
        currentlyPlayingRoomsList.innerHTML = '';

        groupPlayers.forEach((player) => {
          const roomRow = createRoomVolumeRow(player);
          currentlyPlayingRoomsList.appendChild(roomRow);
        });
      }

      function createRoomVolumeRow(player) {
        const roomRow = document.createElement('div');
        roomRow.className = 'currently-playing-room-volume';
        roomRow.dataset.playerId = player.id;

        const name = document.createElement('span');
        name.className = 'currently-playing-room-name';
        name.textContent = player.name || player.id || 'Room';

        const slider = document.createElement('input');
        slider.type = 'range';
        slider.className = 'currently-playing-room-slider';
        slider.min = '0';
        slider.max = '100';
        slider.value = Number.isFinite(Number(player.volume)) ? Number(player.volume) : 0;
        slider.dataset.isDragging = 'false';
        slider.dataset.expectedValue = ''; // Track expected volume after release

        const value = document.createElement('span');
        value.className = 'currently-playing-room-value';
        value.textContent = `${slider.value}`;

        let playerVolumeUpdateTimeout = null;

        slider.addEventListener('input', (e) => {
          e.stopPropagation();
          const newValue = Number(e.target.value);
          value.textContent = newValue;
          
          // Send update immediately while dragging (debounced to avoid too many requests)
          if (slider.dataset.isDragging === 'true') {
            clearTimeout(playerVolumeUpdateTimeout);
            const playerId = roomRow.dataset.playerId;
            if (playerId) {
              playerVolumeUpdateTimeout = setTimeout(() => {
                setPlayerVolume(playerId, newValue, false); // false = don't show feedback for intermediate updates
              }, 50); // Debounce to 50ms
            }
          }
        });

        slider.addEventListener('mousedown', () => {
          slider.dataset.isDragging = 'true';
          slider.dataset.expectedValue = ''; // Clear expected value when starting to drag
        });

        slider.addEventListener('touchstart', () => {
          slider.dataset.isDragging = 'true';
          slider.dataset.expectedValue = ''; // Clear expected value when starting to drag
        });

        slider.addEventListener('change', async (e) => {
          e.stopPropagation();
          const finalValue = Number(e.target.value);
          slider.dataset.expectedValue = finalValue.toString(); // Set expected value on release
          slider.dataset.isDragging = 'false';
          clearTimeout(playerVolumeUpdateTimeout);
          const playerId = roomRow.dataset.playerId;
          if (playerId) {
            await setPlayerVolume(playerId, finalValue, true); // true = show feedback for final update
          }
        });

        slider.addEventListener('mouseup', async () => {
          if (slider.dataset.isDragging === 'true') {
            const finalValue = Number(slider.value);
            slider.dataset.expectedValue = finalValue.toString(); // Set expected value on release
            slider.dataset.isDragging = 'false';
            clearTimeout(playerVolumeUpdateTimeout);
            const playerId = roomRow.dataset.playerId;
            if (playerId) {
              await setPlayerVolume(playerId, finalValue, true); // true = show feedback for final update
            }
          }
        });

        slider.addEventListener('touchend', async () => {
          if (slider.dataset.isDragging === 'true') {
            const finalValue = Number(slider.value);
            slider.dataset.expectedValue = finalValue.toString(); // Set expected value on release
            slider.dataset.isDragging = 'false';
            clearTimeout(playerVolumeUpdateTimeout);
            const playerId = roomRow.dataset.playerId;
            if (playerId) {
              await setPlayerVolume(playerId, finalValue, true); // true = show feedback for final update
            }
          }
        });

        // Prevent panel from closing when interacting with slider
        slider.addEventListener('pointerdown', (e) => {
          e.stopPropagation();
        });
        slider.addEventListener('mousedown', (e) => {
          e.stopPropagation();
        });
        slider.addEventListener('touchstart', (e) => {
          e.stopPropagation();
        });
        slider.addEventListener('touchmove', (e) => {
          e.stopPropagation();
        });
        slider.addEventListener('touchend', (e) => {
          e.stopPropagation();
        });

        roomRow.appendChild(name);
        roomRow.appendChild(slider);
        roomRow.appendChild(value);
        return roomRow;
        
      }

      function startPlaybackRefresh() {
        clearInterval(playbackRefreshTimer);
        playbackRefreshTimer = setInterval(() => {
          if (isSonosConnected && getSelectedGroupId()) {
            // Don't refresh if a play action just occurred (within last 2 seconds)
            // This prevents refresh from overwriting correct metadata during play operations
            const timeSinceLastPlayAction = Date.now() - lastPlayActionTime;
            if (timeSinceLastPlayAction > 2000) {
              updateCurrentlyPlaying();
            }
          }
        }, 3000);
        // Only update immediately if no recent play action
        const timeSinceLastPlayAction = Date.now() - lastPlayActionTime;
        if (timeSinceLastPlayAction > 2000) {
          updateCurrentlyPlaying();
        }
      }
      
      function stopPlaybackRefresh() {
        clearInterval(playbackRefreshTimer);
        playbackRefreshTimer = null;
      }


      // Use event delegation on the panel itself - simpler and more reliable
      currentlyPlayingPanel.addEventListener('click', (e) => {
        // Don't toggle if clicking on interactive elements
        const roomVolume = e.target.closest('.currently-playing-room-volume');
        const roomSlider = e.target.closest('.currently-playing-room-slider');
        const rangeInput = e.target.closest('input[type="range"]');
        const masterVolume = e.target.closest('.currently-playing-master-volume');
        
        if (roomVolume || roomSlider || rangeInput || masterVolume) {
          return;
        }
        
        // Toggle expanded state
        currentlyPlayingPanel.classList.toggle('expanded');
        
        // Update rooms when expanding (in case they weren't loaded yet)
        if (currentlyPlayingPanel.classList.contains('expanded')) {
          const groupId = getSelectedGroupId();
          if (groupId) {
            updateCurrentlyPlayingRooms(groupId);
          }
        }
      });

      // Close panel when clicking outside of it
      document.addEventListener('click', (e) => {
        if (!currentlyPlayingPanel.classList.contains('visible')) {
          return;
        }
        
        // If click is outside the panel, close it
        if (!currentlyPlayingPanel.contains(e.target)) {
          currentlyPlayingPanel.classList.remove('expanded');
        }
      });

      // Close panel when scrolling starts (only if scroll is outside the panel)
      let isScrolling = false;
      document.addEventListener('scroll', (e) => {
        if (!currentlyPlayingPanel.classList.contains('visible') || !currentlyPlayingPanel.classList.contains('expanded')) {
          return;
        }
        
        // Check if the scroll event originated from within the panel
        const target = e.target;
        if (target && currentlyPlayingPanel.contains(target)) {
          return; // Don't close if scrolling within the panel
        }
        
        // Check if the scroll happened on the document/body (outside the panel)
        if (target === document || target === document.body || target === document.documentElement) {
          // Close immediately when scrolling starts outside the panel
          if (!isScrolling) {
            isScrolling = true;
            currentlyPlayingPanel.classList.remove('expanded');
          }
        }
      }, { passive: true, capture: true });

      // Close panel on touchmove (mobile scrolling) - only if touch is outside the panel
      document.addEventListener('touchmove', (e) => {
        if (!currentlyPlayingPanel.classList.contains('visible') || !currentlyPlayingPanel.classList.contains('expanded')) {
          return;
        }
        
        // Check if the touch event originated from within the panel
        const target = e.target;
        if (target && currentlyPlayingPanel.contains(target)) {
          return; // Don't close if touching/swiping within the panel
        }
        
        // Only close if touch is outside the panel
        currentlyPlayingPanel.classList.remove('expanded');
      }, { passive: true, capture: true });

      // Reset scrolling flag when scroll ends
      let scrollEndTimeout = null;
      document.addEventListener('scroll', () => {
        clearTimeout(scrollEndTimeout);
        scrollEndTimeout = setTimeout(() => {
          isScrolling = false;
        }, 150);
      }, { passive: true });


      function setActiveGroup(groupId, name, { refreshFavorites = false } = {}) {
        currentGroupId = groupId || null;
        currentGroupName = currentGroupId ? name || currentGroupName || 'Group' : 'No group selected';
        updateActiveGroupDisplay();
        evaluateFavoritesAvailability();
        if (refreshFavorites && currentHouseholdId) {
          loadFavorites(currentHouseholdId).catch((error) => {
            console.error('Failed to refresh favorites', error);
          });
        }
        if (groupId) {
          startPlaybackRefresh();
        } else {
          stopPlaybackRefresh();
        }
      }

      window.addEventListener('load', () => {
        // Loading screen is already visible by default
        applyAuthFeedback();
        checkAuthAndInit();
      });
    </script>


  </body>
</html>
